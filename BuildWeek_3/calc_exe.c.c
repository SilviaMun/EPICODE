//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>
#include <windows.h>

// ---------------- Integer Types Definitions -----------------

typedef int64_t int128_t;
typedef int64_t int224_t;
typedef int64_t int864_t;

// ----------------- Float Types Definitions ------------------

typedef float float32_t;
typedef double float64_t;
typedef long double float80_t;

// ------------------------ Structures ------------------------

struct struct1 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
};

struct tagPOINT {
    int32_t e0;
    int32_t e1;
};

struct tagWNDCLASSEXW {
    int32_t e0;
    int32_t e1;
    int32_t (*e2)(int32_t *, int32_t, int32_t, int32_t);
    int32_t e3;
    int32_t e4;
    int32_t * e5;
    int32_t * e6;
    int32_t * e7;
    int32_t * e8;
    int16_t * e9;
    int16_t * e10;
    int32_t * e11;
};

// ------------------- Function Prototypes --------------------

int32_t entry_point(void);
int32_t function_100125b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, uint32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, uint32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, uint32_t a18, uint32_t a19, int32_t a20, int32_t a21, int32_t a22, int32_t a23);
int32_t function_1001473(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, uint32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11);
int32_t function_10014e3(void);
int32_t function_10015df(void);
int32_t function_10015e4(void);
int32_t function_1001624(void);
int32_t function_100164b(void);
int32_t function_1001652(int32_t a1);
int32_t function_1001654(int32_t a1);
int32_t function_1001657(int32_t a1);
int32_t function_10017a0(void);
int32_t function_10017b3(void);
int32_t function_10017d4(int32_t a1);
int32_t function_10017ec(void);
int32_t function_10017ed(void);
int32_t function_1001884(void);
int32_t function_10018f83(void);
int32_t function_1001924(void);
int32_t function_1001951(void);
int32_t function_10019d9(int32_t a1, int32_t a2);
int32_t function_1001a38(void);
int32_t function_1001b4d(void);
int32_t function_1001bcc(void);
int32_t function_1001c2b(char a1);
int32_t function_1001d34(void);
int32_t function_1001df8(void);
int32_t function_1001e2d(void);
int32_t function_1001e40(int32_t a1);
int32_t function_1001ec3(void);
int32_t function_1001f31(void);
int32_t function_1001f67(int32_t a1);
int32_t function_10020fc(void);
int32_t function_1002149(void);
int32_t function_10021a7(void);
int32_t function_100220c(void);
int32_t function_1002226(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7);
int32_t function_1002326(void);
int32_t function_100232f(void);
int32_t function_100233e(void);
int32_t function_1002354(int16_t a1, int32_t a2);
int32_t function_10023ab(void);
int32_t function_10023e7(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1002460(void);
int32_t function_10024e6(void);
int32_t function_10024ef(void);
int32_t function_10024f2(void);
int32_t function_1002528(int32_t a1);
int32_t function_10025b1(int32_t a1, int32_t a2);
int32_t function_1002646(int32_t a1);
int32_t function_100269d(void);
int32_t function_1002807(void);
int32_t function_100280f(int16_t a1, int32_t a2);
int32_t function_100283f(void);
int32_t function_1002876(void);
int32_t function_10028b1(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1002ad1(void);
int32_t function_1002ad5(int32_t a1);
int32_t function_1002c9d(int32_t a1, int32_t a2);
int32_t function_1002daa(int32_t a1);
int32_t function_10031f5(int32_t a1);
int32_t function_100322d(void);
int32_t function_1003232(void);
int32_t function_1003235(void);
int32_t function_100323e(void);
int32_t function_10032aa(void);
int32_t function_10033ba(void);
int32_t function_10033ed(void);
int32_t function_10033fb(int32_t a1, int32_t a2);
int32_t function_1003447(void);
int32_t function_1003465(void);
int32_t function_1003469(void);
int32_t function_100347c(void);
int32_t function_1003543(void);
int32_t function_100361a(int32_t a1);
int32_t function_1003656(void);
int32_t function_1003671(void);
int32_t function_1003685(void);
int32_t function_10037c8(void);
int32_t function_10037cd(void);
int32_t function_10037e3(void);
int32_t function_10037fb(void);
int32_t function_100381e(void);
int32_t function_1003826(void);
int32_t function_1003844(void);
int32_t function_100392c(void);
int32_t function_1003950(void);
int32_t function_100395d(void);
int32_t function_100397b(void);
int32_t function_10039ab(void);
int32_t function_10039d7(void);
int32_t function_1003afb(void);
int32_t function_1003b0f(void);
int32_t function_1003bae(int32_t a1);
int32_t function_1003bcd(int32_t a1);
int32_t function_1003bd9(void);
int32_t function_1003cff(void);
int32_t function_1003d04(void);
int32_t function_1003df5(void);
int32_t function_1003e04(void);
int32_t function_1003e0b(void);
int32_t function_1003e19(void);
int32_t function_1003e2c(void);
int32_t function_1003e3a(void);
int32_t function_1003e50(void);
int32_t function_1003e58(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t function_1003e5c(void);
int32_t function_1003e5d(void);
int32_t function_1003e66(void);
int32_t function_1003e67(void);
int32_t function_1003e6b(void);
int32_t function_1003e75(int32_t Offset);
int32_t function_1003e7b(void);
int32_t function_1003e85(void);
int32_t function_1003e8f(void);
int32_t function_1003e9e(void);
int32_t function_1003eab(int32_t a1);
int32_t function_1003eb3(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_1003f06(void);
int32_t function_1003f15(void);
int32_t function_1003f31(int32_t a1);
int32_t function_1003f36(int32_t a1, int32_t a2);
int32_t function_1003f3b(int16_t a1);
int32_t function_1003f48(void);
int32_t function_1003f50(void);
int32_t function_1003f5b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11);
int32_t function_1004105(void);
int32_t function_1004114(int32_t a1, int32_t a2);
int32_t function_100411b(void);
int32_t function_1004126(void);
int32_t function_1004132(void);
int32_t function_100413c(void);
int32_t function_1004141(void);
int32_t function_100414e(void);
int32_t function_1004150(int32_t a1);
int32_t function_1004156(void);
int32_t function_1004164(void);
int32_t function_1004169(void);
int32_t function_1004178(void);
int32_t function_1004184(void);
int32_t function_100418c(int32_t a1);
int32_t function_10041c1(void);
int32_t function_10041c3(int16_t a1);
int32_t function_10041d1(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10041e5(void);
int32_t function_10041e7(void);
int32_t function_10041f0(void);
int32_t function_10041fb(void);
int32_t function_10041fe(void);
int32_t function_100420a(void);
int32_t function_1004214(int32_t a1);
int32_t function_100422c(int32_t a1);
int32_t function_1004235(void);
int32_t function_100423f(void);
int32_t function_1004248(void);
int32_t function_100425e(void);
int32_t function_1004266(int32_t a1);
int32_t function_1004270(void);
int32_t function_1004279(int32_t a1, int32_t a2);
int32_t function_10042e3(int32_t a1);
int32_t function_10042e5(void);
int32_t function_10042e6(int32_t a1);
int32_t function_10042f0(void);
int32_t function_10042fb(int32_t a1);
int32_t function_10042fd(void);
int32_t function_1004307(int32_t a1);
int32_t function_1004310(int32_t Offset);
int32_t function_1004321(void);
int32_t function_100432a(void);
int32_t function_1004331(int32_t a1);
int32_t function_100436f(int32_t a1);
int32_t function_1004383(void);
int32_t function_10043ce(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10044f2(void);
int32_t function_10045ae(void);
int32_t function_10045c4(int32_t a1);
int32_t function_10045c9(int32_t a1, int32_t a2);
int32_t function_10047c1(void);
int32_t function_10047f6(int32_t a1);
int32_t function_100480b(void);
int32_t function_1004812(void);
int32_t function_1004820(void);
int32_t function_100483e(int32_t a1);
int32_t function_100484b(int32_t a1);
int32_t function_1004a4d(int32_t a1);
int32_t function_1004a78(int32_t a1);
int32_t function_1004b28(void);
int32_t function_1004b48(int16_t a1, int32_t a2);
int32_t function_1004e7e(void);
int32_t function_1004e85(void);
int32_t function_1004e8c(void);
int32_t function_1005082(void);
int32_t function_10050e6(void);
int32_t function_10050f4(void);
int32_t function_1005132(void);
int32_t function_1005145(void);
int32_t function_1005148(void);
int32_t function_100514f(int16_t a1);
int32_t function_100526a(void);
int32_t function_10052a9(void);
int32_t function_10052b2(int32_t a1, int32_t a2);
int32_t function_100530e(void);
int32_t function_1005322(void);
int32_t function_1005330(void);
int32_t function_100535e(void);
int32_t function_1005380(int32_t a1);
int32_t function_1005418(int32_t a1, int32_t a2);
int32_t function_100546c(void);
int32_t function_100547d(void);
int32_t function_100548f(int32_t a1);
int32_t function_10054d1(int32_t a1);
int32_t function_1005517(void);
int32_t function_100553d(void);
int32_t function_1005546(int32_t a1);
int32_t function_1005563(void);
int32_t function_10055a7(void);
int32_t function_10055e8(int32_t a1);
int32_t function_100565b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_1005a26(void);
int32_t function_1005a73(int32_t a1, int32_t a2);
int32_t function_1005a76(void);
int32_t function_1005a7a(int32_t a1, int32_t a2);
int32_t function_1006059(void);
int32_t function_1006083(int32_t a1);
int32_t function_100608d(int32_t a1);
int32_t function_100611c(void);
int32_t function_1006177(void);
int32_t function_10061a1(void);
int32_t function_1006201(int32_t a1);
int32_t function_1006221(int32_t a1);
int32_t function_1006252(void);
int32_t function_100629e(void);
int32_t function_10062d1(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10062e7(int16_t a1, int16_t a2);
int32_t function_10063cd(void);
int32_t function_10063f2(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam);
int32_t function_1006400(void);
int32_t function_10064a7(void);
int32_t function_1006521(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1006538(void);
int32_t function_1006564(int32_t a1);
int32_t function_1006580(void);
int32_t function_1006597(void);
int32_t function_10065a4(void);
int32_t function_10065e3(int32_t a1);
int32_t function_100660d(int32_t a1, int32_t a2);
int32_t function_1006626(int32_t a1);
int32_t function_1006793(char a1);
int32_t function_100683d(void);
int32_t function_1006856(void);
int32_t function_1006859(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_1006893(int32_t a1);
int32_t function_1006a55(int32_t a1);
int32_t function_1006abd(void);
int32_t function_1006b26(void);
int32_t function_1006bbe(void);
int32_t function_1006bc3(void);
int32_t function_1006c97(void);
int32_t function_1006c99(void);
int32_t function_1006cb2(void);
int32_t function_1006cf1(void);
int32_t function_1006d38(int32_t a1, int32_t result2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_1006de0(void);
int32_t function_1006de7(int32_t a1);
int32_t function_1006e22(void);
int32_t function_1006e2a(int32_t a1, int32_t a2);
int32_t function_1006e58(int32_t a1);
int32_t function_1006e66(void);
int32_t function_1006f1e(void);
int32_t function_1006f2f(void);
int32_t function_100709d(void);
int32_t function_10070a7(int32_t a1, uint32_t a2);
int32_t function_10071b9(int32_t a1, int32_t a2);
int32_t function_1007305(void);
int32_t function_1007307(void);
int32_t function_1007308(void);
int32_t function_10073a7(int32_t a1);
int32_t function_10073a9(void);
int32_t function_10073c1(void);
int32_t function_1007438(int16_t a1, int32_t a2);
int32_t function_1007673(void);
int32_t function_10076a9(void);
int32_t function_10076ae(int32_t a1);
int32_t function_10076b8(void);
int32_t function_1007703(void);
int32_t function_1007714(int32_t a1);
int32_t function_100771e(void);
int32_t function_100772a(void);
int32_t function_1007736(void);
int32_t function_100776c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_100782a(int32_t a1);
int32_t function_1007848(int32_t a1);
int32_t function_1007874(void);
int32_t function_1007883(void);
int32_t function_10079fd(void);
int32_t function_1007a0a(void);
int32_t function_1007a2e(void);
int32_t function_1007a51(void);
int32_t function_1007a63(void);
int32_t function_1007a68(void);
int32_t function_1007aaf(int32_t a1);
int32_t function_1007ac8(void);
int32_t function_1007b03(void);
int32_t function_1007b07(void);
int32_t function_1007b09(void);
int32_t function_1007b0e(int32_t a1, int32_t a2);
int32_t function_1007b4d(int32_t a1);
int32_t function_1007b87(void);
int32_t function_1007b8d(void);
int32_t function_1007b91(int32_t a1);
int32_t function_1007b94(void);
int32_t function_1007b96(void);
int32_t function_1007ba3(void);
int32_t function_1007ba4(void);
int32_t function_1007ba5(void);
int32_t function_1007ba8(int32_t a1);
int32_t function_1007bb0(void);
int32_t function_1007bbf(int32_t a1);
int32_t function_1007bc1(int32_t a1);
int32_t function_1007bd1(void);
int32_t function_1007c0e(int32_t a1);
int32_t function_1007c18(void);
int32_t function_1007c19(int32_t a1);
int32_t function_1007c1d(void);
int32_t function_1007c26(void);
int32_t function_1007c2b(int32_t a1, int32_t a2);
int32_t function_1007c2f(int32_t a1);
int32_t function_1007c30(int32_t a1);
int32_t function_1007c36(int32_t a1);
int32_t function_1007c38(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t result, int32_t a6);
int32_t function_1007c8e(int32_t a1, int32_t a2);
int32_t function_1007c93(void);
int32_t function_1007cba(int32_t a1);
int32_t function_1007cc4(int32_t a1);
int32_t function_1007cd3(int32_t a1);
int32_t function_1007cfa(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1007d16(int32_t a1, int32_t a2);
int32_t function_1007d2a(void);
int32_t function_1007d3b(void);
int32_t function_1007e28(void);
int32_t function_1007e6a(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1007f4e(void);
int32_t function_1007f57(void);
int32_t function_1007f61(void);
int32_t function_1007f77(void);
int32_t function_1007fa0(void);
int32_t function_1007fce(void);
int32_t function_1007fdc(void);
int32_t function_1007fed(int32_t a1, int32_t a2);
int32_t function_1008123(void);
int32_t function_1008130(void);
int32_t function_1008134(int32_t a1);
int32_t function_1008136(void);
int32_t function_1008142(void);
int32_t function_1008178(void);
int32_t function_1008195(void);
int32_t function_100819a(void);
int32_t function_100819d(void);
int32_t function_10081b4(void);
int32_t function_10081b6(void);
int32_t function_10081c1(void);
int32_t function_10081c2(int32_t a1, int32_t a2);
int32_t function_10081cc(void);
int32_t function_10081f8(void);
int32_t function_10081fa(void);
int32_t function_1008213(void);
int32_t function_1008315(void);
int32_t function_1008322(void);
int32_t function_1008356(int32_t a1);
int32_t function_1008358(void);
int32_t function_1008472(void);
int32_t function_1008476(void);
int32_t function_10084a5(int32_t a1);
int32_t function_1008648(int32_t a1);
int32_t function_100865c(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_10086c8(int32_t a1, int32_t a2);
int32_t function_10086ee(void);
int32_t function_10086fb(void);
int32_t function_100874e(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1008754(void);
int32_t function_100875d(void);
int32_t function_100877e(int32_t a1);
int32_t function_10087b7(int32_t a1);
int32_t function_1008818(void);
int32_t function_1008822(void);
int32_t function_1008827(void);
int32_t function_10088e2(void);
int32_t function_10088ec(void);
int32_t function_1008920(void);
int32_t function_1008934(void);
int32_t function_1008942(void);
int32_t function_100896c(void);
int32_t function_10089ba(void);
int32_t function_10089c1(void);
int32_t function_10089fb(int32_t a1);
int32_t function_1008a3f(void);
int32_t function_1008a86(void);
int32_t function_1008b1c(void);
int32_t function_1008b22(int32_t a1);
int32_t function_1008b2e(int32_t a1);
int32_t function_1008c19(int32_t a1);
int32_t function_1008c45(int32_t a1);
int32_t function_1008c96(void);
int32_t function_1008cab(void);
int32_t function_1008ce5(void);
int32_t function_1008cef(void);
int32_t function_1008d44(void);
int32_t function_1008d7b(int32_t a1, int32_t a2);
int32_t function_1008d93(void);
int32_t function_1008dba(int32_t a1);
int32_t function_1008e56(int32_t a1);
int32_t function_1008e73(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_1008e90(void);
int32_t function_1008ed6(void);
int32_t function_1008f0f(int32_t a1, int32_t a2);
int32_t function_1008f17(void);
int32_t function_1008f7b(int32_t a1, int32_t a2);
int32_t function_1008ffc(int32_t a1, int32_t a2);
int32_t function_1009010(void);
int32_t function_1009020(int32_t a1);
int32_t function_1009095(void);
int32_t function_10090ce(int32_t a1);
int32_t function_10090d7(int32_t a1, int32_t a2);
int32_t function_10091ad(void);
int32_t function_10091c1(int32_t a1);
int32_t function_10091cf(void);
int32_t function_10091ec(int32_t a1);
int32_t function_1009209(void);
int32_t function_100920a(void);
int32_t function_1009216(void);
int32_t function_1009256(void);
int32_t function_100926a(void);
int32_t function_1009280(void);
int32_t function_10092c6(void);
int32_t function_10092ec(void);
int32_t function_10092f5(int32_t a1);
int32_t function_100931e(void);
int32_t function_100932e(void);
int32_t function_100935b(void);
int32_t function_1009363(void);
int32_t function_1009389(int32_t a1);
int32_t function_10093b1(void);
int32_t function_10093c3(int32_t a1);
int32_t function_1009409(int32_t a1);
int32_t function_1009414(int32_t a1);
int32_t function_100959c(void);
int32_t function_100961d(void);
int32_t function_1009627(void);
int32_t function_1009634(void);
int32_t function_1009643(void);
int32_t function_10096f7(void);
int32_t function_1009790(void);
int32_t function_10097d9(void);
int32_t function_1009818(void);
int32_t function_1009846(void);
int32_t function_100986f(void);
int32_t function_100987b(void);
int32_t function_1009885(void);
int32_t function_10098dc(void);
int32_t function_100990b(void);
int32_t function_100991d(void);
int32_t function_1009921(void);
int32_t function_1009929(void);
int32_t function_100994f(void);
int32_t function_1009977(void);
int32_t function_10099b1(void);
int32_t function_10099bc(void);
int32_t function_10099c6(void);
int32_t function_10099fd(void);
int32_t function_1009a44(void);
int32_t function_1009a4d(void);
int32_t function_1009a5e(void);
int32_t function_1009ab4(int16_t a1);
int32_t function_1009ad1(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1009ad4(int32_t a1);
int32_t function_1009bfb(void);
int32_t function_1009c30(void);
int32_t function_1009c41(void);
int32_t function_1009c4d(void);
int32_t function_1009c52(void);
int32_t function_1009c9c(void);
int32_t function_1009cd1(void);
int32_t function_1009ce4(void);
float80_t function_1009cee(void);
int32_t function_1009d22(void);
int32_t function_1009d70(void);
float80_t function_1009d83(void);
int32_t function_1009db4(int32_t a1);
int32_t function_1009dd9(void);
int32_t function_1009e0a(void);
int32_t function_1009e32(void);
int32_t function_1009e38(void);
int32_t function_1009e7f(void);
int32_t function_1009ec7(void);
int32_t function_1009f1e(void);
float80_t function_1009f27(void);
int32_t function_1009f7e(void);
int32_t function_1009fa6(void);
int32_t function_1009fc1(void);
int32_t function_1009fc3(void);
int32_t function_1009fcd(void);
int32_t function_1009fce(int32_t a1, int32_t a2);
int32_t function_100a08b(void);
int32_t function_100a0aa(void);
int32_t function_100a0b2(void);
int32_t function_100a0ed(void);
int32_t function_100a0f3(void);
int32_t function_100a14f(void);
int32_t function_100a1aa(void);
int32_t function_100a1ce(void);
int32_t function_100a1d9(void);
int32_t function_100a1e3(void);
int32_t function_100a228(void);
int32_t function_100a243(void);
int32_t function_100a24c(int32_t a1, int32_t a2);
int32_t function_100a257(void);
int32_t function_100a28a(void);
int32_t function_100a2cb(void);
int32_t function_100a310(void);
int32_t function_100a3c8(void);
int32_t function_100a3d8(int32_t a1);
int32_t function_100a404(void);
int32_t function_100a412(int16_t a1, int32_t a2);
int32_t function_100a4fe(void);
int32_t function_100a511(void);
int32_t function_100a51d(void);
int32_t function_100a52a(int32_t a1);
int32_t function_100a52f(void);
int32_t function_100a54f(void);
int32_t function_100a565(void);
int32_t function_100a585(void);
int32_t function_100a59f(void);
int32_t function_100a5b2(void);
int32_t function_100a5be(void);
int32_t function_100a5f0(void);
int32_t function_100a609(void);
int32_t function_100a651(void);
int32_t function_100a65a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, uint32_t a7);
int32_t function_100a68f(void);
int32_t function_100a6aa(void);
int32_t function_100a6e1(void);
int32_t function_100a6f2(void);
int32_t function_100a706(void);
int32_t function_100a70a(void);
int32_t function_100a7ee(void);
int32_t function_100a823(void);
int32_t function_100a835(void);
int32_t function_100a874(void);
int32_t function_100a88f(void);
int32_t function_100a8d7(void);
int32_t function_100a8e1(void);
int32_t function_100a915(void);
int32_t function_100a952(void);
int32_t function_100aa6b(void);
int32_t function_100aa72(void);
int32_t function_100aa78(int32_t a1);
int32_t function_100ab09(int32_t a1);
int32_t function_100ab25(void);
int32_t function_100ab26(void);
int32_t function_100ab31(int32_t a1);
int32_t function_100ab60(void);
int32_t function_100ab65(int32_t a1);
int32_t function_100acce(void);
int32_t function_100ad14(void);
int32_t function_100ad51(void);
int32_t function_100aeaa(void);
int32_t function_100aec7(void);
int32_t function_100aed9(void);
int32_t function_100aedd(int32_t a1);
int32_t function_100aefe(void);
int32_t function_100af44(void);
int32_t function_100af7b(void);
int32_t function_100afcc(void);
int32_t function_100afde(void);
int32_t function_100afe9(int32_t a1);
int32_t function_100b05b(int32_t a1);
int32_t function_100b064(void);
float80_t function_100b0a4(int32_t a1);
int32_t function_100b0b6(void);
int32_t function_100b0bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t result);
int32_t function_100b0cc(int32_t a1);
int32_t function_100b0e7(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100b199(void);
int32_t function_100b1c1(void);
int32_t function_100b1dd(void);
int32_t function_100b1f2(void);
int32_t function_100b229(int32_t a1);
int32_t function_100b233(void);
int32_t function_100b26d(void);
int32_t function_100b2c5(void);
int32_t function_100b2c9(void);
int32_t function_100b2df(void);
int32_t function_100b323(void);
int32_t function_100b383(void);
int32_t function_100b38d(char a1);
int32_t function_100b41f(void);
int32_t function_100b440(void);
float80_t function_100b446(void);
int32_t function_100b455(void);
int32_t function_100b48f(void);
int32_t function_100b4a6(void);
int32_t function_100b4be(int32_t a1);
int32_t function_100b4e5(void);
int32_t function_100b50f(void);
int32_t function_100b51d(void);
int32_t function_100b5a0(void);
int32_t function_100b5ca(void);
int32_t function_100b5cd(int32_t a1);
int32_t function_100b5e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_100b640(void);
int32_t function_100b67d(void);
int32_t function_100b69d(void);
int32_t function_100b6dc(void);
int32_t function_100b70a(void);
int32_t function_100b71a(void);
int32_t function_100b726(void);
int32_t function_100b760(void);
int32_t function_100b777(void);
int32_t function_100b7b6(void);
int32_t function_100b7e7(void);
int32_t function_100b7f4(void);
int32_t function_100b7fb(void);
int32_t function_100b819(void);
int32_t function_100b83a(void);
int32_t function_100b84b(uint32_t a1);
int32_t function_100b8cf(void);
int32_t function_100b953(void);
int32_t function_100b961(void);
int32_t function_100b980(void);
int32_t function_100bbd4(void);
int32_t function_100bc53(int32_t a1);
int32_t function_100bc54(void);
int32_t function_100bcb6(int16_t a1);
int32_t function_100bd5b(int32_t a1, int32_t a2);
int32_t function_100bd61(int32_t a1);
int32_t function_100bd6f(int32_t a1);
int32_t function_100bd7e(int32_t a1, int16_t a2);
int32_t function_100bdb3(void);
int32_t function_100bdba(void);
int32_t function_100bdd0(void);
int32_t function_100be29(int32_t a1);
int32_t function_100be30(void);
int32_t function_100be3b(void);
int32_t function_100be5f(void);
int32_t function_100be63(void);
int32_t function_100be9c(void);
int32_t function_100beff(int32_t a1);
int32_t function_100bf18(void);
int32_t function_100bf43(void);
int32_t function_100bf9c(void);
int32_t function_100bfba(void);
int32_t function_100bfce(void);
int32_t function_100c00d(void);
int32_t function_100c014(void);
int32_t function_100c027(void);
int32_t function_100c04b(void);
int32_t function_100c05c(void);
int32_t function_100c065(void);
int32_t function_100c071(void);
int32_t function_100c088(void);
int32_t function_100c108(void);
int32_t function_100c172(void);
int32_t function_100c223(void);
int32_t function_100c22b(void);
int32_t function_100c248(void);
float80_t function_100c2cf(void);
int32_t function_100c2d5(void);
int32_t function_100c318(int32_t a1);
int32_t function_100c357(void);
int32_t function_100c37c(int32_t a1, int32_t a2);
int32_t function_100c46f(int32_t a1, int32_t a2);
int32_t function_100c471(void);
int32_t function_100c474(int32_t a1);
int32_t function_100c4b7(void);
int32_t function_100c4e3(void);
int32_t function_100c4f8(void);
int32_t function_100c504(void);
int32_t function_100c50b(void);
int32_t function_100c518(int32_t a1);
int32_t function_100c558(void);
int32_t function_100c5a9(void);
int32_t function_100c5fa(int32_t a1);
int32_t function_100c62c(void);
int32_t function_100c6c8(void);
int32_t function_100c6ef(void);
int32_t function_100c70e(int32_t a1);
int32_t function_100c716(int32_t a1);
int32_t function_100c781(void);
int32_t function_100c7e5(int32_t a1);
int32_t function_100cad7(void);
int32_t function_100caf8(void);
int32_t function_100cb54(int32_t a1, int32_t a2);
int32_t function_100cb64(void);
int32_t function_100cba4(void);
int32_t function_100cbee(void);
int32_t function_100cc4a(void);
int32_t function_100cc82(void);
int32_t function_100cc99(void);
int32_t function_100ccd0(void);
int32_t function_100ccff(void);
int32_t function_100cd47(void);
int32_t function_100cdb9(void);
int32_t function_100cdd0(void);
int32_t function_100cdfb(void);
int32_t function_100d1c1(void);
int32_t function_100d1ce(int32_t result, int32_t a2);
int32_t function_100d1f4(void);
int32_t function_100d203(void);
int32_t function_100d208(void);
int32_t function_100d243(void);
int32_t function_100d272(void);
int32_t function_100d2a2(void);
int32_t function_100d2c8(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100d2f5(int32_t a1, int32_t a2);
int32_t function_100d37c(void);
int32_t function_100d3c1(void);
int32_t function_100d403(void);
int32_t function_100d4a2(void);
int32_t function_100d4aa(void);
int32_t function_100d4b1(void);
int32_t function_100d5e0(void);
int32_t function_100d5eb(int32_t a1);
int32_t function_100d62a(void);
int32_t function_100d642(int32_t a1);
int32_t function_100d64b(void);
int32_t function_100d670(void);
int32_t function_100d682(void);
int32_t function_100d70b(void);
int32_t function_100d734(void);
int32_t function_100d799(void);
int32_t function_100d7e1(void);
int32_t function_100d7ef(void);
int32_t function_100d80c(void);
int32_t function_100d830(void);
int32_t function_100d856(void);
int32_t function_100d885(int32_t a1);
int32_t function_100d9b6(void);
int32_t function_100daad(void);
int32_t function_100daf3(void);
int32_t function_100db28(void);
int32_t function_100db3b(void);
int32_t function_100db57(int32_t a1);
int32_t function_100db5f(void);
int32_t function_100dc20(void);
int32_t function_100dc27(void);
int32_t function_100dc3a(int32_t a1);
int32_t function_100dc53(int32_t a1);
int32_t function_100dc65(void);
int32_t function_100dc8b(int32_t a1);
int32_t function_100dcfe(void);
int32_t function_100dd8d(int32_t a1);
int32_t function_100dda4(void);
int32_t function_100ddaa(void);
int32_t function_100dde1(void);
int32_t function_100de3f(void);
int32_t function_100de87(void);
int32_t function_100dec7(void);
int32_t function_100ded4(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t result);
int32_t function_100dede(void);
int32_t function_100dee4(int16_t a1);
int32_t function_100df72(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_100dfd2(int32_t a1, int32_t a2);
int32_t function_100dfef(void);
int32_t function_100e053(int32_t a1);
int32_t function_100e08a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_100e0ff(void);
int32_t function_100e127(int32_t a1);
int32_t function_100e14b(void);
int32_t function_100e199(void);
int32_t function_100e1e7(void);
int32_t function_100e240(void);
int32_t function_100e24d(void);
int32_t function_100e280(void);
int32_t function_100e28c(void);
int32_t function_100e2b5(void);
int32_t function_100e2d4(int32_t a1);
int32_t function_100e2da(int32_t a1);
int32_t function_100e2f5(int32_t a1, int32_t a2);
int32_t function_100e447(void);
int32_t function_100e461(void);
int32_t function_100e561(void);
int32_t function_100e588(void);
int32_t function_100e616(void);
int32_t function_100e64a(void);
int32_t function_100e69e(void);
int32_t function_100e6ba(void);
int32_t function_100e6c6(void);
int32_t function_100e6df(void);
int32_t function_100e6f4(void);
int32_t function_100e700(void);
int32_t function_100e70e(void);
int32_t function_100e729(void);
int32_t function_100e7af(void);
int32_t function_100e7ea(void);
int32_t function_100e80a(void);
int32_t function_100e828(void);
int32_t function_100e851(void);
int32_t function_100e87f(void);
int32_t function_100e8ab(void);
int32_t function_100e8d7(int32_t a1);
int32_t function_100e8fc(void);
int32_t function_100e97f(void);
int32_t function_100e9b0(void);
int32_t function_100e9c2(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100e9e9(void);
int32_t function_100ea2b(void);
int32_t function_100ea3a(void);
int32_t function_100ea41(void);
int32_t function_100ea78(void);
int32_t function_100ea81(int32_t a1, int32_t a2, uint32_t a3, int32_t a4);
int32_t function_100eadb(void);
int32_t function_100eb4e(int32_t a1);
int32_t function_100eb5c(int32_t a1);
int32_t function_100eb92(int32_t a1);
int32_t function_100ebf0(void);
int32_t function_100ec01(void);
int32_t function_100ec2a(void);
int32_t function_100ec36(void);
int32_t function_100eced(void);
int32_t function_100ecf8(int32_t a1);
int32_t function_100ed2b(void);
int32_t function_100ed74(void);
int32_t function_100eddd(void);
int32_t function_100edeb(void);
int32_t function_100ee02(void);
int32_t function_100ee14(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100ee2c(void);
int32_t function_100ee38(int16_t a1, int32_t a2);
int32_t function_100ef03(void);
int32_t function_100efc5(void);
int32_t function_100efdd(void);
int32_t function_100efef(int32_t a1);
int32_t function_100f033(void);
int32_t function_100f035(void);
int32_t function_100f049(void);
int32_t function_100f0d5(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100f0e4(int32_t a1);
int32_t function_100f15e(void);
int32_t function_100f1a6(void);
int32_t function_100f1b3(void);
int32_t function_100f1cd(int32_t a1);
int32_t function_100f1d1(int32_t a1);
int32_t function_100f1dc(void);
int32_t function_100f1fb(int32_t a1);
int32_t function_100f20a(void);
int32_t function_100f22d(int32_t a1, int32_t a2);
int32_t function_100f38a(int32_t a1);
int32_t function_100f3cf(void);
int32_t function_100f3fb(int32_t a1);
int32_t function_100f40a(int32_t a1);
int32_t function_100f40c(void);
int32_t function_100f42d(void);
int32_t function_100f468(void);
int32_t function_100f47a(void);
int32_t function_100f50c(void);
int32_t function_100f538(void);
int32_t function_100f579(void);
int32_t function_100f5af(void);
int32_t function_100f5d1(int32_t a1);
int32_t function_100f627(void);
int32_t function_100f63d(void);
int32_t function_100f646(int32_t a1);
int32_t function_100f664(void);
int32_t function_100f6b6(void);
int32_t function_100f71f(int32_t a1);
int32_t function_100f730(void);
int32_t function_100f738(int32_t a1, int32_t a2);
int32_t function_100f73f(void);
int32_t function_100f836(void);
int32_t function_100f8db(void);
int32_t function_100f8e0(void);
int32_t function_100f926(int32_t a1);
int32_t function_100f95a(void);
int32_t function_100f95d(void);
int32_t function_100f965(void);
int32_t function_100f96a(void);
int32_t function_100f99f(void);
int32_t function_100fa4c(int32_t a1);
int32_t function_100fa99(void);
int32_t function_100fac3(int32_t a1, int32_t a2);
int32_t function_100fad4(void);
int32_t function_100fae4(int32_t a1);
int32_t function_100fb18(void);
int32_t function_100fbb2(void);
int32_t function_100fbc3(int32_t a1);
int32_t function_100fbe8(void);
int32_t function_100fc04(void);
int32_t function_100fc23(int32_t a1, int32_t a2, int32_t a3);
int32_t function_100fc62(int16_t a1);
int32_t function_100fc9c(void);
int32_t function_100fcec(void);
int32_t function_100fcfe(void);
int32_t function_100fd15(void);
int32_t function_100fd2e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7);
int32_t function_100fdbc(int32_t result2);
int32_t function_100fe62(void);
int32_t function_100fe87(void);
int32_t function_100fea6(void);
int32_t function_100fee4(void);
int32_t function_100fefb(void);
int32_t function_100ff0b(void);
int32_t function_100ff7e(void);
int32_t function_100ffea(void);
int32_t function_100fffb(int32_t a1);
int32_t function_101004b(void);
int32_t function_101009f(void);
int32_t function_10100db(void);
int32_t function_10101d3(void);
int32_t function_10101f8(void);
int32_t function_101023b(void);
int32_t function_101028c(void);
int32_t function_1010313(int16_t a1);
int32_t function_1010353(int32_t a1, int32_t a2);
int32_t function_10103d3(void);
int32_t function_1010458(void);
int32_t function_1010515(void);
int32_t function_1010535(void);
int32_t function_101065c(void);
int32_t function_1010706(void);
int32_t function_101073c(void);
int32_t function_101076a(void);
int32_t function_10107a2(void);
int32_t function_10107c0(void);
int32_t function_10107ed(int32_t a1, int32_t a2);
int32_t function_10107fc(int32_t a1);
float80_t function_101091f(void);
int32_t function_101099c(void);
int32_t function_10109ff(void);
int32_t function_1010a16(int32_t a1);
int32_t function_1010a21(void);
int32_t function_1010a30(void);
int32_t function_1010a4a(void);
int32_t function_1010a51(void);
int32_t function_1010a5f(int16_t a1, int32_t a2);
int32_t function_1010aa5(void);
int32_t function_1010ab0(void);
int32_t function_1010ab5(void);
int32_t function_1010ad9(void);
int32_t function_1010b1b(void);
int32_t function_1010b5d(void);
int32_t function_1010ba5(void);
int32_t function_1010bb2(void);
int32_t function_1010bf8(void);
int32_t function_1010c0d(void);
int32_t function_1010c63(void);
int32_t function_1010ec7(void);
int32_t function_1010ee5(int16_t a1, int32_t a2);
int32_t function_1010fcd(void);
int32_t function_1010fd7(void);
int32_t function_1011036(void);
int32_t function_101103c(void);
int32_t function_1011050(void);
int32_t function_1011080(void);
int32_t function_10110bf(void);
int32_t function_10110c4(void);
int32_t function_10110d8(void);
int32_t function_10110ea(void);
int32_t function_10110fb(int32_t a1);
int32_t function_10111c0(void);
int32_t function_10111c8(void);
int32_t function_10111e8(void);
int32_t function_10111fd(int32_t a1);
int32_t function_101120a(int32_t a1);
int32_t function_101121b(void);
int32_t function_1011265(void);
int32_t function_1011270(int32_t a1, int32_t a2, int32_t a3);
int32_t function_1011288(void);
int32_t function_101132b(void);
int32_t function_1011348(int32_t a1);
int32_t function_101134e(void);
int32_t function_1011361(void);
int32_t function_101137b(void);
int32_t function_1011437(void);
int32_t function_10114c5(void);
int32_t function_1011502(int32_t a1);
int32_t function_1011569(int32_t a1);
int32_t function_10115ed(void);
int32_t function_1011603(void);
int32_t function_101160f(int32_t a1);
int32_t function_1011683(int16_t a1);
int32_t function_10116c5(int32_t a1);
int32_t function_1011705(void);
int32_t function_1011716(void);
int32_t function_1011726(void);
int32_t function_101172d(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10117c1(int32_t a1);
int32_t function_10118ea(void);
int32_t function_10118fc(void);
int32_t function_10118fe(void);
int32_t function_1011913(int32_t a1);
int32_t function_101195a(void);
int32_t function_1011961(int32_t a1, int32_t a2);
int32_t function_1011977(void);
int32_t function_1011979(int32_t a1);
int32_t function_1011986(int32_t a1, int32_t a2);
int32_t function_101198c(void);
int32_t function_101199f(void);
int32_t function_10119b0(void);
int32_t function_10119c6(void);
int32_t function_10119dc(void);
int32_t function_1011a00(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_1011a16(void);
int32_t function_1011a18(void);
int32_t function_1011a3c(int32_t a1, int32_t a2);
int32_t function_1011a9a(int32_t a1, int32_t a2);
int32_t function_1011ab5(int32_t a1);
int32_t function_1011cd1(int32_t a1, int32_t a2);
int32_t function_1011cec(void);
int32_t function_1011cf6(void);
int32_t function_1011d2b(void);
int32_t function_1011d36(int32_t a1);
int32_t function_1011d81(void);
int32_t function_1011e02(void);
int32_t function_1011e14(int32_t a1, int32_t a2);
int32_t function_1011ea3(void);
int32_t function_1011ecf(int32_t a1, int32_t a2);
int32_t function_1011ede(void);
int32_t function_1011ef3(void);
int32_t function_1012080(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10120bc(void);
int32_t function_1012158(void);
int32_t function_1012170(void);
int32_t function_1012243(void);
int32_t function_1012255(void);
int32_t function_1012257(void);
int32_t function_1012273(void);
int32_t function_1012275(int32_t a1);
int32_t function_101228d(int32_t a1);
int32_t function_10122eb(int32_t a1);
int32_t function_1012314(int32_t a1);
int32_t function_101238e(void);
int32_t function_1012390(int32_t a1);
int32_t function_1012397(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_101239e(int32_t a1);
int32_t function_10123df(void);
int32_t function_10123eb(void);
int32_t function_101246e(int32_t a1);
int32_t function_101246f(int32_t a1);
int32_t function_1012644(void);
int32_t function_1012670(int32_t a1);
int32_t function_1012678(void);
int32_t function_10126b0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_10126c1(void);
int32_t function_101270e(void);
int32_t function_1012758(int32_t a1);
float80_t function_101276c(int32_t a1);
int32_t function_1012770(int32_t a1, int32_t a2);
int32_t function_1012789(void);
int32_t function_10127a2(void);
void function_10127a3(void (**First)(), void (**Last)());
int32_t function_10127b0(void);
int32_t function_10127c2(void);
int32_t function_10127c8(int32_t * a1, int32_t a2);
int32_t function_10127e2(int32_t a1);
int32_t function_1012801(int32_t a1, int32_t a2);
int32_t function_1012811(void);
int32_t function_1012812(void);
int32_t function_1012855(void);
int32_t function_1012867(void);
int32_t function_101286b(void);
int32_t function_1012877(void);
int32_t function_1012896(void);
int32_t function_10128a1(void);
int32_t function_10128a6(void);
int32_t function_10128c3(void);
int32_t function_10128ee(void);
int32_t function_101290c(void);
int32_t function_1012916(void);
int32_t function_1012920(void);
int32_t function_10129d0(int32_t a1, int32_t a2);
int32_t function_1012a8f(void);
int32_t function_1012af0(int32_t a1);
int32_t function_1012b12(void);
int32_t function_1012b2d(void);
int32_t function_1012b40(void);
int32_t function_1012feb(void);
int32_t function_1013026(void);
int32_t function_101313a(void);
int32_t function_10131b6(int32_t a1);
int32_t function_10133b8(void);
int32_t function_1013454(char * a1, int32_t a2, int32_t * a3, int32_t a4);
int32_t function_1013c73(int32_t a1, int32_t a2);
int32_t function_101427e(void);
int32_t function_10149bc(int32_t a1);
int32_t function_1014bc1(int32_t a1);
int32_t function_1015257(void);
int32_t function_1015fef(void);
int32_t function_101636f(int32_t a1);
int32_t function_1017418(int32_t a1);
int32_t function_1017570(int32_t a1, int32_t a2, int32_t a3);
int32_t function_101763c(int32_t a1, int32_t a2);
int32_t function_1017d65(void);
int32_t function_10194f5(void);
int32_t function_101a670(int32_t a1);
int32_t function_101b112(void);
int32_t function_1036cb2(void);
int32_t function_1053dd7(void);
int32_t function_11198154(void);
int32_t function_1146521(void);
int32_t function_11681a6(int32_t a1);
int32_t function_11e3246(int32_t a1);
int32_t function_11e6336(void);
int32_t function_1301c78(void);
int32_t function_131c1d3(void);
int32_t function_13270a7(void);
int32_t function_132ce93(void);
int32_t function_13a4f3e(void);
int32_t function_13b4e95(void);
int32_t function_1496049(void);
int32_t function_14a6bdff(void);
int32_t function_14d90a1(void);
int32_t function_154c44d(void);
int32_t function_15a6c3a9(void);
int32_t function_15a6fe64(void);
int32_t function_1655726(void);
int32_t function_16e6998(void);
int32_t function_17159c1(void);
int32_t function_17f42eb(void);
int32_t function_18993b3(void);
int32_t function_193fc40(void);
int32_t function_1985792(void);
int32_t function_1a009b79(void);
int32_t function_1ae14e0c(int32_t a1);
int32_t function_1c48996(void);
int32_t function_1df3232(void);
int32_t function_1ee7a24(void);
int32_t function_1ee9c1c1(void);
int32_t function_1f321f2(void);
int32_t function_2008cab(void);
int32_t function_24642976(void);
int32_t function_25a16ea2(void);
int32_t function_28006e08(int32_t a1);
int32_t function_29f2a2d3(void);
int32_t function_2b5d1885(void);
int32_t function_2c08c6c5(int32_t a1);
int32_t function_2e016128(void);
int32_t function_30a6cae8(void);
int32_t function_30c6bbc1(void);
int32_t function_30cc0c5d(void);
int32_t function_3116931(void);
int32_t function_34a5bebd(void);
int32_t function_3766cfdb(void);
int32_t function_388d0c8d(void);
int32_t function_389bf445(void);
int32_t function_39d302dc(void);
int32_t function_3a004cae(void);
int32_t function_3b0059bb(void);
int32_t function_3bc03357(int32_t a1);
int32_t function_3c01468d(void);
int32_t function_3c0d8b04(void);
int32_t function_3e4dfecb(void);
int32_t function_3ea39e1(void);
int32_t function_400011a4(int32_t a1);
int32_t function_44d716a7(void);
int32_t function_44e13c24(void);
int32_t function_450154ab(void);
int32_t function_451186ed(int32_t a1);
int32_t function_45417c2a(void);
int32_t function_455affff(void);
int32_t function_455b7812(void);
int32_t function_455d667b(void);
int32_t function_458b0004(void);
int32_t function_4590831c(void);
int32_t function_45a9ffff(int32_t a1, int32_t a2);
int32_t function_46095804(void);
int32_t function_46795a37(void);
int32_t function_468c9169(void);
int32_t function_468c925a(void);
int32_t function_46ad5ad8(void);
int32_t function_46d15b49(void);
int32_t function_47195bca(void);
int32_t function_473d5c1a(void);
int32_t function_47f15dad(void);
int32_t function_480105fc(void);
int32_t function_4835ff51(void);
int32_t function_48675eb8(int32_t a1);
int32_t function_492a60d2(void);
int32_t function_49c962ab(void);
int32_t function_49d56305(void);
int32_t function_4a07f545(void);
int32_t function_4a4463a6(void);
int32_t function_4a7964e8(void);
int32_t function_4a89671c(void);
int32_t function_4a916539(void);
int32_t function_4a977b0a(void);
int32_t function_4ab063f7(void);
int32_t function_4ab9680d(void);
int32_t function_4e0a926e(void);
int32_t function_4e8c92f0(void);
int32_t function_4ecdebe2(void);
int32_t function_4fcfe9d1(void);
int32_t function_51a82ab1(int32_t a1);
int32_t function_52a62791(void);
int32_t function_558cebcc(void);
int32_t function_56180406(void);
int32_t function_58a6c05b(void);
int32_t function_5affa4f3(void);
int32_t function_5fc52ca(void);
int32_t function_6100cb8a(void);
int32_t function_6319e274(void);
int32_t function_66a618ac(void);
int32_t function_6900398e(void);
int32_t function_6ba6ab41(void);
int32_t function_71908972(void);
int32_t function_734ac721(void);
int32_t function_75a70732(int32_t * a1);
int32_t function_768a91dc(void);
int32_t function_79f15558(void);
int32_t function_7e004061(void);
int32_t function_7e80476(void);
int32_t function_7ea6c36b(void);
int32_t function_8143408b(void);
int32_t function_88003348(void);
int32_t function_8a0b077c(void);
int32_t function_8b00003d(void);
int32_t function_8b00004e(void);
int32_t function_8b308903(void);
int32_t function_8b9a6ce4(int32_t a1);
int32_t function_8c01e9d3(void);
int32_t function_8c02f81c(void);
int32_t function_8c040e0c(void);
int32_t function_8c067c12(void);
int32_t function_8c1e0110(void);
int32_t function_8c384357(void);
int32_t function_8c3ef280(void);
int32_t function_8c47056c(void);
int32_t function_8c5d05cf(void);
int32_t function_8c7bd7c0(void);
int32_t function_8c88cada(void);
int32_t function_8c94f711(void);
int32_t function_8c9ca3a6(void);
int32_t function_8ca5d2f2(void);
int32_t function_8ca5ffb8(void);
int32_t function_8ca60ec1(void);
int32_t function_8ca6117a(void);
int32_t function_8ca61814(void);
int32_t function_8ca61d96(void);
int32_t function_8ca6234c(int32_t * a1);
int32_t function_8ca6267b(int16_t a1);
int32_t function_8ca62886(void);
int32_t function_8ca62b04(void);
int32_t function_8ca62b25(void);
int32_t function_8ca62cad(void);
int32_t function_8ca63006(void);
int32_t function_8ca6311f(void);
int32_t function_8ca63a59(void);
int32_t function_8ca6409e(void);
int32_t function_8ca64615(void);
int32_t function_8ca64665(void);
int32_t function_8ca6474e(void);
int32_t function_8ca64974(void);
int32_t function_8ca64f12(void);
int32_t function_8ca66a8b(void);
int32_t function_8ca66c6b(void);
int32_t function_8ca671cf(void);
int32_t function_8ca67233(void);
int32_t function_8ca67578(void);
int32_t function_8ca6761c(void);
int32_t function_8ca67ee2(void);
int32_t function_8ca67fb2(void);
int32_t function_8ca6809a(void);
int32_t function_8ca68182(void);
int32_t function_8ca68431(int16_t a1);
int32_t function_8ca6854a(int32_t a1);
int32_t function_8ca68727(void);
int32_t function_8ca68bb0(void);
int32_t function_8ca68f9c(void);
int32_t function_8ca6a263(void);
int32_t function_8ca6a329(void);
int32_t function_8ca6a808(void);
int32_t function_8ca6a893(void);
int32_t function_8ca6aa67(void);
int32_t function_8ca6ae74(void);
int32_t function_8ca6b2c3(void);
int32_t function_8ca6b604(void);
int32_t function_8ca6b7bd(int32_t a1);
int32_t function_8ca6beab(void);
int32_t function_8ca6bf3c(void);
int32_t function_8ca6c008(void);
int32_t function_8ca6c0c2(void);
int32_t function_8ca6c2e0(void);
int32_t function_8ca6c579(void);
int32_t function_8ca6c683(void);
int32_t function_8ca6c8e7(void);
int32_t function_8ca6d005(void);
int32_t function_8ca6d238(void);
int32_t function_8ca6d4f9(void);
int32_t function_8ca6d547(void);
int32_t function_8ca6d6f0(void);
int32_t function_8ca6d74e(void);
int32_t function_8ca6d91d(void);
int32_t function_8ca6d9a5(void);
int32_t function_8ca6da9e(void);
int32_t function_8ca6dbb2(void);
int32_t function_8ca6dc03(void);
int32_t function_8ca6dd32(void);
int32_t function_8ca6e0e4(void);
int32_t function_8ca6e30a(void);
int32_t function_8ca6e465(void);
int32_t function_8ca6e52d(void);
int32_t function_8ca6e773(void);
int32_t function_8ca6e77c(void);
int32_t function_8ca6eed3(void);
int32_t function_8ca6f077(void);
int32_t function_8ca6f40c(void);
int32_t function_8ca6f4da(void);
int32_t function_8ca6f522(void);
int32_t function_8ca6f670(void);
int32_t function_8ca6f749(void);
int32_t function_8ca6faa9(void);
int32_t function_8ca6fde0(void);
int32_t function_8ca6feff(void);
int32_t function_8ca7033d(void);
int32_t function_8ca70655(void);
int32_t function_8ca707cc(void);
int32_t function_8ca70aab(void);
int32_t function_8ca71680(void);
int32_t function_8caa6b7b(void);
int32_t function_8cabd452(void);
int32_t function_8cacd9ec(void);
int32_t function_8cb3c9b1(void);
int32_t function_8cc7baba(void);
int32_t function_8ccd8a34(void);
int32_t function_8cded146(void);
int32_t function_8cedcfc1(void);
int32_t function_8cf0f39a(void);
int32_t function_8cf3c24c(void);
int32_t function_8cf9a887(void);
int32_t function_8de27876(void);
int32_t function_8e0d577d(void);
int32_t function_900042e5(void);
int32_t function_91004ab2(void);
int32_t function_91ece804(void);
int32_t function_924968f(void);
int32_t function_93a68d06(void);
int32_t function_944f5cfc(void);
int32_t function_96004a19(void);
int32_t function_972948be(void);
int32_t function_98a6d4a0(void);
int32_t function_9ba68587(void);
int32_t function_a27eaaf5(void);
int32_t function_a3f55b79(void);
int32_t function_a3ffffe4(void);
int32_t function_a5dc9c51(void);
int32_t function_a5f302e9(void);
int32_t function_a81a391e(void);
int32_t function_a98d044e(void);
int32_t function_b0059b5(void);
int32_t function_b2017228(void);
int32_t function_b3e99cec(void);
int32_t function_b3ed6094(void);
int32_t function_b502e9c1(void);
int32_t function_b6003e72(void);
int32_t function_b8a6a01b(void);
int32_t function_bd0057b9(void);
int32_t function_bd402da4(void);
int32_t function_be2b5ef9(void);
int32_t function_c0008963(void);
int32_t function_c0a64830(void);
int32_t function_c3c9d5c6(void);
int32_t function_c600d9b8(void);
int32_t function_c8d046d(void);
int32_t function_cc005977(void);
int32_t function_d0138a2(void);
int32_t function_d1116dd7(void);
int32_t function_d1a602d0(void);
int32_t function_d4ff9a2a(void);
int32_t function_d6783ab(void);
int32_t function_d6e0c5c1(void);
int32_t function_d953527(void);
int32_t function_db005977(int32_t a1);
int32_t function_dc826521(void);
int32_t function_e245a9e3(void);
int32_t function_e30113e5(int16_t a1);
int32_t function_e4a6a98d(void);
int32_t function_e830b293(void);
int32_t function_e89b014d(void);
int32_t function_e90547c4(void);
int32_t function_e950f125(int32_t a1);
int32_t function_e9a6df21(void);
int32_t function_ea002dab(void);
int32_t function_eda6bffb(void);
int32_t function_ee005a73(void);
int32_t function_f40df47a(void);
int32_t function_f49ca082(int32_t a1);
int32_t function_f4f41ab1(void);
int32_t function_f6cbb47b(void);
int32_t function_f8a6a796(void);
int32_t function_f9004a2a(void);
int32_t function_f922fd55(void);
int32_t function_f9a6a60a(void);
int32_t function_f9fb0069(void);
int32_t function_faa68357(void);
int32_t function_fd004ab2(void);
int32_t function_fd455568(void);
int32_t function_fe436498(void);
int32_t function_ff157ccd(int32_t a1);
int32_t function_ffbf98e8(void);
int32_t function_fff1ffd7(void);
int32_t function_ffff99be(void);
int32_t function_ffffce86(int32_t a1);
int32_t unknown_10001c1(int32_t a1);
int32_t unknown_1000242(void);
int32_t unknown_1000ac1(int32_t a1);
int32_t unknown_1000b3f(void);
int32_t unknown_1000cd1(void);
int32_t unknown_1000db0(void);
int32_t unknown_101(void);
int32_t unknown_10136c1(int32_t a1);
int32_t unknown_10152c1(void);
int32_t unknown_1015e54(int32_t a1);
int32_t unknown_1027bfb(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t unknown_111691e(void);
int32_t unknown_11f0e4(int32_t a1);
int32_t unknown_11f7ba9(void);
int32_t unknown_12007bc1(int16_t a1);
int32_t unknown_12007bd1(int32_t a1);
int32_t unknown_12007bfb(int32_t a1);
int32_t unknown_1207c26(void);
int32_t unknown_12661c1(int32_t a1);
int32_t unknown_127bfb(int32_t a1);
int32_t unknown_12c7b5f(void);
int32_t unknown_13007c4c(int32_t a1);
int32_t unknown_13c7b21(int32_t a1);
int32_t unknown_1402ca1(void);
int32_t unknown_14d7c26(void);
int32_t unknown_15003afb(void);
int32_t unknown_15ebd6f(void);
int32_t unknown_165abdd(void);
int32_t unknown_1671a18(int32_t a1);
int32_t unknown_168beba7(void);
int32_t unknown_16945ef(void);
int32_t unknown_1737bfb(int32_t a1);
int32_t unknown_17b94c1(int32_t a1, int32_t a2);
int32_t unknown_1800a3c1(void);
int32_t unknown_1802314(int32_t a1);
int32_t unknown_1997bfb(int32_t a1);
int32_t unknown_1a6c7bfb(void);
int32_t unknown_1a92650(void);
int32_t unknown_1bb71a3c(void);
int32_t unknown_1c007c26(void);
int32_t unknown_1cf17cbc(void);
int32_t unknown_1d0660d(void);
int32_t unknown_1db1a3c(void);
int32_t unknown_1e50bc1(void);
int32_t unknown_1edd3c(int16_t a1);
int32_t unknown_1f00353f(void);
int32_t unknown_1f37bc7(void);
int32_t unknown_1fb7bb7(void);
int32_t unknown_1ff8a62(int32_t a1, int32_t a2);
int32_t unknown_2009efb(void);
int32_t unknown_207bd1(int32_t a1, int32_t a2);
int32_t unknown_21007bfb(int32_t a1);
int32_t unknown_21d9fb(void);
int32_t unknown_22007bd1(int32_t a1);
int32_t unknown_2500ee2a(void);
int32_t unknown_2517a5(int32_t a1);
int32_t unknown_26be29(void);
int32_t unknown_2700bc54(void);
int32_t unknown_27547c26(void);
int32_t unknown_287bb1(void);
int32_t unknown_290254(int32_t a1);
int32_t unknown_2aba81cc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5);
int32_t unknown_2cd37c26(void);
int32_t unknown_2d34c1(int32_t a1);
int32_t unknown_2e36ed2(void);
int32_t unknown_2ee95c19(int32_t a1);
int32_t unknown_30161a3c(void);
int32_t unknown_3200bd6f(void);
int32_t unknown_3200e1e3(void);
int32_t unknown_33000058(int32_t a1, int32_t a2);
int32_t unknown_3777e730(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_37bd1(void);
int32_t unknown_3884c1(int32_t a1);
int32_t unknown_3a00031d(void);
int32_t unknown_3a00be29(int32_t a1, int32_t a2);
int32_t unknown_3a414516(void);
int32_t unknown_3ca37b87(void);
int32_t unknown_3cf25c(void);
int32_t unknown_3d007bfb(void);
int32_t unknown_3d007c09(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int16_t a10, int32_t a11);
int32_t unknown_3e0ee5(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_3f7bc1(int32_t a1);
int32_t unknown_41247bfb(void);
int32_t unknown_458bffff(void);
int32_t unknown_458e73d1(void);
int32_t unknown_4600ab09(int32_t a1);
int32_t unknown_4600bd50(int32_t a1, int32_t a2);
int32_t unknown_47007ba7(void);
int32_t unknown_47007bfb(int32_t a1);
int32_t unknown_47026859(void);
int32_t unknown_492c8982(void);
int32_t unknown_4b007bd1(void);
int32_t unknown_4c0045c4(void);
int32_t unknown_4c2c0(void);
int32_t unknown_4e4d14b6(int16_t a1);
int32_t unknown_507c26(void);
int32_t unknown_50d3d9ee(int16_t a1, int32_t a2);
int32_t unknown_51007bc3(int32_t a1);
int32_t unknown_510c9605(void);
int32_t unknown_52007d7d(int32_t a1);
int32_t unknown_5300ac26(void);
int32_t unknown_53668edb(void);
int32_t unknown_545c26(void);
int32_t unknown_547c4c(void);
int32_t unknown_56005291(void);
int32_t unknown_57007c26(void);
int32_t unknown_579765f(void);
int32_t unknown_58007b71(void);
int32_t unknown_5a00be0a(void);
int32_t unknown_5a011b2d(void);
int32_t unknown_5c13(int16_t a1);
int32_t unknown_5c7d7bcc(void);
int32_t unknown_5d007bd1(void);
int32_t unknown_5f007bc1(void);
int32_t unknown_6007bd1(void);
int32_t unknown_60c80f24(void);
int32_t unknown_62bd6f(int32_t a1, int32_t a2);
int32_t unknown_63000cc1(int32_t a1);
int32_t unknown_632677d3(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_65007bfb(int32_t a1, int32_t a2);
int32_t unknown_65011a18(int32_t a1);
int32_t unknown_650a33(int32_t a1);
int32_t unknown_6686c8(int32_t a1);
int32_t unknown_669d(void);
int32_t unknown_6a007bd1(int32_t a1);
int32_t unknown_6a007bff(int32_t a1);
int32_t unknown_6a012314(int32_t a1, int32_t a2);
int32_t unknown_6a7bac(void);
int32_t unknown_6b7bc1(void);
int32_t unknown_6b7bd1(int32_t a1);
int32_t unknown_6cb27c50(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int16_t * a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int16_t a10);
int32_t unknown_6d007bfb(int32_t a1);
int32_t unknown_6e81cc(int32_t a1);
int32_t unknown_6f008858(int32_t a1, int32_t a2);
int32_t unknown_71007bfb(int32_t a1);
int32_t unknown_71bc54(int32_t a1, int32_t a2);
int32_t unknown_7200dff5(int32_t a1);
int32_t unknown_73007b8c(void);
int32_t unknown_73007bd1(void);
int32_t unknown_73a5d1(int32_t a1);
int32_t unknown_74007c26(void);
int32_t unknown_7442a2a4(int16_t a1);
int32_t unknown_747b7a(int16_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t * a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9);
int32_t unknown_7500bbd4(int32_t * a1, int32_t a2);
int32_t unknown_782cc1(void);
int32_t unknown_787bfb(void);
int32_t unknown_7900bbd4(int32_t a1);
int32_t unknown_79085f18(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_7a660a04(void);
int32_t unknown_7b007bc1(void);
int32_t unknown_7b548f(int32_t a1);
int32_t unknown_7e007bc1(void);
int32_t unknown_7e7ba9(void);
int32_t unknown_7e8642(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_80007b93(void);
int32_t unknown_80730000(int16_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_8101014d(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t unknown_82dc58(int32_t a1);
int32_t unknown_83007bd1(int32_t a1);
int32_t unknown_84007bca(void);
int32_t unknown_840129c9(void);
int32_t unknown_84012f11(void);
int32_t unknown_849632(void);
int32_t unknown_87003a54(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_87007b9c(void);
int32_t unknown_87007bfb(int32_t a1, int32_t a2, int16_t a3);
int32_t unknown_88011a3c(int32_t a1);
int32_t unknown_890b8bff(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_89767c3a(void);
int32_t unknown_8c007b86(int32_t a1);
int32_t unknown_8d00fb93(void);
int32_t unknown_8f00fb(int32_t a1);
int32_t unknown_8f4022c1(int32_t a1);
int32_t unknown_905132(int32_t a1);
int32_t unknown_9185fe(int16_t a1);
int32_t unknown_93011a18(int32_t a1);
int32_t unknown_935454(void);
int32_t unknown_947bfb(int32_t a1, int32_t a2);
int32_t unknown_95007bfb(void);
int32_t unknown_96cae8b7(int16_t a1);
int32_t unknown_977bc1(int32_t a1);
int32_t unknown_97c309(int32_t a1, int32_t a2);
int32_t unknown_97eab3ba(int16_t a1);
int32_t unknown_98014714(void);
int32_t unknown_9961c1(int32_t a1);
int32_t unknown_99a42bb8(void);
int32_t unknown_99bdb7(void);
int32_t unknown_9b00a9d1(int32_t a1);
int32_t unknown_9c007bfb(void);
int32_t unknown_9cb17c26(void);
int32_t unknown_9f0147d0(void);
int32_t unknown_a0011a6d(int32_t a1);
int32_t unknown_a0012ac7(void);
int32_t unknown_a21a3c(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_a25c15(void);
int32_t unknown_a3004b26(void);
int32_t unknown_a6ce2f(void);
int32_t unknown_a7007c4c(int32_t a1, int32_t a2);
int32_t unknown_a77bc1(void);
int32_t unknown_a7967bd1(int32_t a1);
int32_t unknown_a90076c1(void);
int32_t unknown_aa007bc1(void);
int32_t unknown_ab007bd1(void);
int32_t unknown_ab0081f8(int32_t a1, int32_t a2);
int32_t unknown_ac007be3(void);
int32_t unknown_ae00b2c1(void);
int32_t unknown_ae7c60(int32_t * a1, int32_t a2);
int32_t unknown_afaac3c7(void);
int32_t unknown_b1007bc1(int32_t a1);
int32_t unknown_b200674c(void);
int32_t unknown_b47bc1(void);
int32_t unknown_b7011aa0(void);
int32_t unknown_b72b946c(void);
int32_t unknown_b8fc7bc1(int32_t a1, int32_t a2);
int32_t unknown_bc33bd6f(int32_t a1, int32_t a2);
int32_t unknown_bf007bd1(void);
int32_t unknown_bf7bd1(int32_t a1);
int32_t unknown_c2012670(void);
int32_t unknown_c2e8d1(int32_t a1);
int32_t unknown_c4007baf(void);
int32_t unknown_c4c7a877(void);
int32_t unknown_c4ffb2c1(int32_t a1);
int32_t unknown_c68cf0(void);
int32_t unknown_c70126d0(void);
int32_t unknown_c8007bd1(int32_t a1);
int32_t unknown_c8d0c(int16_t a1);
int32_t unknown_c8d54(int16_t a1);
int32_t unknown_c9987bd1(void);
int32_t unknown_cccccccc(int16_t a1);
int32_t unknown_cd7c4c(void);
int32_t unknown_ce77c0cf(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_d0001e26(void);
int32_t unknown_d1007bfb(void);
int32_t unknown_d17bd1(void);
int32_t unknown_d3012818(int32_t a1);
int32_t unknown_d3f5cb77(int32_t a1);
int32_t unknown_d4007c4c(void);
int32_t unknown_d57b9b(void);
int32_t unknown_d5dd81c(void);
int32_t unknown_d6007b0e(int32_t a1, int32_t a2, int32_t a3);
int32_t unknown_d74ab2(int32_t a1);
int32_t unknown_d8000000(int32_t a1, int32_t a2, int32_t a3, int16_t a4);
int32_t unknown_dff0e8(int16_t a1, int32_t a2);
int32_t unknown_e1007bc1(int32_t a1);
int32_t unknown_e100ab09(int32_t a1);
int32_t unknown_e28fbbd4(void);
int32_t unknown_e5007bd2(void);
int32_t unknown_e5007c26(int32_t a1);
int32_t unknown_e56f7bfb(void);
int32_t unknown_e7d70bfb(int32_t a1);
int32_t unknown_e8007bc1(int32_t a1);
int32_t unknown_e800bd0b(int32_t a1);
int32_t unknown_e850f495(int16_t a1, int32_t a2);
int32_t unknown_e87b6f(void);
int32_t unknown_e8b9150(int32_t a1, int32_t a2);
int32_t unknown_e97c27(void);
int32_t unknown_ea0089fb(int32_t a1);
int32_t unknown_eca26826(void);
int32_t unknown_eca77bfb(int32_t a1);
int32_t unknown_ecff8aff(int16_t a1);
int32_t unknown_ed7bfb(int32_t a1);
int32_t unknown_f007e82(int32_t a1, int32_t a2);
int32_t unknown_f0b07bfb(void);
int32_t unknown_f10128be(void);
int32_t unknown_f177e736(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_f2126626(int32_t a1, int32_t a2);
int32_t unknown_f21cbaee(int16_t a1);
int32_t unknown_f272c1(int32_t a1);
int32_t unknown_f3007c4c(int32_t a1, int32_t a2);
int32_t unknown_f5007bd1(int32_t a1);
int32_t unknown_f9007b5e(int32_t a1);
int32_t unknown_f9e4f9ed(void);
int32_t unknown_fb005a50(void);
int32_t unknown_fb007b5a(int32_t a1);
int32_t unknown_fb0102e1(int32_t a1);
int32_t unknown_fb846a05(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t unknown_fbbf46(int32_t a1);
int32_t unknown_fc724d(int32_t a1, int32_t a2, int32_t * a3);
int32_t unknown_fd34377d(void);
int32_t unknown_ff007c4c(void);
int32_t unknown_ffa178(int32_t a1);
int32_t unknown_ffa4f303(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8);
int32_t unknown_ffb7c1(int32_t a1);
int32_t unknown_ffd1fb(int32_t a1);
int32_t unknown_ffd5d1(int32_t a1);
int32_t unknown_ffe3c1(void);
int32_t unknown_ffe944(void);
int32_t unknown_ffeec1(int32_t a1);
int32_t unknown_fff4c1(int32_t a1);
int32_t unknown_ffffe887(int16_t a1);
int32_t unknown_ffffffec(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0x4d0020; // 0x1001264
int32_t g2 = -0x355cff8a; // 0x1005edd
int32_t g3 = 32; // 0x1014008
char * g4 = "\n"; // 0x1014010
int16_t g5 = 0x6c00; // 0x1014021
int32_t g6 = 46; // 0x101402c
int32_t g7 = 1; // 0x1014048
int32_t g8 = -1; // 0x101406b
char g9 = -1; // 0x1014300
char * g10; // 0x1014402
int16_t g11 = 0; // 0x101448d
int32_t g12 = 0; // 0x1014490
char * g13 = "\x01"; // 0x10144e8
int32_t g14 = 1; // 0x101454c
int32_t g15 = 6; // 0x101458c
int32_t g16 = 0x6ee3d3f4; // 0x1014608
int32_t g17 = 6; // 0x1014664
int32_t g18 = 6; // 0x1014718
int32_t g19 = 0x3f0eb2bc; // 0x1014790
int32_t g20 = 6; // 0x10147a8
char * g21 = "\x01"; // 0x10147c8
char * g22 = "\x01"; // 0x1014880
char * g23 = "\xff\xff\xff\xff\x02"; // 0x10148a4
char g24 = -1; // 0x10148a5
int64_t * g25 = (int64_t *)2; // 0x10148a8
int32_t g26 = 0x7fffffff; // 0x10148b0
int32_t g27 = 1; // 0x10148b8
char * g28; // 0x10148f5
char * g29; // 0x1014956
int32_t g30 = 0; // 0x1014a10
int32_t g31 = 0; // 0x1014b98
int32_t g32 = 0; // 0x1014c1b
char * g33; // 0x1014c70
int32_t g34 = 0; // 0x1014c94
int32_t g35 = 0; // 0x1014d14
char g36 = 0; // 0x1014d15
int32_t g37 = 0; // 0x1014d22
int32_t g38 = 0; // 0x1014d42
int32_t g39 = 0; // 0x1014d48
int32_t g40 = 0; // 0x1014d54
int32_t g41 = 0; // 0x1014d58
int32_t g42 = 0; // 0x1014d5c
int32_t g43 = 0; // 0x1014d62
char g44 = 0; // 0x1014d64
int32_t g45 = 0; // 0x1014d68
char * g46; // 0x1014d6c
char g47 = 0; // 0x1014d74
char g48 = 0; // 0x1014d78
int32_t g49 = 0; // 0x1014d7c
int32_t g50 = 0; // 0x1014d80
int32_t g51 = 0; // 0x1014d89
int32_t g52 = 0; // 0x1014d8c
int32_t g53 = 0; // 0x1014d90
int32_t g54 = 0; // 0x1014d94
char * g55; // 0x1014d98
int32_t g56 = 0; // 0x1014da6
int32_t g57 = 0; // 0x1014db7
char g58 = 0; // 0x1014dca
int32_t g59 = 0; // 0x1014de0
int32_t g60 = 0; // 0x1014de3
int32_t g61 = 0; // 0x1014dfc
int32_t g62 = 0; // 0x1014eec
int32_t g63 = 0; // 0x1014ef0
int32_t g64 = 0; // 0x1014efc
int32_t g65 = 0; // 0x1014f04
int32_t g66 = 0; // 0x1014f18
int32_t g67 = 0; // 0x1014f1b
int32_t g68 = 0; // 0x1014f20
int32_t g69 = 0; // 0x1014f24
int32_t g70 = 0; // 0x1014f26
int32_t g71 = 0; // 0x1014f28
int32_t g72 = 0; // 0x1014f30
int32_t g73 = 0; // 0x1014f31
char * g74; // 0x1014f38
char * g75; // 0x1014f40
int32_t g76 = 0; // 0x1014f4c
char g77 = 0; // 0x1014f5c
char g78 = 0; // 0x1014f60
int32_t g79 = 0; // 0x1014f62
char g80 = 0; // 0x1014f64
int32_t g81 = 0; // 0x1014f70
int32_t g82 = 0; // 0x1014f71
int16_t g83 = 0; // 0x1014f7c
int32_t g84 = 0; // 0x1014f7e
int32_t g85 = 0; // 0x1014f7f
char g86 = 0; // 0x1014f80
char * g87; // 0x1014f84
char * g88; // 0x1014f88
int32_t g89 = 0; // 0x1014f8c
int32_t g90 = 0; // 0x1014f90
int32_t g91 = 0; // 0x1014f98
int32_t g92 = 0; // 0x1014f9d
int32_t g93 = 0; // 0x1014fa0
int32_t g94 = 0; // 0x1014fa4
int32_t g95 = 0; // 0x1014fa7
char g96 = 0; // 0x1014fa8
char * g97; // 0x1014fa9
int32_t g98 = 0; // 0x1014fac
char * g99; // 0x1014fb0
int32_t g100 = 0; // 0x1014fb4
int32_t g101 = 0; // 0x1014fb8
int32_t g102 = 0; // 0x1014fba
int32_t g103 = 0; // 0x1014fbc
int32_t g104 = 0; // 0x1014fc2
char g105 = 0; // 0x1014fc8
int32_t g106 = 0; // 0x1014fcc
int32_t g107 = 0; // 0x1014fd8
char g108 = 0; // 0x1014fe6
char * g109; // 0x1014fe8
int32_t g110 = 0; // 0x1014fec
int32_t g111 = 0; // 0x1014ff0
int32_t g112 = 0; // 0x1014ff4
int32_t g113 = 0; // 0x1014ff6
int32_t g114 = 0; // 0x1014ff8
int32_t g115 = 0; // 0x1014ffe
char * g116 = "\x93"; // 0x1016b62
int32_t g117 = 0; // 0x101906c
int32_t g118 = 0; // 0x1019c59
int32_t g119 = -0x2a0801; // 0x101a810
int32_t g120 = 0x31000000; // 0x101afb8
int32_t g121 = 0; // 0x101c0fb
char g122 = 48; // 0x101ca98
char * g123; // 0x101d390
int32_t g124 = 0x44f0438; // 0x101dedc
int32_t g125;

// ------------------------ Functions -------------------------

// Address range: 0x100125b - 0x1001473
int32_t function_100125b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, uint32_t a5, uint32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11, uint32_t a12, int32_t a13, int32_t a14, int32_t a15, int32_t a16, int32_t a17, uint32_t a18, uint32_t a19, int32_t a20, int32_t a21, int32_t a22, int32_t a23) {
    int32_t v1 = a21;
    int32_t v2 = a8;
    int32_t v3 = a2;
    int32_t result3; // 0x100125b
    int32_t v4; // 0x100125b
    uint32_t v5 = result3 + (v4 & 0xff00);
    int32_t v6; // 0x100125b
    *(char *)v6 = *(char *)&v6 + (char)result3;
    int32_t v7; // 0x100125b
    uint32_t v8 = 257 * v7;
    int32_t v9 = v8 & 0xff00 | v7 & -0xff01; // 0x1001261
    uint32_t v10 = result3;
    *(char *)v10 = *(char *)&result3 + (char)(v10 / 256);
    char v11 = v4; // 0x1001265
    int32_t v12; // 0x100125b
    *(char *)v12 = *(char *)&v12 + v11;
    int32_t v13; // 0x100125b
    *(char *)v13 = *(char *)&v13 + v11;
    char v14 = v8 / 256; // 0x100126b
    *(char *)v6 = *(char *)&v6 + v14;
    char * v15 = (char *)v9; // 0x100126f
    *v15 = *v15 + v14;
    int32_t v16; // 0x100125b
    __asm_outsd((int16_t)v9, v16);
    *(char *)v12 = *(char *)&v12 + v14;
    uint32_t v17 = __asm_int1(); // 0x1001278
    char v18 = v5 / 256; // 0x1001279
    *(char *)v16 = *(char *)&v16 + v18;
    unsigned char v19 = (char)(v17 / 256); // 0x100127c
    unsigned char v20 = v19 + v18; // 0x100127c
    int32_t v21 = 256 * (int32_t)v20 | v17 & -0xff01; // 0x100127c
    result3 = v21;
    unsigned char v22 = (char)v17; // 0x100127f
    bool v23 = v22 > 153 | v20 < v19;
    int32_t v24; // 0x100125b
    if ((v22 & 14) > 9 || (v19 & 15) + (v18 & 15) > 15) {
        v24 = (v23 ? 154 : 250) + v17 & 255 | v21 & -256;
    } else {
        v24 = v21 & -256 | (v23 ? v17 + 160 : v17) & 255;
    }
    int32_t v25 = v24;
    result3 = v25;
    int32_t v26 = *(int32_t *)v25 ^ v25; // 0x1001280
    char * v27 = (char *)v26; // 0x1001284
    char v28 = v26; // 0x1001284
    *v27 = (*v27 ^ v28) + v28;
    int32_t v29 = &v3; // 0x100128a
    char * v30 = (char *)((v5 & 0xff00 | v4 & -0xff01) + 0x751a6f00); // 0x100128b
    *v30 = *v30 + v14;
    *(char *)v6 = *(char *)&v6 + v14;
    v13 = v29;
    v16 = v3;
    v12 = a3;
    v6 = a4;
    char * v31 = (char *)v3; // 0x1001295
    char v32 = a6 / 256; // 0x1001295
    *v31 = *v31 + v32;
    char v33 = __readfsbyte(a7); // 0x1001298
    char v34 = a7; // 0x1001298
    __writefsbyte(a7, v33 + v34);
    char * v35 = (char *)a7; // 0x100129e
    *v35 = *v35 + v34;
    int32_t v36 = 110 * *(int32_t *)a7; // 0x10012a0
    result3 = v36;
    char * v37 = (char *)(v29 - 16); // 0x10012a3
    unsigned char v38 = *v37; // 0x10012a3
    *v37 = (char)(a5 / 256);
    char * v39 = (char *)v36; // 0x10012a7
    char v40 = v36; // 0x10012a7
    *v39 = *v39 + 2 * v40;
    char * v41 = (char *)a4; // 0x10012ab
    *v41 = *v41 + v32;
    char * v42 = (char *)(a3 + 101 + v29); // 0x10012ad
    char v43 = *v42; // 0x10012ad
    char v44 = v43 + v40; // 0x10012ad
    *v42 = v44;
    char v45; // 0x100125b
    int16_t v46; // 0x100125b
    int32_t v47; // 0x100125b
    int32_t * v48; // 0x100125b
    int16_t v49; // 0x100125b
    if (v44 < 0 == ((v44 ^ v43) & (v44 ^ v40)) < 0 == (v44 != 0)) {
        int32_t v50 = 256 * (int32_t)v38 | a5 & -0xff01; // 0x10012a3
        char * v51 = (char *)(v13 + 0x20006e00); // 0x100131b
        *v51 = *v51 + (char)a6;
        char * v52 = (char *)v12; // 0x1001321
        *v52 = *v52 + v38;
        result3 = v49;
        char * v53 = (char *)(v13 - 0x3ff9200); // 0x1001325
        *v53 = *v53 + (char)(v6 / 256);
        v45 = a5;
        v46 = v50;
        v47 = v50;
        v48 = &v2;
    } else {
        char * v54 = (char *)a6; // 0x10012b3
        *v54 = *v54 + v32;
        int32_t * v55 = (int32_t *)result3; // 0x10012b6
        *v55 = *v55 & result3;
        v12 = a9;
        v6 = a10;
        result3 = a13;
        char * v56 = (char *)(2 * a13 - 109); // 0x10012b9
        *v56 = *v56 + (char)(a12 / 256);
        *(int32_t *)(int32_t)v49 = *(int32_t *)v2;
        v13 = ((a1 & 1024) != 0 ? -4 : 4) + (int32_t)v49;
        uint32_t v57 = (a12 & 0xff00) + a10;
        char * v58 = (char *)a13; // 0x10012c0
        *v58 = *v58 + (char)a13;
        char * v59 = (char *)a9; // 0x10012c3
        char v60 = a11;
        *v59 = *v59 + v60;
        __writegsbyte(v6 - 57, __readgsbyte(v6 - 57) + v60);
        char v61 = __asm_in_1(0); // 0x10012cc
        int32_t v62 = result3 & -256 | (int32_t)v61; // 0x10012cc
        result3 = v62;
        v16 = a11;
        char * v63 = (char *)v62; // 0x10012d0
        *v63 = *v63 + 2 * v61;
        int16_t v64 = a11;
        *(char *)v13 = __asm_insb(v64);
        char * v65 = (char *)(v57 & 0xff00 | a12 & -0xff01); // 0x10012d5
        char v66 = *v65 + (char)(v62 / 256); // 0x10012d5
        *v65 = v66;
        if (v66 < 0) {
            // 0x10012da
            __asm_outsd(v64, *(int32_t *)v16);
            char * v67 = (char *)(v13 + 0x7400); // 0x10012db
            *v67 = *v67 + (char)(v57 / 256);
            char * v68 = (char *)result3; // 0x10012e1
            *v68 = *v68 + (char)result3;
            char * v69 = (char *)v12; // 0x10012e3
            *v69 = *v69 + (char)result3;
            char * v70 = (char *)v16; // 0x10012e7
            *v70 = *v70 + (char)(v6 / 256);
            int32_t * v71 = (int32_t *)result3; // 0x10012ea
            *v71 = result3;
            int32_t v72 = v6; // 0x10012ed
            v6 = *v71 - 1;
            char * v73 = (char *)v72; // 0x10012ee
            *v73 = *v73 + (char)v72;
            v13 = a14;
            v16 = a15;
            v12 = a16;
            v6 = a17;
            result3 = a20;
            char * v74 = (char *)(2 * a20 + 99); // 0x10012f3
            *v74 = *v74 + (char)(a19 / 256);
            char * v75 = (char *)a16; // 0x10012f7
            unsigned char v76 = *v75; // 0x10012f7
            char v77 = a19; // 0x10012f7
            unsigned char v78 = v76 + v77; // 0x10012f7
            *v75 = v78;
            int32_t result = result3;
            if (v78 < v76) {
                // 0x10012fc
                return result;
            }
            char * v79 = (char *)result; // 0x1001364
            *v79 = *v79 & (char)result;
            char * v80 = (char *)result3; // 0x1001366
            *v80 = *v80 + (char)result3;
            char * v81 = (char *)v6; // 0x100136b
            *v81 = *v81 + (char)v6;
            char * v82 = (char *)(v12 - 117); // 0x100136f
            *v82 = *v82 + (char)a18;
            int32_t v83 = v6;
            v6 = 2 * v83 & 254 | v83 & -256;
            char * v84 = (char *)result3; // 0x1001376
            *v84 = *v84 + (char)result3;
            uint32_t v85 = 256 * a18 & 0xff00 ^ a19; // 0x1001378
            char * v86 = (char *)result3; // 0x100137a
            *v86 = *v86 + (char)result3;
            char * v87 = (char *)v13; // 0x100137e
            *v87 = *v87 + (char)result3;
            char * v88 = (char *)result3; // 0x1001380
            *v88 = *v88 + (char)result3;
            char * v89 = (char *)v13; // 0x1001383
            *v89 = *v89 + (char)(v6 / 256);
            char * v90 = (char *)result3; // 0x1001386
            *v90 = *v90 + (char)result3;
            char * v91 = (char *)(v6 - 0x1ff0580); // 0x100138a
            char v92 = v85 / 256; // 0x100138a
            *v91 = *v91 + v92;
            int32_t v93 = a18 & -256; // 0x1001390
            char * v94 = (char *)result3; // 0x1001392
            *v94 = *v94 + (char)result3;
            int32_t v95 = result3 - 1; // 0x1001394
            char * v96 = (char *)v95; // 0x1001395
            char v97 = v95; // 0x1001395
            *v96 = *v96 + v97;
            char * v98 = (char *)v16; // 0x1001397
            *v98 = *v98 + (char)(a18 / 256);
            *v96 = *v96 + v97;
            int16_t v99 = v93; // 0x100139f
            __asm_outsd(v99, *(int32_t *)v16);
            int32_t v100 = ((v95 & 14) > 9 ? result3 + 5 : v95) & 15; // 0x10013a0
            char * v101 = (char *)(v100 | v95 & -0x10000 | 256 * (int32_t)((v95 & 14) > 9) + v95 & 0xff00); // 0x10013a1
            *v101 = *v101 + (char)v100;
            int32_t v102 = __asm_hlt(); // 0x10013a3
            result3 = v102;
            v12 = a22;
            char * v103 = (char *)v102; // 0x10013aa
            char v104 = v102; // 0x10013aa
            *v103 = *v103 + 2 * v104;
            int32_t v105 = v13 + 1; // 0x10013b2
            char * v106 = (char *)(a22 - 0x57000000); // 0x10013b3
            *v106 = *v106 + v104;
            *v103 = *v103 + v104;
            char * v107 = (char *)(v16 + 0x42000053); // 0x10013bb
            *v107 = *v107 + v104;
            *v103 = *v103 + v104;
            char * v108 = (char *)(v13 + 0x4388c0e5); // 0x10013c3
            *v108 = *v108 + v104;
            *v103 = *v103 + v104;
            char * v109 = (char *)(v102 + 0x44000000); // 0x10013cb
            *v109 = *v109 + v77;
            *v103 = *v103 + v104;
            char * v110 = (char *)(v85 + 0x4528f400); // 0x10013d3
            *v110 = *v110 + v77;
            *(char *)v105 = v104;
            char * v111 = (char *)(v93 + 0x46000000); // 0x10013db
            *v111 = *v111 + v77;
            int32_t v112 = v6;
            int32_t v113 = (v112 & 0xff00) + v102 & 0xff00 | v112 & -0xff01; // 0x10013e1
            v6 = v113;
            char * v114 = (char *)(v113 + 0x27000000); // 0x10013e3
            *v114 = *v114 + v77;
            *v103 = *v103 + v104;
            char * v115 = (char *)v93; // 0x10013eb
            *v115 = *v115 + v92;
            *v103 = *v103 + v104;
            *v115 = *v115 + v77;
            char * v116 = (char *)(v105 + ((a1 & 1024) != 0 ? -1 : 1)); // 0x10013f7
            *v116 = *v116 + v77;
            char v117 = *v103 + v104; // 0x10013fa
            *v103 = v117;
            if (v117 != 0) {
                char * v118 = (char *)result3; // 0x1001466
                *v118 = *v118 + (char)result3;
                __asm_in_1(0);
                int32_t v119 = __asm_sti(); // 0x100146a
                *v115 = *v115 + (char)v6;
                char * v120 = (char *)v119; // 0x100146e
                char v121 = *v120; // 0x100146e
                *v120 = v121 + (char)v119;
                return v119 & -256 | (int32_t)-v121;
            }
            char * v122 = (char *)v6; // 0x10013fe
            *v122 = *v122 + (char)(v6 / 256);
            uint32_t v123 = (int32_t)&v1; // 0x1001400
            char * v124 = (char *)(2 * result3 + 100); // 0x1001401
            *v124 = *v124 + v92;
            char * v125 = (char *)result3; // 0x1001405
            *v125 = *v125 + (char)result3;
            char * v126 = (char *)(v16 + 0x5b006b); // 0x100140a
            *v126 = *v126 + v92;
            __asm_out_2(v99, result3);
            char * v127 = (char *)result3; // 0x1001412
            *v127 = *v127 + 1;
            v13 = v1;
            char * v128 = (char *)v6; // 0x1001417
            *v128 = *v128 + (char)(result3 / 256);
            char * v129 = (char *)result3; // 0x1001419
            unsigned char v130 = *v129; // 0x1001419
            *v129 = (char)result3;
            int32_t v131 = result3 & -256 | (int32_t)v130; // 0x1001419
            char * v132 = (char *)(v123 - 14); // 0x100141b
            *v132 = *v132 + (char)(v123 / 256);
            char * v133 = (char *)v131; // 0x100141e
            *v133 = *v133 + v130;
            int32_t v134 = v131 + 1; // 0x1001420
            result3 = v134;
            v1 = 0x4d000000;
            char * v135 = (char *)v134; // 0x1001429
            char v136 = v134; // 0x1001429
            unsigned char v137 = *v135 + v136; // 0x1001429
            unsigned char v138 = v137 + v136; // 0x100142e
            *v135 = v138;
            v1 = v93;
            *v135 = *v135 + v136 + (char)(v138 < v137);
            v16 = v1;
            __writegsbyte(v134, __readgsbyte(v134) + v136);
            unsigned char v139 = *v135; // 0x1001439
            unsigned char v140 = v139 + v136; // 0x1001439
            *v135 = v140;
            uint32_t v141 = v123 & 28; // 0x100143b
            if (v141 != 0) {
                uint32_t v142 = v12; // 0x100143b
                v12 = (int32_t)(v140 < v139) << v141 - 1 | v142 << v141 | (int32_t)((int64_t)v142 >> (int64_t)(33 - v141));
            }
            char * v143 = (char *)result3; // 0x100143d
            *v143 = *v143 + (char)result3;
            char * v144 = (char *)result3; // 0x1001442
            *v144 = *v144 + (char)result3;
            unsigned char v145 = *(char *)0x58000000; // 0x1001444
            int32_t v146 = result3 & -256; // 0x1001444
            int32_t v147 = v146 | (int32_t)v145; // 0x1001444
            char * v148 = (char *)v147; // 0x1001449
            *v148 = *v148 + v145;
            char * v149 = (char *)(v12 - 127); // 0x100144b
            *v149 = *v149 + 76;
            char * v150 = (char *)(v147 + 0x790000 + v13); // 0x1001453
            *v150 = *v150 - 56;
            *v148 = *v148 + v145;
            unsigned char v151 = v145 ^ -24; // 0x1001460
            int32_t result2 = v146 | (int32_t)v151; // 0x1001460
            char * v152 = (char *)result2; // 0x1001462
            *v152 = *v152 + v151;
            return result2;
        }
        char * v153 = (char *)result3; // 0x10012fd
        unsigned char v154 = *v153; // 0x10012fd
        unsigned char v155 = v154 + v60; // 0x10012fd
        *v153 = v155;
        int32_t v156 = result3; // 0x1001300
        unsigned char v157 = (char)v156; // 0x1001300
        bool v158 = v155 < v154 | v157 > 153;
        int32_t v159; // 0x100125b
        if ((v154 & 15) + (v60 & 15) > 15 || (v157 & 14) > 9) {
            v159 = (v158 ? 154 : 250) + v156 & 255 | v156 & -256;
        } else {
            v159 = (v158 ? v156 + 160 : v156) & 255 | v156 & -256;
        }
        result3 = v159;
        char * v160 = (char *)v12; // 0x1001301
        char v161 = v57 / 256; // 0x1001301
        unsigned char v162 = *v160 + v161; // 0x1001301
        *v160 = v162;
        v45 = v60;
        v46 = v64;
        v47 = a11;
        int32_t v163; // bp+62, 0x100125b
        v48 = &v163;
        if (v162 >= 1) {
            // 0x1001306
            *v65 = *v65 + v161;
            char v164 = *(char *)0x64976e; // 0x100130f
            *(char *)0x64976e = (char)(a11 / 256) + 110 + v161 + v164;
            return 0x64976e;
        }
    }
    int32_t v165 = (int32_t)v48;
    char * v166 = (char *)(v13 + 14); // 0x100132b
    char v167 = v47 / 256; // 0x100132b
    *v166 = *v166 + v167;
    __asm_outsb(v46, *(char *)v16);
    char * v168 = (char *)v47; // 0x1001335
    *v168 = *v168 + v167;
    __asm_outsd(v46, *(int32_t *)v16);
    char * v169 = (char *)(2 * result3 + 0x680020); // 0x1001339
    *v169 = *v169 + v45;
    int32_t v170 = *(int32_t *)(v165 + 8); // 0x1001340
    uint32_t v171 = *(int32_t *)(v165 + 20); // 0x1001340
    v16 = *(int32_t *)(v165 + 4);
    v12 = v170;
    result3 = *(int32_t *)(v165 + 28);
    char * v172 = (char *)*(int32_t *)(v165 + 16); // 0x1001341
    char v173 = v171 / 256; // 0x1001341
    *v172 = *v172 + v173;
    char * v174 = (char *)(v170 + 0x63006f); // 0x1001344
    *v174 = *v174 & v173;
    int16_t v175 = v171; // 0x100134e
    __asm_out(v175, (char)result3);
    char * v176 = (char *)v171; // 0x100134f
    *v176 = *v176 + (char)(result3 / 256);
    int32_t v177 = v16;
    __writefsbyte(v177, __readfsbyte(v177) + (char)(*(int32_t *)(v165 + 24) / 256));
    char * v178 = (char *)result3; // 0x1001355
    *v178 = *v178 + (char)result3;
    char * v179 = (char *)(v171 + 38); // 0x1001359
    *v179 = *v179 + v173;
    __asm_outsd(v175, *(int32_t *)v16);
    char * v180 = (char *)(v171 - 119); // 0x100135f
    *v180 = *v180 + v173;
    __asm_out_2(v175, result3);
    return result3;
}

// Address range: 0x1001473 - 0x10014e3
int32_t function_1001473(uint32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, uint32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11) {
    // 0x1001473
    bool v1; // 0x1001473
    int32_t v2 = v1 ? 255 : 0; // 0x1001473
    uint32_t v3; // 0x1001473
    int32_t v4 = v2 | v3 & -256; // 0x1001473
    char * v5 = (char *)v4; // 0x1001475
    char v6 = v2;
    *v5 = *v5 + v6;
    char v7 = v3 / 256; // 0x1001477
    *(char *)-0x6b000000 = *(char *)-0x6b000000 + v7;
    *v5 = *v5 + v6;
    int32_t v8; // 0x1001473
    uint32_t v9; // 0x1001473
    *(char *)v8 = *(char *)&v8 + (char)v9;
    char v10 = 2 * v6;
    *v5 = *v5 + v10;
    char v11 = a1 / 256; // 0x1001487
    *(char *)0x701800a1 = *(char *)0x701800a1 + v11;
    int32_t v12; // 0x1001473
    *(char *)v12 = *(char *)&v12 + v7;
    char * v13 = (char *)a1; // 0x100148f
    *v13 = *v13 + (char)(v9 / 256);
    *v5 = *v5 + v6;
    char * v14 = (char *)(2 * v4); // 0x1001493
    *v14 = *v14 + (char)a1;
    int32_t v15; // 0x1001473
    *(char *)v15 = *(char *)&v15 + v7;
    *v5 = *v5 + v6;
    int32_t v16; // 0x1001473
    *(char *)v15 = *(char *)&v15 + (char)v16;
    *v5 = *v5 + v6;
    int32_t v17 = 0x10000 * v4 / 0x10000; // 0x10014a0
    char * v18 = (char *)v17; // 0x10014a1
    *v18 = *v18 + v10;
    *(char *)v15 = *(char *)&v15 + 87;
    *v18 = *v18 + (char)v17;
    char * v19 = (char *)(v15 - 126); // 0x10014af
    *v19 = *v19 + v11;
    char * v20 = (char *)a3; // 0x10014b2
    *v20 = *v20 + (char)a3;
    uint32_t v21 = __asm_int1(); // 0x10014b5
    char * v22 = (char *)v21; // 0x10014bb
    char v23 = v21 / 256; // 0x10014bb
    *v22 = *v22 + v23;
    *(char *)0x28000000 = *(char *)0x28000000 + (char)a9;
    char v24 = v21; // 0x10014c9
    *v22 = *v22 + v24;
    char * v25 = (char *)(v21 + a8 & 255 | a8 & -0x10000 | v21 + (a8 & 0xff00) & 0xff00); // 0x10014cb
    char v26 = a7 / 256; // 0x10014cb
    *v25 = *v25 + v26;
    *v22 = *v22 + v24;
    int32_t * v27 = (int32_t *)v21; // 0x10014d0
    *v27 = *v27 - v21;
    char * v28 = (char *)(a6 + 0x6e007b); // 0x10014d2
    *v28 = *v28 + v23;
    *v22 = *v22 + v24;
    char * v29 = (char *)a9; // 0x10014db
    *v29 = *v29 + v26;
    return function_10065e3((int32_t)&g125);
}

// Address range: 0x10014e3 - 0x100150b
int32_t function_10014e3(void) {
    // 0x10014e3
    int32_t v1; // 0x10014e3
    char * v2 = (char *)(v1 + 34); // 0x10014e3
    uint32_t v3; // 0x10014e3
    char v4 = v3; // 0x10014e3
    *v2 = *v2 + v4;
    int32_t v5; // 0x10014e3
    int32_t v6 = v5;
    *(char *)v6 = *(char *)&v5 + (char)v6;
    int32_t v7 = v5;
    *(char *)v7 = *(char *)&v5 + (char)v7;
    int32_t v8 = v5;
    *(char *)v8 = *(char *)&v5 + (char)v8;
    int32_t v9 = v5;
    *(char *)v9 = *(char *)&v5 + (char)v9;
    char * v10 = (char *)(2 * v5); // 0x10014f3
    *v10 = *v10 + v4;
    int32_t v11 = v5;
    *(char *)v11 = *(char *)&v5 + (char)v11;
    int32_t v12 = v5;
    *(char *)v12 = *(char *)&v5 + (char)v12;
    int32_t v13 = v5 + 115; // 0x10014ff
    int32_t v14 = v13 & 255 | v5 & -256; // 0x10014ff
    char * v15 = (char *)v14; // 0x1001501
    *v15 = *v15 + (char)v13;
    char * v16 = (char *)(2 * v14); // 0x1001503
    *v16 = *v16 + (char)(v3 / 256);
    return 257 * v1 & 0xff00 | v1 & -0xff01;
}

// Address range: 0x10015df - 0x10015e0
int32_t function_10015df(void) {
    // 0x10015df
    int32_t result; // 0x10015df
    return result;
}

// Address range: 0x10015e4 - 0x10015e6
int32_t function_10015e4(void) {
    // 0x10015e4
    int32_t result; // 0x10015e4
    return result;
}

// Address range: 0x1001624 - 0x1001639
int32_t function_1001624(void) {
    // 0x1001624
    int32_t v1; // 0x1001624
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x1001624
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 + (char)v3;
    int32_t v4 = v2;
    *(char *)v4 = *(char *)&v2 + (char)v4;
    int32_t v5 = v2;
    *(char *)v5 = *(char *)&v2 + (char)v5;
    int32_t v6 = v2;
    *(char *)v6 = *(char *)&v2 + (char)v6;
    int32_t v7 = v2;
    *(char *)v7 = *(char *)&v2 + (char)v7;
    int32_t v8; // 0x1001624
    return function_1001652(v8);
}

// Address range: 0x100164b - 0x1001652
int32_t function_100164b(void) {
    // 0x100164b
    int32_t v1; // 0x100164b
    bool v2; // 0x100164b
    return v1 + 0x150093cd + (int32_t)v2;
}

// Address range: 0x1001652 - 0x1001654
int32_t function_1001652(int32_t a1) {
    // 0x1001652
    return function_10015df();
}

// Address range: 0x1001654 - 0x1001657
int32_t function_1001654(int32_t a1) {
    // 0x1001654
    int32_t result; // 0x1001654
    return result;
}

// Address range: 0x1001657 - 0x100179d
int32_t function_1001657(int32_t a1) {
    // 0x1001657
    int32_t v1; // 0x1001657
    char * v2 = (char *)(v1 - 34); // 0x1001658
    *v2 = *v2 ^ (char)v1;
    uint32_t v3; // 0x1001657
    int32_t * v4 = (int32_t *)(v3 + 0x100108c); // 0x1001667
    *v4 = *v4 + 1;
    int32_t v5 = v3 + 111; // 0x100166f
    int32_t v6 = v3 & -256; // 0x100166f
    int32_t result = v5 & 255 | v6; // 0x100166f
    unsigned char v7 = (char)v5; // 0x1001671
    uint16_t v8 = *(int16_t *)result; // 0x1001684
    int32_t v9; // 0x1001657
    uint32_t v10; // 0x1001657
    *(char *)v9 = (char)(v10 / 256 | v9);
    int32_t v11; // 0x1001657
    __asm_outsd((int16_t)v10, v11);
    char * v12 = (char *)result; // 0x1001698
    *v12 = *v12 + v7;
    int32_t v13; // 0x1001657
    if ((v13 & 0x7fffffff) == 1) {
        char * v14 = (char *)(v11 - 125); // 0x10016a3
        *v14 = *v14 & (char)(v3 / 256);
        return result;
    }
    // 0x10016aa
    int32_t v15; // bp-8, 0x1001657
    int32_t v16 = &v15; // 0x1001666
    int32_t v17 = v16 - 4; // 0x10016b9
    *(int32_t *)v17 = result;
    bool v18 = v7 > 153 | v8 < 34 == (v8 != 34);
    int32_t v19 = v18 ? v3 + 207 : v5;
    int32_t v20 = (v7 & 14) > 9 | v8 != 34 == (v8 & 15) > 17 ? (v18 ? 102 : 6) + v5 : v19;
    int32_t v21 = v20 & 255 | v6;
    int32_t v22 = *(int32_t *)v21; // 0x10016bd
    int16_t v23 = v22; // 0x10016bf
    int32_t result3; // 0x1001657
    int32_t v24; // 0x1001657
    int32_t v25; // 0x1001657
    int32_t v26; // 0x1001657
    if (v23 != 0) {
        // 0x10016f4
        *(int32_t *)(v16 - 8) = -0x7a49fa17;
        char * v27 = (char *)v21; // 0x10016fc
        *v27 = *v27 + (char)v20;
        *(int32_t *)(v16 - 12) = v21;
        int32_t v28 = v22 & -0x10000 | (int32_t)*(int16_t *)v21; // 0x1001715
        if (v28 != 0) {
            int32_t v29 = v20 + 64 & 255 | v6; // 0x100171e
            int32_t * v30 = (int32_t *)v28; // 0x1001720
            *v30 = *v30 + v29;
            *(int32_t *)(v16 - 16) = v29;
            return function_10017b3();
        }
        int32_t v31 = v10 - 1; // 0x10016f4
        int32_t v32 = v16 - 16; // 0x1001786
        *(int32_t *)v32 = v31;
        int32_t * v33 = (int32_t *)(v9 + 12); // 0x1001787
        *v33 = *v33 | v11;
        v24 = v9 + 1;
        result3 = v21;
        v25 = v31;
        v26 = v32;
    } else {
        char * v34 = (char *)(v21 & -0xff01 | 0x4000 * (int32_t)(v23 == 0) | 0x8000 * (int32_t)(v23 < 0) | 1024 * (int32_t)((llvm_ctpop_i8((char)v22) & 1) == 0) | 512); // 0x10016cc
        *v34 = *v34 + (char)v20;
        int32_t * v35 = (int32_t *)(*(int32_t *)v22 + v17); // 0x10016cf
        int32_t v36 = *v35; // 0x10016cf
        *v35 = 2;
        int128_t v37; // 0x1001657
        __asm_comiss(v37, *(int128_t *)(v9 + 0x1500007f));
        __asm_bound(*(int64_t *)(v10 + 124 + 2 * v10));
        int32_t result2 = v36 + 0x2a74 & 0xffff | v36 & -0x10000; // 0x10016e4
        result3 = result2;
        v26 = v9 + 4;
        if (v22 != 105) {
            // 0x10016f1
            return result2;
        }
    }
    // 0x100178a
    *(int32_t *)(v26 - 4) = result3;
    char * v38 = (char *)(v24 + 0x68e356c9); // 0x1001790
    char v39 = result3; // 0x1001790
    *v38 = *v38 - v39;
    char * v40 = (char *)(result3 + 1); // 0x1001796
    *v40 = *v40 | v39;
    int32_t * v41 = (int32_t *)(result3 - 24); // 0x1001799
    *v41 = *v41 + v25;
    return result3;
}

// Address range: 0x10017a0 - 0x10017b3
int32_t function_10017a0(void) {
    // 0x10017a0
    g3 = 0xf5993a;
    int32_t result; // 0x10017a0
    return result;
}

// Address range: 0x10017b3 - 0x10017bf
int32_t function_10017b3(void) {
    // 0x10017b3
    int32_t v1; // 0x10017b3
    int32_t v2; // 0x10017b3
    return v2 & -0x10000 | (int32_t)*(int16_t *)(v1 + 22);
}

// Address range: 0x10017d4 - 0x10017dd
int32_t function_10017d4(int32_t a1) {
    // 0x10017d4
    int32_t v1; // 0x10017d4
    char * v2 = (char *)(v1 + 1); // 0x10017d6
    int32_t v3; // 0x10017d4
    *v2 = *v2 & (char)v3;
    int32_t result; // 0x10017d4
    int32_t * v4 = (int32_t *)(result + 92); // 0x10017d9
    int32_t v5; // 0x10017d4
    *v4 = *v4 + v5;
    return result;
}

// Address range: 0x10017ec - 0x10017ed
int32_t function_10017ec(void) {
    // 0x10017ec
    int32_t result; // 0x10017ec
    return result;
}

// Address range: 0x10017ed - 0x1001883
int32_t function_10017ed(void) {
    // 0x10017ed
    int32_t v1; // 0x10017ed
    int32_t v2; // 0x10017ed
    *(int32_t *)(v2 - 62) = (int32_t)&v1;
    int32_t * v3 = (int32_t *)(v2 - 0x2538238b); // 0x10017f0
    uint32_t v4 = *v3; // 0x10017f0
    uint32_t v5 = v4 + v2; // 0x10017f0
    *v3 = v5;
    if (v2 == 1 || v5 == 0) {
        // 0x10017f8
        uint32_t v6; // 0x10017ed
        *(char *)-0x1bba7700 = *(char *)-0x1bba7700 + (char)(v6 / 256);
        int32_t hInstance; // 0x10017ed
        return (int32_t)LoadCursorW((int32_t *)hInstance, (int16_t *)0x7f00);
    }
    // 0x1001816
    int32_t v7; // 0x10017ed
    int32_t v8; // 0x10017ed
    int32_t v9 = v8 & -256 | (int32_t)__asm_in_3((int16_t)v7); // 0x1001817
    uint32_t v10 = v7 + (int32_t)(v5 < v4) - *(int32_t *)0x1001124; // 0x1001818
    *(int32_t *)(v10 - 16) = v9;
    int32_t v11 = v2 + 36; // 0x1001821
    struct tagWNDCLASSEXW * lpwcx = (struct tagWNDCLASSEXW *)(v9 & 0xffff); // 0x1001824
    int32_t v12; // 0x10017ed
    *(int32_t *)(v12 - 11) = 0x90006a;
    *(int32_t *)(v12 - 23) = (int32_t)L"SciCalc";
    int16_t v13 = RegisterClassExW(lpwcx); // 0x1001836
    int32_t v14 = v13 != 0 ? (int32_t)v13 : 0;
    int32_t * v15 = (int32_t *)(v12 + 1); // 0x1001849
    int32_t v16 = *v15; // 0x1001849
    char * v17 = (char *)(2 * v14); // 0x100184a
    *v17 = *v17 + 1;
    *v15 = v11;
    *(char *)(0x10000 * v9 / 0x10000 + 0x14dc068) = (char)v14;
    int32_t v18; // 0x10017ed
    *(int32_t *)v18 = lpwcx->e0;
    int32_t * v19 = (int32_t *)(2 * (v14 + v16)); // 0x1001857
    *v19 = *v19 | v16;
    int32_t v20 = v12 - 3; // 0x100185a
    int32_t * v21 = (int32_t *)v20; // 0x100185a
    *v21 = g35;
    g120 = 1;
    int32_t * v22 = (int32_t *)(v10 + 99); // 0x100186a
    *v22 = *v22 ^ v20;
    char * v23 = (char *)v11; // 0x100186e
    *v23 = *v23 + (char)(v10 / 256);
    float80_t v24; // 0x10017ed
    *(int32_t *)(v2 + 0x14dc4ee) = (int32_t)v24;
    uint32_t result = *v21 + v16; // 0x1001876
    bool v25; // 0x10017ed
    *(char *)((v25 ? -4 : 4) + v18) = (char)result;
    __asm_arpl(*(int16_t *)result, (int16_t)result);
    char * v26 = (char *)(v2 + 0x30e34db4); // 0x100187b
    *v26 = *v26 + (char)(result / 256);
    *v21 = *(int32_t *)result;
    return result;
}

// Address range: 0x1001884 - 0x1001924
int32_t function_1001884(void) {
    // 0x1001884
    int32_t v1; // 0x1001884
    int32_t v2; // 0x1001884
    *(int32_t *)v1 = v2 + v1;
    int32_t v3; // 0x1001884
    int32_t * v4 = (int32_t *)(v3 + 0x470b800); // 0x1001893
    *v4 = *v4 + v1;
    unknown_f0b07bfb();
    int32_t v5 = *(int32_t *)0x1b74d90; // 0x100189e
    int32_t v6 = __asm_int3(); // 0x10018a4
    int32_t * v7 = (int32_t *)(v5 + 0x1019584); // 0x10018a5
    int32_t v8; // 0x1001884
    *v7 = *v7 + v8;
    int32_t v9 = v6 + 161; // 0x10018af
    int32_t v10 = v9 & 255 | v6 & -256; // 0x10018af
    int32_t * v11 = (int32_t *)v5; // 0x10018b3
    *v11 = *v11 + v10;
    char * v12 = (char *)v10; // 0x10018bb
    *v12 = *v12 + (char)v9;
    char * v13 = (char *)(*(int32_t *)(v3 + 0xcb8178d) + 0x2e9c195); // 0x10018bd
    *v13 = *v13 + (char)v5;
    int32_t v14; // 0x1001884
    int32_t v15; // 0x1001884
    __asm_rep_movsd_memcpy((char *)v14, (char *)(v15 - 1), v5);
    abort();
    // UNREACHABLE
}

// Address range: 0x1001924 - 0x100192b
int32_t function_1001924(void) {
    // 0x1001924
    return function_e89b014d();
}

// Address range: 0x1001951 - 0x10019d9
int32_t function_1001951(void) {
    // 0x1001951
    int32_t v1; // 0x1001951
    int32_t v2 = (v1 & 0xff00) + v1 & 0xff00 | v1 & -0xff01; // 0x1001951
    __asm_sti();
    int32_t v3 = *(int32_t *)-0x74ffff9e | -0x79feb268; // 0x100195b
    int32_t v4; // 0x1001951
    *(int32_t *)v4 = v3 + v4;
    int32_t v5 = *(int32_t *)v3; // 0x1001971
    int32_t v6 = v5 + 2 * v2; // 0x1001973
    char * v7 = (char *)v3; // 0x1001978
    *v7 = *v7 + (char)v3;
    int32_t v8; // 0x1001951
    int128_t v9; // 0x1001951
    __asm_vpsubsw(v9, *(int128_t *)&v8);
    __asm_rep_movsd_memcpy((char *)v5, (char *)*(int32_t *)v3, v6);
    bool v10; // 0x1001951
    char * v11 = (char *)(v6 * (v10 ? -4 : 4) + v5); // 0x1001986
    __asm_rep_movsb_memcpy(v11, v11, 0);
    *(int32_t *)-0x675efbb6 = *(int32_t *)0xa4c803;
    unknown_ae00b2c1();
    *(int32_t *)(*(int32_t *)0x72014d98 + 4) = v2;
    int32_t v12 = *(int32_t *)(*(int32_t *)0x12ec984 + 4); // 0x10019a2
    *(int32_t *)-0x675efbba = *(int32_t *)(v12 + 4);
    int32_t v13 = function_1007c38((int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125); // 0x10019a8
    int32_t v14 = *(int32_t *)-0x4610b268; // 0x10019ad
    *(int32_t *)(v14 + 4) = v13;
    int32_t v15; // 0x1001951
    *(int32_t *)-0x675efbbe = v15 - 1;
    int32_t * v16 = (int32_t *)(v2 + 0x4ec12c70); // 0x10019ba
    *v16 = *v16 + v14;
    int32_t * v17 = (int32_t *)v14; // 0x10019c4
    *v17 = *v17 + 0x10000 * (v13 + 161 & 255 | v13 & 0xff00) / 0x10000;
    return function_a5f302e9();
}

// Address range: 0x10019d9 - 0x1001a17
int32_t function_10019d9(int32_t a1, int32_t a2) {
    // 0x10019d9
    int32_t v1; // 0x10019d9
    int32_t v2 = v1 & 3; // 0x10019d9
    int32_t v3; // 0x10019d9
    int32_t v4; // 0x10019d9
    __asm_rep_movsb_memcpy((char *)v3, (char *)v4, v2);
    int32_t v5; // 0x10019d9
    *(int32_t *)51 = *(int32_t *)51 - v5;
    bool v6; // 0x10019d9
    char * v7 = (char *)(v3 + 1 + (v6 ? -1 : 1) * v2); // 0x10019ea
    int32_t v8; // 0x10019d9
    __asm_rep_stosd_memset(v7, v8, 0);
    int32_t v9 = 4; // 0x10019ed
    char v10 = *(char *)(((int32_t)&v9 | 1) + 2 * a1); // 0x10019ef
    int32_t v11; // 0x10019d9
    __asm_out_2((int16_t)(v11 & 0xff00 | (int32_t)(v10 & (char)v11)), v8);
    __asm_rep_stosd_memset(v7, v8, a1);
    LocalAlloc((int32_t)&g125, (int32_t)&g125);
    abort();
    // UNREACHABLE
}

// Address range: 0x1001a38 - 0x1001a3e
int32_t function_1001a38(void) {
    // 0x1001a38
    int32_t result; // 0x1001a38
    return result;
}

// Address range: 0x1001b4d - 0x1001b50
int32_t function_1001b4d(void) {
    // 0x1001b4d
    int32_t result; // 0x1001b4d
    return result;
}

// Address range: 0x1001bcc - 0x1001bcd
int32_t function_1001bcc(void) {
    // 0x1001bcc
    int32_t result; // 0x1001bcc
    return result;
}

// Address range: 0x1001c2b - 0x1001d33
int32_t function_1001c2b(char a1) {
    // 0x1001c2b
    int32_t hWnd; // 0x1001c2b
    int32_t v1; // 0x1001c2b
    int32_t * v2 = (int32_t *)(hWnd + 1 + 2 * v1); // 0x1001c2b
    *v2 = *v2 ^ hWnd;
    int32_t v3; // 0x1001c2b
    uint32_t v4 = (v3 & -256) + v3;
    int32_t v5 = v4 & 0xff00 | v3 & -0xff01; // 0x1001c2f
    char * v6 = (char *)(v5 + 123); // 0x1001c38
    char v7 = v4 / 256; // 0x1001c38
    *v6 = *v6 | v7;
    int32_t v8; // 0x1001c2b
    uint32_t v9; // 0x1001c2b
    char * v10 = (char *)(v8 + 25 + 2 * v9); // 0x1001c3b
    char v11 = *v10 + (char)v3; // 0x1001c3b
    *v10 = v11;
    int32_t v12; // bp-389, 0x1001c2b
    int32_t v13 = &v12; // 0x1001c3f
    if (v11 == 0) {
        // 0x1001c41
        char * v14; // bp-393, 0x1001c2b
        *(int32_t *)&v14 = (int32_t)g46;
        v13 = (int32_t)&v14;
    }
    bool v15 = EnableWindow((int32_t *)hWnd, (bool)&g125); // 0x1001c4a
    int32_t * v16 = (int32_t *)(v5 + 8); // 0x1001c53
    int32_t v17 = *v16 | 38; // 0x1001c53
    *v16 = v17;
    int16_t v18; // 0x1001c2b
    int32_t v19; // 0x1001c2b
    bool v20; // 0x1001c2b
    if (v17 < 0) {
        int32_t v21 = v15; // 0x1001c4a
        uint32_t v22 = *(int32_t *)(v21 - 1); // 0x1001cc8
        int32_t v23 = v21 + 0x1001898 + (int32_t)(v9 < v22); // 0x1001ccb
        int16_t v24 = v9 - v22;
        v18 = v24;
        v19 = v13 - 4;
        if (v23 != 0) {
            // 0x1001cd2
            int32_t v25; // 0x1001c2b
            int32_t result = (v23 & -256 | (int32_t)__asm_in_3(v24)) - v25; // 0x1001cd3
            *(int32_t *)(v13 - 8) = 20;
            *(int32_t *)(v13 - 12) = result;
            return result;
        }
    } else {
        // 0x1001c59
        int32_t v26; // bp-3, 0x1001c2b
        int32_t v27 = &v26; // 0x1001c37
        int32_t * v28 = (int32_t *)(v1 - 0xfefeb4 + 2 * v27); // 0x1001c59
        *v28 = *v28 - 1;
        *(int32_t *)(v13 - 8) = 84;
        int32_t v29; // 0x1001c2b
        uint32_t result2 = function_1006626(v29 + 1); // 0x1001c67
        int32_t * v30 = (int32_t *)(v1 + 63 + result2); // 0x1001c6c
        *v30 = *v30 | 1;
        int16_t v31 = v9;
        int32_t v32; // 0x1001c2b
        __asm_outsd(v31, v32);
        char v33 = result2 / 256 & v9; // 0x1001c72
        char v34 = llvm_ctpop_i8(v33); // 0x1001c72
        *(char *)v9 = v33;
        if ((v34 & 1) != 0) {
            if (v1 != 2 && v33 != 0) {
                // 0x1001d30
                return result2;
            }
            // 0x1001ce0
            *(int32_t *)(v13 - 24) = (int32_t)a1;
            int32_t v35 = unknown_111691e(); // 0x1001cea
            int32_t * v36 = (int32_t *)(v35 - 109); // 0x1001cef
            *v36 = *v36 + v27;
            int32_t * v37 = (int32_t *)v35; // 0x1001cf2
            *v37 = *v37 + v35;
            int32_t v38 = v35 ^ (int32_t)&g46; // 0x1001cf6
            *(int32_t *)(v13 - 28) = -4;
            *(char *)v8 = *(char *)v38;
            int32_t v39 = v20 ? -1 : 1; // 0x1001d05
            int32_t v40 = v39 + v8; // 0x1001d05
            int32_t v41 = unknown_3a00031d(); // 0x1001d06
            *(int32_t *)"alSize" = v41;
            int32_t result3 = v40; // 0x1001d13
            if (v41 != v40) {
                // 0x1001d15
                *(int32_t *)(v13 - 32) = 0x100652a;
                *(int32_t *)(v13 - 36) = 54;
                *(int32_t *)(v13 - 40) = v38 + v39;
                result3 = unknown_c4c7a877();
            }
            // 0x1001d23
            return result3;
        }
        // 0x1001c76
        __asm_out_4(147, result2);
        char * v42 = (char *)result2; // 0x1001c78
        unsigned char v43 = *v42; // 0x1001c78
        unsigned char v44 = v43 + (char)result2; // 0x1001c78
        *v42 = v44;
        int32_t v45; // bp-35, 0x1001c2b
        *(int32_t *)(v13 - 12) = (int32_t)&v45;
        *(int32_t *)(v13 - 16) = (v44 < v43 ? 255 : 0) | result2 & -256;
        int32_t v46; // bp-67, 0x1001c2b
        *(int32_t *)(v13 - 20) = (int32_t)&v46;
        int32_t v47 = v13 - 24; // 0x1001c90
        *(int32_t *)v47 = (int32_t)g46;
        v18 = v31;
        v19 = v47;
    }
    // 0x1001c9c
    *(int32_t *)(v19 - 4) = 2;
    int32_t v48 = (v20 ? -1 : 1) + v8; // 0x1001ca1
    int32_t v49 = v19 - 8; // 0x1001ca2
    *(int32_t *)v49 = v48;
    *(int32_t *)v48 = __asm_insd(v18);
    int32_t v50; // bp+53, 0x1001c2b
    int32_t v51 = (int32_t)&v50 ^ (int32_t)&g118; // 0x1001ca4
    int32_t result4 = v19 - 12; // 0x1001ca9
    *(int32_t *)result4 = v49;
    char * v52 = (char *)(v48 - 125); // 0x1001cad
    *v52 = *v52 + v7;
    int32_t v53; // bp-5, 0x1001c2b
    *(int32_t *)(v51 - 4) = (int32_t)&v53;
    int32_t * v54 = (int32_t *)(v51 + 0x50d8d24d); // 0x1001cc0
    *v54 = -*v54;
    return result4;
}

// Address range: 0x1001d34 - 0x1001df7
int32_t function_1001d34(void) {
    // 0x1001d34
    int32_t v1; // 0x1001d34
    char * v2 = (char *)(v1 + 0x130be92); // 0x1001d4e
    char v3 = *v2; // 0x1001d4e
    *v2 = 2 * v3 | 1 * (char)((int32_t)&g117 < 0x3af38c48);
    int32_t v4 = v3 < 0 ? -1 - (int32_t)&g117 : -(int32_t)&g117; // 0x1001d54
    g117 = v4;
    int32_t v5 = __asm_insd((int16_t)((int32_t)&g117 >> 31)); // 0x1001d76
    int32_t v6; // 0x1001d34
    *(int32_t *)v6 = v5;
    int32_t v7 = *(int32_t *)0x36016a80; // bp-28, 0x1001d79
    char * v8 = (char *)(v1 - 123);
    int32_t v9 = &v7; // 0x1001d7f
    while (g49 == v6) {
        int32_t v10 = v9;
        *(int32_t *)0x6e014478 = -1;
        *(int32_t *)(v10 - 4) = 118;
        int32_t v11 = function_100b05b((int32_t)&g125); // 0x1001dcd
        *(int32_t *)(v10 - 8) = *(int32_t *)0x76804d94;
        v9 = v10 - 16;
        char v12 = *v8; // 0x1001ddb
        int32_t v13; // 0x1001d34
        char v14 = v13; // 0x1001ddb
        char v15 = v12 + v14; // 0x1001ddb
        *v8 = v15;
        if (((v15 ^ v12) & (v15 ^ v14)) < 0) {
            int32_t v16 = v11 & -0xff01 | 0x8600; // 0x1001dda
            int32_t v17 = *(int32_t *)&v13;
            int32_t v18 = v17 + v16; // 0x1001de1
            *(int32_t *)v17 = v18;
            int32_t result = v18 != 0 ? v16 : (int32_t)&g1;
            *(int32_t *)(v10 - 20) = result;
            *(int32_t *)(v10 - 24) = 401;
            *(int32_t *)(v10 - 28) = (int32_t)g46;
            return result;
        }
    }
    // 0x1001d8e
    return g49;
}

// Address range: 0x1001df8 - 0x1001e2d
int32_t function_1001df8(void) {
    // 0x1001df8
    int32_t v1; // 0x1001df8
    char * v2 = (char *)(v1 + 0x68036a57); // 0x1001dfb
    int32_t v3; // 0x1001df8
    *v2 = *v2 + (char)v3;
    int32_t v4; // 0x1001df8
    int32_t v5 = v4;
    *(char *)v5 = *(char *)&v4 + (char)v5;
    return function_1001e40((int32_t)g46);
}

// Address range: 0x1001e2d - 0x1001e40
int32_t function_1001e2d(void) {
    // 0x1001e2d
    int32_t v1; // 0x1001e2d
    int32_t v2; // 0x1001e2d
    int32_t v3; // 0x1001e2d
    if (*(int32_t *)(v3 - 4) == v2) {
        v1 = function_1001e40((int32_t)&g125);
    }
    // 0x1001e32
    __asm_bound(*(int64_t *)(v2 - 115));
    return v1 ^ (int32_t)&g46;
}

// Address range: 0x1001e40 - 0x1001e47
int32_t function_1001e40(int32_t a1) {
    // 0x1001e40
    int32_t result; // 0x1001e40
    return result;
}

// Address range: 0x1001ec3 - 0x1001f30
int32_t function_1001ec3(void) {
    // 0x1001ec3
    int32_t v1; // 0x1001ec3
    int32_t v2 = v1 + 232; // 0x1001ec3
    int32_t v3 = v2 & 255 | v1 & -256; // 0x1001ec3
    int32_t v4; // 0x1001ec3
    int32_t v5; // 0x1001ec3
    int32_t v6 = v5 ^ v4 & 255; // 0x1001ec5
    char * v7 = (char *)(v6 + 0x14d940d); // 0x1001ec8
    int32_t v8; // 0x1001ec3
    *v7 = *v7 + (char)v8;
    int32_t * v9 = (int32_t *)(v8 + 0x4f84a1ea); // 0x1001ece
    *v9 = *v9 + v8;
    int32_t v10; // 0x1001ec3
    int64_t v11 = (int64_t)*(int32_t *)(v10 - 0x6b89fbb2); // 0x1001ed7
    int64_t v12 = 77 * v11; // 0x1001ed7
    int32_t v13 = v12; // 0x1001ed7
    int32_t v14; // 0x1001ec3
    *(int32_t *)v14 = v3;
    int32_t * v15 = (int32_t *)(v6 - 0x72f372c8); // 0x1001edf
    *v15 = *v15 - v13 + (int32_t)(v12 != 0x4d00000000 * v11 / 0x100000000);
    char * v16 = (char *)v3; // 0x1001ee7
    *v16 = *v16 + (char)v2;
    int32_t v17; // 0x1001ec3
    bool v18; // 0x1001ec3
    __asm_rep_movsb_memcpy((char *)((v18 ? -4 : 4) + v14), (char *)v17, v13);
    abort();
    // UNREACHABLE
}

// Address range: 0x1001f31 - 0x1001f51
int32_t function_1001f31(void) {
    int32_t v1 = *(int32_t *)(*(int32_t *)-0x6126b26c + 4); // 0x1001f36
    int32_t v2; // 0x1001f31
    uint32_t result = 4 * v2 + 0x230c; // 0x1001f39
    uint32_t v3 = result / 4; // 0x1001f42
    int32_t v4; // 0x1001f31
    __asm_rep_movsd_memcpy((char *)v1, (char *)v4, v3);
    bool v5; // 0x1001f31
    int32_t * v6 = (int32_t *)(v1 + 0x5fa4f3cb + v3 * (v5 ? -4 : 4)); // 0x1001f49
    *v6 = *v6 - 94;
    return result;
}

// Address range: 0x1001f67 - 0x10020f5
int32_t function_1001f67(int32_t a1) {
    // 0x1001f67
    int32_t v1; // 0x1001f67
    float80_t v2; // 0x1001f67
    *(int32_t *)v1 = (int32_t)v2;
    bool v3; // 0x1001f67
    int32_t v4 = v3 ? -4 : 4; // 0x1001f7e
    int32_t v5 = 49; // 0x1001f6f
    int32_t result = 0; // 0x1001f6f
    int32_t v6; // bp-32, 0x1001f67
    int32_t v7 = &v6; // 0x1001f6f
    while (true) {
        // 0x1001f75
        int32_t v8; // 0x1001f67
        uint32_t v9 = v8;
        int32_t v10; // 0x1001f67
        int32_t v11 = v10;
        int32_t v12 = v7;
        int32_t v13 = *(int32_t *)(v11 - 0xd0fa); // 0x1001f75
        int32_t v14 = v13 + v9; // 0x1001f75
        char v15 = llvm_ctpop_i8((char)v14); // 0x1001f75
        *(int32_t *)v14 = result & -0xff01 | 256 * (64 * (int32_t)(v14 == 0) | (int32_t)(v14 < v9) | 128 * (int32_t)(v14 < 0) | 16 * (int32_t)((v13 & 15) + (v9 & 15) > 15) | 4 * (int32_t)((v15 & 1) == 0)) | 512;
        int32_t v16 = v14 + v4; // 0x1001f7e
        int32_t v17 = v12 - 4; // 0x1001f82
        *(int32_t *)v17 = v11 - 104;
        int32_t v18 = GetProcessDefaultLayout(&g125); // 0x1001f83
        char v19; // 0x1001f67
        int32_t v20; // 0x1001f67
        int32_t v21; // 0x1001f67
        int32_t v22; // 0x1001f67
        int32_t v23; // 0x1001f67
        if (v5 == *(int32_t *)(v23 + 0x1a8e845)) {
            // 0x1001f75
            v19 = v18 / 256;
            v5 = 0;
            v20 = v18;
            v22 = v17;
            v21 = v11;
        } else {
            // 0x1001f94
            g59 = 0x8e01;
            *(int32_t *)(v12 - 8) = *(int32_t *)(v11 + 16);
            int32_t v24 = *(int32_t *)(v11 + 12); // 0x1001fb3
            *(int32_t *)(v12 - 12) = v24;
            int32_t v25 = function_10017ec(); // 0x1001fbb
            if (v25 == 0) {
                // break -> 0x10020a8
                break;
            }
            int32_t v26 = v11 - 1 + *(int32_t *)(v11 + 8); // 0x1001fb9
            char * v27 = (char *)(v16 + 0x406a0000); // 0x1001fc9
            *v27 = *v27 + (char)((v18 + 0xffff) / 256);
            v19 = -1;
            v5 = v24;
            v20 = v25;
            v22 = v26 + 4;
            v21 = *(int32_t *)v26;
        }
        int32_t v28 = v21;
        v7 = v22;
        result = v20;
        char * v29 = (char *)(v28 + 95); // 0x1001fdc
        unsigned char v30 = *v29 + v19 + (char)((result & 256) != 0); // 0x1001fdc
        *v29 = v30;
        *(int32_t *)v16 = result;
        v10 = v28 + 1;
        v8 = v16 + v4;
        if (v30 >= 1) {
            // 0x1001fe4
            if (*(int32_t *)(v28 + 13) <= 63) {
                // 0x1001ff8
                *(int32_t *)(v28 - 19) = *(int32_t *)0x9210;
                return result;
            }
            // 0x1002049
            *(int32_t *)(v7 - 4) = 2;
            int32_t result2 = 2 * v23; // 0x100204b
            *(int32_t *)(v7 - 8) = result2;
            *(int32_t *)(v7 - 12) = *(int32_t *)(v28 + 3);
            return result2;
        }
    }
    // 0x10020a8
    return function_1f321f2();
}

// Address range: 0x10020fc - 0x1002149
int32_t function_10020fc(void) {
    // 0x10020fc
    int32_t v1; // 0x10020fc
    int32_t * v2 = (int32_t *)(v1 + 0x109435); // 0x10020fc
    *v2 = *v2 - 1;
    int32_t v3; // 0x10020fc
    int32_t * v4 = (int32_t *)(v3 + 1); // 0x1002102
    int32_t v5; // 0x10020fc
    *v4 = *v4 + v5;
    float80_t v6; // 0x10020fc
    *(int32_t *)(v1 + 104) = (int32_t)v6;
    __asm_int1();
    int32_t v7 = 87; // bp-12, 0x1002119
    int32_t * v8 = (int32_t *)(v1 + (int32_t)&g40); // 0x1002123
    *v8 = *v8 + (int32_t)&v7;
    int32_t v9 = unknown_fbbf46(v7); // 0x1002129
    *(char *)0x10011a0 = (char)v9;
    g8 = v9;
    g30 = v9 ^ 0x100059c;
    return function_10021a7();
}

// Address range: 0x1002149 - 0x10021a7
int32_t function_1002149(void) {
    char v1 = g47; // 0x1002149
    int32_t v2; // 0x1002149
    int32_t v3; // 0x1002149
    __asm_outsd((int16_t)v3, v2);
    bool v4; // 0x1002149
    if (v4) {
        // 0x1002161
        unknown_2e36ed2();
        int32_t v5; // 0x1002149
        *(int32_t *)v5 = __asm_int3() + v5;
        int32_t v6; // 0x1002149
        int32_t v7; // 0x1002149
        if ((v7 & v6) != 0) {
            function_10021a7();
        }
        // 0x1002193
        return v6 - 52;
    }
    // 0x1002152
    bool v8; // 0x1002149
    bool v9 = v8 | (v1 & 14) > 9; // 0x100214f
    char v10 = v9 ? v1 + 10 : v1; // 0x100214f
    int32_t result = 0x10000 * (256 * (int32_t)((v1 >> 7) + (char)v9) | (int32_t)(v10 & 15)) / 0x10000; // 0x1002159
    int32_t * v11 = (int32_t *)result; // 0x100215a
    *v11 = result + (int32_t)v9 + *v11;
    return result;
}

// Address range: 0x10021a7 - 0x1002204
int32_t function_10021a7(void) {
    // 0x10021a7
    int32_t v1; // 0x10021a7
    bool v2; // 0x10021a7
    int32_t result = (v2 ? 255 : 0) | v1 & -256; // 0x10021af
    if (result != 0) {
        // 0x100220a
        return result;
    }
    // 0x10021b4
    int32_t v3; // 0x10021a7
    int32_t v4 = *(int32_t *)(v3 + 8); // 0x10021b4
    int32_t v5; // 0x10021a7
    unknown_632677d3(v4, v5, v5);
    int32_t * v6 = (int32_t *)(v3 - 12); // 0x10021c0
    *(int32_t *)v3 = v4;
    char v7 = v5; // 0x10021cf
    int32_t v8; // 0x10021a7
    *(char *)v5 = *(char *)&v8 + v7;
    if (*(char *)v4 != v7) {
        // 0x10021d5
        bool v9; // 0x10021a7
        int32_t v10 = v4 + (v9 ? -1 : 1); // 0x10021d2
        *(int32_t *)(v3 - 8) = v10;
        *v6 = 0x14e1319;
        int32_t v11 = v5 + 23 & 53 | 202; // 0x10021e2
        int32_t v12 = v11 | v5 & -256; // 0x10021e2
        *(int32_t *)*v6 = 0x70001;
        char * v13 = (char *)v12; // 0x10021ed
        *v13 = *v13 + (char)v11;
        int32_t * v14 = (int32_t *)(v10 - 1); // 0x10021ef
        uint32_t v15; // 0x10021a7
        *v14 = *v14 + v15;
        char * v16 = (char *)(v15 + 13 + v12); // 0x10021f2
        *v16 = *v16 + (char)(v15 / 256);
        int32_t * v17 = (int32_t *)(v10 - 72); // 0x10021f6
        *v17 = *v17 + (v8 | v15 & 255);
    }
    // 0x10021f9
    return function_924968f();
}

// Address range: 0x100220c - 0x1002226
int32_t function_100220c(void) {
    // 0x100220c
    int32_t v1; // 0x100220c
    int32_t * v2 = (int32_t *)(v1 + 0x9886); // 0x100220c
    *v2 = *v2 - 1;
    int32_t v3; // 0x100220c
    char * v4 = (char *)(v3 - 24); // 0x1002212
    unsigned char v5 = *v4; // 0x1002212
    int32_t v6; // 0x100220c
    unsigned char v7 = v5 + (char)v6; // 0x1002212
    *v4 = v7;
    int32_t v8; // 0x100220c
    *(int32_t *)(v8 + 4) = -1;
    return v7 < v5 ? -0x7c00ca01 : -0x7c00cb00;
}

// Address range: 0x1002226 - 0x10022f9
int32_t function_1002226(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, uint32_t a6, int32_t a7) {
    // 0x1002226
    int32_t v1; // 0x1002226
    __asm_in_3((int16_t)v1);
    int32_t v2; // 0x1002226
    int32_t v3 = __asm_bound(*(int64_t *)(v2 + 12)); // 0x1002227
    bool v4; // 0x1002226
    if (!v4) {
        // 0x100222c
        int32_t v5; // 0x1002226
        char * v6 = (char *)(v5 + 86); // 0x100222c
        *v6 = *v6 + (char)v1;
        *(int16_t *)(8 * v5 + 20) = 0;
        bool v7 = false; // 0x100223b
        int32_t result = v3; // 0x100223b
        int32_t v8; // bp-4, 0x1002226
        int32_t * v9 = &v8; // 0x100223b
        if (*(int32_t *)v3 != 0) {
            // 0x100223d
            result = v3 + 0xe0a090;
            __asm_int(141);
            *(char *)0x26000000 = 0;
            *(int32_t *)result = result;
            int32_t v10 = 0; // bp-8, 0x100224c
            v7 = (result & (v3 ^ -0x80000000)) < 0;
            v9 = &v10;
        }
        int32_t v11 = (int32_t)v9;
        *(int32_t *)(v11 - 4) = 0;
        *(int32_t *)(v11 - 8) = *(int32_t *)(result + 156);
        *(int32_t *)(v11 - 12) = result + 20;
        if (v7) {
            // 0x10022ca
            return result;
        }
        // 0x100225a
        return result | 232;
    }
    char * v12 = (char *)a7; // 0x100227d
    char v13 = *v12; // 0x100227d
    char v14 = a7; // 0x100227d
    char v15 = v13 + v14; // 0x100227d
    *v12 = v15;
    *(int32_t *)*(int32_t *)a4 = a1;
    int32_t * v16 = (int32_t *)a2; // 0x1002283
    int32_t result2 = *v16; // 0x1002283
    if (((v15 ^ v13) & (v15 ^ v14)) >= 0) {
        // 0x1002288
        __asm_outsb((int16_t)a5, *(char *)a2);
        return result2;
    }
    char * v17 = (char *)(a4 - 119 + a6); // 0x100228c
    char v18 = a6; // 0x100228c
    *v17 = *v17 + v18;
    int32_t * v19 = (int32_t *)(a4 + 0x44e8bd3); // 0x1002290
    *v19 = *v19 + a6;
    unsigned char v20 = v18 & 31; // 0x1002296
    if (v20 != 0) {
        char * v21 = (char *)a4; // 0x1002296
        unsigned char v22 = *v21; // 0x1002296
        *v21 = v22 >> 8 - v20 | v22 << v20;
    }
    int32_t v23 = *(int32_t *)result2; // 0x1002298
    int32_t result3 = result2 | 141; // 0x100229d
    *(char *)-0x163e3eeb = *(char *)-0x163e3eeb + (char)(a6 / 256);
    *(int32_t *)v23 = *v16;
    bool v24; // 0x1002226
    int32_t v25 = v24 ? -4 : 4; // 0x10022a7
    int32_t v26 = v23 + v25; // 0x10022a7
    int32_t v27 = a6 - 1; // 0x10022ab
    if (v27 != 0 != ((*(int32_t *)(v26 - 125) & result3) == 0)) {
        // 0x10022ad
        __asm_rep_movsb_memcpy((char *)v26, (char *)(v25 + a2), v27);
        return result3;
    }
    if ((2 * v26 ^ v26) >= 0) {
        char * v28 = (char *)(a6 + 101); // 0x10022b5
        *v28 = *v28 | (char)a4 - 1;
    }
    char * v29 = (char *)(a4 + 0x4608302); // 0x10022b8
    *v29 = *v29 + (char)v27;
    return ((result2 & 114 ^ 6) + 127 & 119 | result2 & -256) ^ -0x74e38b00;
}

// Address range: 0x1002326 - 0x100232d
int32_t function_1002326(void) {
    // 0x1002326
    int32_t v1; // 0x1002326
    return v1 | 119;
}

// Address range: 0x100232f - 0x1002330
int32_t function_100232f(void) {
    // 0x100232f
    int32_t result; // 0x100232f
    return result;
}

// Address range: 0x100233e - 0x100234a
int32_t function_100233e(void) {
    // 0x100233e
    int32_t v1; // 0x100233e
    int32_t v2; // 0x100233e
    return v2 - 0x580108 + 2 * v1;
}

// Address range: 0x1002354 - 0x10023aa
int32_t function_1002354(int16_t a1, int32_t a2) {
    // 0x1002354
    int32_t v1; // 0x1002354
    int32_t * v2 = (int32_t *)(v1 - 96); // 0x1002356
    uint32_t v3 = *v2; // 0x1002356
    int32_t v4; // 0x1002354
    uint32_t v5 = v3 + v4; // 0x1002356
    *v2 = v5;
    int32_t v6; // 0x1002354
    int32_t v7 = v6 + 2 * v1;
    int32_t v8 = *(int32_t *)(v7 - 359); // 0x1002359
    int32_t v9; // 0x1002354
    int32_t v10 = (v9 + 192 & 255 | v9 & -256) - v8 + (int32_t)(v5 < v3); // 0x1002359
    if (v10 == *(int32_t *)v10) {
        function_100232f();
    }
    // 0x1002366
    int32_t v11; // 0x1002354
    int32_t v12 = __asm_in_5((int16_t)v11); // 0x1002370
    *(int16_t *)(v7 - 0x4ca1) = (int16_t)v12 + 95;
    if (*(int32_t *)(v12 - 0x5bfffedf) == 0) {
        // 0x1002394
        *(int16_t *)(v7 + 0x42fffefc) = 43;
        int32_t v13; // 0x1002354
        return v13 + 0x480000a4;
    }
    // 0x1002388
    *(int16_t *)(v7 - 0xfd0104) = 45;
    int32_t result = function_10023e7((int32_t)&g125, (int32_t)&g125, (int32_t)&g125); // 0x1002392
    return result;
}

// Address range: 0x10023ab - 0x10023e7
int32_t function_10023ab(void) {
    // 0x10023ab
    int32_t v1; // 0x10023ab
    int32_t v2; // 0x10023ab
    int32_t result = 2 * unknown_890b8bff(v1 - 0x7586017d, 0, v2) + 2 ^ 10; // 0x10023c8
    uint32_t v3; // 0x10023ab
    if (result != 0) {
        char * v4 = (char *)(v1 + 1); // 0x10023e4
        *v4 = *v4 + (char)(v3 / 256);
        return result;
    }
    // 0x10023d8
    *(char *)0x7a855d8b = *(char *)0x7a855d8b - (char)v3;
    int32_t v5; // 0x10023ab
    *(int32_t *)(v5 - 4) = result;
    return result;
}

// Address range: 0x10023e7 - 0x100245f
int32_t function_10023e7(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10023e7
    int32_t v1; // 0x10023e7
    char * v2 = (char *)(v1 + 0x6811a45); // 0x10023e9
    int32_t v3; // 0x10023e7
    *v2 = *v2 + (char)v3;
    int32_t v4; // 0x10023e7
    if (*(int32_t *)(v4 + 91) != -93) {
        int32_t result = *(int32_t *)(v1 + 0x7f87da4); // 0x1002407
        int32_t * v5 = (int32_t *)result; // 0x100240e
        *v5 = *v5 - result;
        return result;
    }
    // 0x1002429
    int32_t v6; // 0x10023e7
    bool v7; // 0x10023e7
    char * v8 = (char *)(v6 - (256 * (int32_t)v7 + v1 & 0xff00) & 0xff00 | v6 & -0xff01); // 0x1002429
    char v9 = *v8; // 0x1002429
    *v8 = v9 - 1;
    int32_t v10; // 0x10023e7
    int32_t result2; // 0x10023e7
    if (v10 == 0) {
        // 0x1002449
        int32_t v11; // 0x10023e7
        char * v12 = (char *)((v9 < 1 ? 48 : 55) + v11); // 0x100244b
        *v12 = *v12 | (char)v6;
        return result2;
    }
    int32_t * v13 = (int32_t *)(result2 + 0x74047541); // 0x1002452
    int32_t v14; // bp-4, 0x10023e7
    *v13 = *v13 + (int32_t)&v14;
    return 4 * (int32_t)*(char *)(result2 - 0x6d8e7435);
}

// Address range: 0x1002460 - 0x10024e6
int32_t function_1002460(void) {
    // 0x1002460
    int32_t v1; // 0x1002460
    int32_t v2; // 0x1002460
    int32_t v3; // 0x1002460
    int32_t v4; // 0x1002460
    int32_t v5; // 0x1002460
    bool v6; // 0x1002460
    uint32_t v7; // 0x1002460
    char * v8; // 0x10024a3
    int32_t v9; // 0x1002460
    uint32_t v10; // 0x1002460
    int32_t result; // 0x1002460
    bool v11; // 0x1002460
    if (v6 == v11) {
        char v12 = v10 / 256 | v9; // 0x10024b6
        *(char *)v9 = v12;
        char * v13 = (char *)(result + 14); // 0x10024b8
        unsigned char v14 = *v13; // 0x10024b8
        *v13 = v14 / 4 | 64 * v14;
        if (*(int32_t *)(result + 8) != 0) {
            // 0x10024c7
            return result;
        }
        // 0x10024d2
        int32_t v15; // 0x1002460
        int32_t v16; // 0x1002460
        int32_t v17 = v12 == 0 ? *(int32_t *)(8 * v15 + v5) : v16; // 0x10024bc
        int32_t v18 = result - 0x4bffff64; // 0x10024d8
        int32_t v19 = v17 - 4; // 0x10024e2
        *(int32_t *)v19 = 0;
        int32_t v20 = v17 - 8; // 0x10024e3
        *(int32_t *)v20 = v19;
        v4 = v20;
        v2 = *(int32_t *)(v7 - 0x748be0c7) ^ v15;
        v3 = 0;
        v1 = *(int32_t *)v18 == 0 ? v18 : v10;
    } else {
        if (v10 == 0) {
            // 0x10024ca
            return function_10024ef();
        }
        // 0x1002466
        int32_t v21; // 0x1002460
        int32_t v22 = __asm_bound(*(int64_t *)(v21 + 8)); // 0x1002466
        char * v23 = (char *)(v9 + 0x418b0017); // 0x1002469
        char v24 = result; // 0x1002469
        *v23 = *v23 + v24;
        char * v25 = (char *)(result - 119); // 0x100246f
        *v25 = *v25 | v24;
        int32_t v26 = v21 + 1; // 0x1002473
        int32_t v27 = result | 3; // 0x1002474
        *(int32_t *)v22 = v26;
        int32_t * v28 = (int32_t *)v27; // 0x100247c
        int32_t v29 = *v28 + v26; // 0x100247c
        *v28 = v29;
        v4 = v22;
        v3 = v26;
        v1 = v27;
        if (v29 != 0) {
            // 0x10024a0
            v8 = (char *)(v9 - 62);
            *v8 = *v8 ^ (char)v9;
            return 0;
        }
    }
    int32_t v30 = v1;
    *(int32_t *)v5 = v30;
    uint32_t v31 = v30 - (v7 < v30 ? 134 : 133) & 255 | v30 & -256; // 0x1002483
    int32_t * v32 = (int32_t *)(v4 - 4); // 0x1002485
    *v32 = *(int32_t *)(v2 + 24);
    int32_t * v33 = (int32_t *)(3 * v31); // 0x1002488
    *v33 = -1 - *v33;
    int32_t * v34 = (int32_t *)(v10 + 3); // 0x100248b
    *v34 = *v34 + v2;
    int64_t v35 = 0x100000000 * (int64_t)(v30 >> 31) | (int64_t)v31; // 0x1002491
    int64_t v36 = (int64_t)*v32; // 0x1002491
    int32_t v37 = (int32_t)(v35 % v36) - 1; // 0x1002493
    if (v37 == 0) {
        int32_t v38 = v3 + 12;
        if (*(int16_t *)v38 == 49) {
            // 0x10024af
            *(int16_t *)(v38 + 2 * v7) = (int16_t)v9;
            return v35 / v36;
        }
        // 0x10024a0
        v8 = (char *)(v9 - 62);
        *v8 = *v8 ^ (char)v9;
        return 0;
    }
    if (v37 != 1) {
        // 0x10024a0
        v8 = (char *)(v9 - 62);
        *v8 = *v8 ^ (char)v9;
        return 0;
    }
    int32_t v39 = v3 + 12;
    if (*(int16_t *)v39 < 52) {
        // 0x10024af
        *(int16_t *)(v39 + 2 * v7) = (int16_t)v9;
        return v35 / v36;
    }
    // 0x10024a0
    v8 = (char *)(v9 - 62);
    *v8 = *v8 ^ (char)v9;
    return 0;
}

// Address range: 0x10024e6 - 0x10024ef
int32_t function_10024e6(void) {
    // 0x10024e6
    int32_t result; // 0x10024e6
    return result;
}

// Address range: 0x10024ef - 0x10024f2
int32_t function_10024ef(void) {
    // 0x10024ef
    int32_t result; // 0x10024ef
    return result;
}

// Address range: 0x10024f2 - 0x1002528
int32_t function_10024f2(void) {
    // 0x10024f2
    int32_t v1; // 0x10024f2
    int32_t v2 = v1 & -252; // 0x10024f4
    int32_t v3 = v2 + 0x74613883 & -256; // 0x1002500
    int32_t v4 = v3 | v2 + 182 & 190; // 0x1002500
    int32_t v5 = *(int32_t *)(v4 + 16); // 0x1002505
    char * v6 = (char *)v5; // 0x100250a
    uint32_t v7; // 0x10024f2
    *v6 = *v6 | (char)(v7 / 256);
    int32_t v8; // 0x10024f2
    *(int32_t *)(v1 + 4) = (int32_t)&v8;
    *(int32_t *)(v4 - 78) = v5 + 1;
    int32_t v9 = *(int32_t *)(v4 + 4) & -0x10000 | v4 & 0xffbe; // 0x1002516
    int32_t v10 = v2 + 118 & 126 | v3; // 0x1002519
    int32_t * v11 = (int32_t *)v9; // 0x100251b
    *v11 = *v11 + v10;
    *(int16_t *)(v9 - 0x3fccebb8) = (int16_t)v1;
    return v10 | 1;
}

// Address range: 0x1002528 - 0x10025b0
int32_t function_1002528(int32_t a1) {
    // 0x1002528
    int32_t v1; // 0x1002528
    char v2 = v1;
    *(char *)v1 = v2 / 16;
    if (v2 < 16) {
        // 0x1002539
        int32_t v3; // 0x1002528
        *(int32_t *)a1 = v3 + 1;
    }
    int32_t v4 = *(int32_t *)(v1 + 4); // 0x1002540
    *(int32_t *)0x33ffcbff = *(int32_t *)0x33ffcbff | 116;
    uint16_t v5; // 0x1002528
    int32_t v6 = v4 + 256 * (int32_t)v5 & 0xff00 | v4 & -0xff01; // 0x100254e
    int32_t * v7 = (int32_t *)v6; // 0x1002550
    if (*v7 != v6) {
        // 0x100255f
        *v7 = 0;
    } else {
        int32_t * v8 = (int32_t *)(v6 - 0x7bffff60); // 0x1002554
        *v8 = *v8 - 1;
    }
    // 0x1002591
    int32_t v9; // 0x1002528
    int32_t v10 = v1 + -1 - *(int32_t *)(v9 + 0xfd88); // 0x1002594
    int32_t v11; // 0x1002528
    if (v10 == 0 || (*(char *)(v11 - 0x77cfb60) & (char)v10) == 0) {
        // 0x1002596
        return 1;
    }
    uint32_t v12 = v9 & -256 | (int32_t)__asm_in_1(-117); // 0x10025a3
    uint32_t result = v12 + (int32_t)&g6; // 0x10025a5
    int16_t * v13 = (int16_t *)a1; // 0x10025aa
    *v13 = *v13 + (int16_t)result + (int16_t)(result < v12);
    return result;
}

// Address range: 0x10025b1 - 0x1002604
int32_t function_10025b1(int32_t a1, int32_t a2) {
    // 0x10025b1
    int32_t v1; // 0x10025b1
    if (a2 == 0) {
        // 0x10025d8
        if (g62 == 0) {
            // 0x1002601
            return 0;
        }
        // 0x10025e1
        int32_t v2; // 0x10025b1
        *(char *)0x1001118 = (char)v2;
        v1 = 0;
    } else {
        // 0x10025b9
        if (g62 != 0) {
            // 0x1002601
            return 1;
        }
        // 0x10025c2
        int32_t v3; // 0x10025b1
        v1 = v3 + 0x1be1918;
    }
    // 0x10025ea
    *(int32_t *)-0x6feb114 = v1;
    // 0x1002601
    return 1;
}

// Address range: 0x1002646 - 0x1002647
int32_t function_1002646(int32_t a1) {
    // 0x1002646
    int32_t result; // 0x1002646
    return result;
}

// Address range: 0x100269d - 0x1002807
int32_t function_100269d(void) {
    // 0x100269d
    int32_t v1; // 0x100269d
    *(int32_t *)v1 = 2 * v1;
    int32_t v2; // 0x100269d
    char * v3 = (char *)(v2 / 0x10000000 + 43); // 0x10026a2
    uint32_t v4; // 0x100269d
    *v3 = *v3 + (char)(v4 / 256);
    int32_t v5; // 0x100269d
    int32_t * v6 = (int32_t *)(2 * v4 + v5); // 0x10026a5
    *v6 = *v6 ^ 116;
    return function_4590831c();
}

// Address range: 0x1002807 - 0x100280f
int32_t function_1002807(void) {
    // 0x1002807
    int32_t result; // 0x1002807
    *(char *)result = 0;
    return result;
}

// Address range: 0x100280f - 0x100283f
int32_t function_100280f(int16_t a1, int32_t a2) {
    // 0x100280f
    int32_t v1; // 0x100280f
    *(int32_t *)(v1 - 4) = -1;
    int32_t v2; // 0x100280f
    int32_t v3 = __asm_bound(*(int64_t *)(v1 + 0x7ebfd00 + v2)) - 12; // 0x100282a
    *(int32_t *)v3 = -0x1dffff74;
    int32_t v4; // 0x100280f
    *(int32_t *)v4 = v3 + v4;
    function_100660d((int32_t)&g125, (int32_t)&g125);
    return function_10122eb((int32_t)&g125);
}

// Address range: 0x100283f - 0x1002876
int32_t function_100283f(void) {
    // 0x100283f
    int32_t result; // 0x100283f
    bool v1; // 0x100283f
    if (v1) {
        result = function_ea002dab();
    }
    // 0x1002848
    int32_t v2; // 0x100283f
    int32_t * v3 = (int32_t *)(v2 - 0x18dd5ea1); // 0x1002848
    *v3 = *v3 | -49;
    int32_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    uint32_t v5 = *(int32_t *)-0x672eb278; // 0x1002851
    uint32_t v6; // 0x100283f
    if (v5 != v6) {
        // 0x1002859
        int32_t v7; // 0x100283f
        int32_t * v8 = (int32_t *)(v7 + 2 * v6); // 0x1002859
        *v8 = *v8 + (v5 < v6 ? 118 : 117);
        result = unknown_1d0660d();
        int32_t v9; // 0x100283f
        *(int32_t *)(v9 + 114) = 7;
    }
    // 0x1002875
    return result;
}

// Address range: 0x1002876 - 0x10028b1
int32_t function_1002876(void) {
    uint32_t v1 = unknown_840129c9(); // 0x1002876
    if (v1 <= 95) {
        // 0x1002884
        *(int32_t *)(v1 - 0x16fefeb3) = v1;
        char * v2 = (char *)v1; // 0x100288d
        *v2 = *v2 + (char)v1;
    }
    // 0x100288f
    int32_t v3; // 0x1002876
    int32_t v4; // 0x1002876
    int32_t * v5 = (int32_t *)(v3 + 0xf3b0003 + v4); // 0x1002895
    *v5 = *v5 | v1;
    int32_t result = v1 + 1; // 0x100289f
    int32_t v6; // 0x1002876
    *(int32_t *)v6 = result + v6;
    __asm_outsd((int16_t)v4 & 255 | 0x1500, v3);
    *(int32_t *)0x17b60f10 = *(int32_t *)0x17b60f10 - 1;
    return result;
}

// Address range: 0x10028b1 - 0x1002ad5
int32_t function_10028b1(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10028b1
    int32_t v1; // 0x10028b1
    int32_t v2 = v1 + 1; // 0x10028b2
    int32_t v3; // 0x10028b1
    *(int32_t *)v3 = v2 + v3;
    int32_t v4; // 0x10028b1
    int32_t v5 = v4 + 1; // 0x10028b5
    int32_t v6; // 0x10028b1
    int16_t v7 = v6; // 0x10028b8
    *(char *)v5 = __asm_insb(v7);
    __asm_out(v7, (char)v2);
    if (*(int32_t *)0x1012760 != v6) {
        // 0x10028c8
        int16_t v8; // 0x10028b1
        return unknown_4e4d14b6(v8);
    }
    if (v5 != 12) {
        char * v9 = (char *)(v4 - 23); // 0x1002961
        char v10 = v6; // 0x1002961
        *v9 = *v9 + v10;
        int32_t v11; // 0x10028b1
        int32_t * v12 = (int32_t *)(v11 - 25); // 0x100296c
        int32_t v13; // 0x10028b1
        *v12 = *v12 + v13;
        char * v14 = (char *)v6; // 0x1002971
        *v14 = *v14 + v10;
        g55 = v14;
        unknown_11f7ba9();
        abort();
        // UNREACHABLE
    }
    unsigned char v15 = *(char *)0x1010b4d; // 0x10028e3
    int32_t v16 = v15; // 0x10028e3
    int32_t v17 = v6 & -256; // 0x10028e3
    unsigned char v18 = *(char *)0x1b340f3; // 0x10028ea
    if (v15 <= v18) {
        int32_t result = v17 | v16; // 0x10028e3
        int32_t * v19 = (int32_t *)result; // 0x1002919
        *v19 = *v19 ^ result;
        return result;
    }
    int32_t v20 = v15 > 153 ? 154 : 250;
    int32_t v21 = v15 > 153 ? v16 + 160 : v16;
    int32_t v22 = (v15 & 14) > 9 | (v15 & 15) - (v18 & 15) > 15 ? v20 + v16 : v21;
    int32_t result2 = (v22 & 255 | v17) - (v15 > 153 ? 0x1011949 : 0x1011948); // 0x10028f4
    int32_t * v23 = (int32_t *)result2; // 0x10028fc
    *v23 = *v23 + result2;
    return result2;
}

// Address range: 0x1002ad1 - 0x1002ad2
int32_t function_1002ad1(void) {
    // 0x1002ad1
    int32_t result; // 0x1002ad1
    return result;
}

// Address range: 0x1002ad5 - 0x1002c9c
int32_t function_1002ad5(int32_t a1) {
    int32_t v1 = *(int32_t *)0x1964d3d; // 0x1002ad5
    int32_t v2; // 0x1002ad5
    int32_t v3; // 0x1002ad5
    int32_t v4; // 0x1002ad5
    bool v5; // 0x1002ad5
    if (v1 > 27) {
        // 0x1002c71
        __asm_rep_movsd_memcpy((char *)v2, (char *)v3, v4);
        char * v6 = (char *)((v5 ? -4 : 4) * v4 + v2); // 0x1002c7d
        __asm_rep_movsb_memcpy(v6, v6, 0);
        // UNREACHABLE
    }
    // 0x1002ae3
    *(int32_t *)v4 = v1 + v4;
    unknown_22007bd1(v3);
    int32_t v7 = function_1005a26(); // 0x1002afb
    int32_t v8 = *(int32_t *)(v4 - 51); // 0x1002b00
    int32_t * v9 = (int32_t *)v8; // 0x1002b04
    *v9 = *v9 + v7;
    *v9 = *v9 + v7;
    unknown_f9007b5e(*(int32_t *)v7);
    int32_t result = *(int32_t *)0x1013898; // 0x1002b14
    int32_t * v10 = (int32_t *)(v8 - 0x340ce777); // 0x1002b1e
    int32_t v11; // 0x1002ad5
    *v10 = *v10 + v11;
    int32_t v12 = *v9; // 0x1002b25
    int32_t v13 = v12 + result; // 0x1002b25
    *v9 = v13;
    if (((v13 ^ v12) & (v13 ^ result)) >= 0) {
        // 0x1002b2c
        return result;
    }
    // 0x1002b30
    int32_t v14; // 0x1002ad5
    int32_t v15 = v14 | 0x1d86ef6; // 0x1002b32
    int32_t v16 = *(int32_t *)(4 * v3 + (int32_t)&g33); // 0x1002b37
    int32_t * v17 = (int32_t *)v16; // 0x1002b3e
    *v17 = v15;
    int32_t v18 = 0x10000 * v15 / 0x10000; // 0x1002b40
    int32_t v19 = *(int32_t *)(v8 - 123) - 1; // bp-17, 0x1002b42
    char * v20 = (char *)(v16 + 0x7f014d64); // 0x1002b46
    *v20 = *v20 & -117;
    int32_t v21 = v18 + 133 & 255 | v18 & -256; // 0x1002b4d
    int32_t * v22; // 0x1002ad5
    int32_t v23; // 0x1002ad5
    int32_t v24; // 0x1002ad5
    int32_t v25; // 0x1002ad5
    int32_t v26; // 0x1002ad5
    if ((char)v18 < 251) {
        // 0x1002b30
        int32_t v27; // bp-287, 0x1002ad5
        int32_t v28 = &v27; // 0x1002b42
        v22 = (int32_t *)(v28 - 4);
        v23 = v21;
        v26 = v28;
        v24 = &v19;
    } else {
        // 0x1002b51
        *v17 = *v17 + v21;
        __asm_iretd();
        char * v29 = (char *)(v2 - 117); // 0x1002b5d
        *v29 = *v29 + (char)v11;
        int32_t * v30 = (int32_t *)(v2 - 0x5a0cfd17); // 0x1002b60
        *v30 = 2048 * *v30;
        int32_t v31; // bp+7514, 0x1002ad5
        int32_t v32 = *(int32_t *)(v16 - 0x47e6b27d) | (int32_t)&v31; // 0x1002b6b
        int32_t v33 = *(int32_t *)(v3 - 1 + v14); // 0x1002b72
        *v17 = *v17 + v33;
        int32_t v34 = (v33 + 232 & 255 | v33 & -256) + 1; // 0x1002b7d
        int32_t * v35 = (int32_t *)(v32 - 4);
        *v35 = v34;
        char * v36 = (char *)v34; // 0x1002b7f
        *v36 = *v36 + (char)v34;
        int32_t * v37 = (int32_t *)(v11 - 0x675efba8 + 4 * v11); // 0x1002b8b
        *v37 = *v37 + v14;
        v22 = v35;
        v23 = 0x71cca90f;
        v25 = *v35;
        v26 = v32;
        int32_t v38; // bp-290, 0x1002ad5
        v24 = (int32_t)&v38 - *(int32_t *)0x1330076;
    }
    int32_t v39 = v26;
    *v22 = v23;
    char * v40 = (char *)v23; // 0x1002b9e
    *v40 = *v40 + (char)v23;
    int32_t * v41 = (int32_t *)g37; // 0x1002bab
    uint32_t v42 = *v41; // 0x1002bab
    uint32_t v43 = v42 + v23; // 0x1002bab
    *v41 = v43;
    int32_t v44 = v5 ? -4 : 4; // 0x1002bad
    int32_t * v45 = (int32_t *)(g37 - 95); // 0x1002bae
    *v45 = *v45 - (v43 < v42 ? -103 : -104);
    int32_t * v46 = (int32_t *)(v25 + 0x4e8b0470); // 0x1002bb4
    *v46 = *v46 + g37;
    int32_t v47 = *(int32_t *)(4 * (int32_t)g44 - 0x2afe4690); // 0x1002bc0
    *(int32_t *)(4 * g37 + 0xc8d0c) = __asm_vmread(v47);
    char * v48 = (char *)v47; // 0x1002bcf
    *v48 = *v48 + (char)v47;
    uint32_t v49 = g37 / 4; // 0x1002bd3
    __asm_rep_movsd_memcpy((char *)v2, (char *)(v44 + 76 + v23), v49);
    int32_t v50 = v49 * v44 + v2; // 0x1002bd6
    int32_t * v51 = (int32_t *)(v25 - 0x5b0c0510); // 0x1002bd9
    *v51 = *v51 - 95;
    *v22 = g37;
    *(int32_t *)(v39 - 8) = 0;
    *(int32_t *)(v39 - 12) = g37;
    *(int32_t *)(v39 - 16) = v25;
    *(int32_t *)(v39 - 20) = v39;
    *(int32_t *)(v39 - 24) = v24;
    *(int32_t *)(v39 - 28) = v50;
    *(int32_t *)(v39 - 32) = v50;
    if (g37 == 0) {
        // 0x1002c14
        return unknown_16945ef();
    }
    // 0x1002c8f
    *(int32_t *)0xa8b9fa = *(int32_t *)0xa8b9fa + g37;
    *(int32_t *)(g37 + 96) = v25;
    return *(int32_t *)(*(int32_t *)0x1274d90 + 4);
}

// Address range: 0x1002c9d - 0x1002d9e
int32_t function_1002c9d(int32_t a1, int32_t a2) {
    // 0x1002c9d
    int32_t v1; // 0x1002c9d
    unsigned char v2 = (char)v1;
    unsigned char v3 = 2 * v2; // 0x1002ca2
    *(char *)v1 = v3;
    int32_t v4 = *(int32_t *)((int32_t)"\x81ia\xe6zid\xd9[UT\xb9\x05\x05\x05\x8c" - 85); // 0x1002cb2
    int32_t v5; // 0x1002c9d
    int32_t v6 = *(int32_t *)(v5 + 4); // 0x1002cb5
    uint32_t v7 = *(int32_t *)((int32_t)"\x81ia\xe6zid\xd9[UT\xb9\x05\x05\x05\x8c" - 0x74fefe56); // 0x1002cb8
    *(int32_t *)((int32_t)"\x81ia\xe6zid\xd9[UT\xb9\x05\x05\x05\x8c" - 0x74fefe56) = v7 / 2 | 0x80000000 * (int32_t)(v3 < v2);
    if (v3 >= 0) {
        // 0x1002cc0
        return (int32_t)"\x81ia\xe6zid\xd9[UT\xb9\x05\x05\x05\x8c" | 162;
    }
    // 0x1002cc4
    *"\x81ia\xe6zid\xd9[UT\xb9\x05\x05\x05\x8c" = (char)"\x81ia\xe6zid\xd9[UT\xb9\x05\x05\x05\x8c" - 127;
    int32_t v8; // 0x1002c9d
    char * v9 = (char *)(v8 + 0x2c3c1c1); // 0x1002cc6
    unsigned char v10 = *v9; // 0x1002cc6
    unsigned char v11 = v10 + (char)v6; // 0x1002cc6
    *v9 = v11;
    int32_t v12; // 0x1002c9d
    if (v11 < v10 || v11 == 0) {
        // 0x1002cce
        *(char *)v12 = *(char *)(v4 + v8);
        function_1007b4d(g12);
        g58 = v8;
        *(int32_t *)-0x7efeb270 = function_1006b26();
        return __asm_sti() ^ (int32_t)"\x81ia\xe6zid\xd9[UT\xb9\x05\x05\x05\x8c" >> 8 & 255;
    }
    // 0x1002d33
    *(int32_t *)v12 = *(int32_t *)v4;
    bool v13; // 0x1002c9d
    int32_t v14 = v13 ? -4 : 4; // 0x1002d33
    __asm_rep_movsb_memcpy((char *)(v14 + v12), (char *)(v4 + v14), v6);
    abort();
    // UNREACHABLE
}

// Address range: 0x1002daa - 0x10031f4
int32_t function_1002daa(int32_t a1) {
    // 0x1002daa
    int32_t v1; // 0x1002daa
    char * v2 = (char *)(v1 + 0x410f60fe); // 0x1002daa
    int32_t v3; // 0x1002daa
    *v2 = *v2 + (char)v3;
    int32_t v4; // 0x1002daa
    int32_t * v5 = (int32_t *)(v4 - 0x17d0000); // 0x1002db0
    int32_t v6 = *v5; // 0x1002db0
    int32_t v7 = v6 + 109; // 0x1002db0
    *v5 = v7;
    int32_t v8; // 0x1002daa
    int32_t v9; // 0x1002daa
    int32_t v10 = v7 < 0 == (v7 & (v6 ^ -0x80000000)) < 0 ? v8 : *(int32_t *)(v9 + 1); // 0x1002db7
    int32_t v11; // 0x1002daa
    int32_t v12 = v11;
    *(char *)v12 = *(char *)&v11 + (char)v12;
    int32_t v13 = __asm_insd((int16_t)v9); // 0x1002dbd
    int32_t * v14 = (int32_t *)v10; // 0x1002dbd
    *v14 = v13;
    if (llvm_bswap_i32(unknown_84012f11()) > 95) {
        function_132ce93();
    }
    int32_t v15 = function_1007bd1(); // 0x1002dda
    g53 = v15;
    unknown_13c7b21(*(int32_t *)v15);
    int32_t v16 = function_10042e3(*(int32_t *)(*(int32_t *)*(int32_t *)0x101f098 + 4)); // 0x1002e07
    *(int32_t *)*(int32_t *)0x1504d3d = v16;
    int32_t v17 = *(int32_t *)g55; // 0x1002e19
    int32_t v18 = *(int32_t *)(4 * *(int32_t *)(v17 + 4) + 0xe78d0c); // 0x1002e23
    uint32_t v19 = (v1 & 0xff00) + v1;
    *v14 = *(int32_t *)v17;
    bool v20; // 0x1002daa
    int32_t v21 = v20 ? -4 : 4; // 0x1002e32
    __asm_rep_movsb_memcpy((char *)(v10 + v21), (char *)(v17 + v21), v18 & 3);
    float80_t v22; // 0x1002daa
    *(int64_t *)((v9 + 256 * v1 & 0xff00 | v9 & -0xff01) + 77) = (int64_t)v22;
    char v23 = *g123; // 0x1002e45
    char v24 = (int32_t)g123; // 0x1002e45
    char v25 = v23 + v24; // 0x1002e45
    *g123 = v25;
    *(int32_t *)(*(int32_t *)0x475b4d90 + 22) = v19 & 0xff00 | v1 & -0xff01;
    int32_t result = *(int32_t *)(*(int32_t *)-0x36fe41a5 + 4); // 0x1002e54
    v11 = result;
    if (((v25 ^ v23) & (v25 ^ v24)) >= 0) {
        // 0x1002e5a
        return result;
    }
    char * v26 = (char *)result; // 0x1002e5e
    *v26 = *v26 + (char)(v19 / 256);
    abort();
    // UNREACHABLE
}

// Address range: 0x10031f5 - 0x1003215
int32_t function_10031f5(int32_t a1) {
    // 0x10031f5
    return __asm_sti();
}

// Address range: 0x100322d - 0x1003232
int32_t function_100322d(void) {
    // 0x100322d
    return function_8143408b();
}

// Address range: 0x1003232 - 0x1003233
int32_t function_1003232(void) {
    // 0x1003232
    int32_t result; // 0x1003232
    return result;
}

// Address range: 0x1003235 - 0x100323e
int32_t function_1003235(void) {
    // 0x1003235
    int32_t v1; // 0x1003235
    int32_t v2; // 0x1003235
    *(char *)v1 = (char)v1 + 17 + (char)v2;
    return function_900042e5();
}

// Address range: 0x100323e - 0x10032aa
int32_t function_100323e(void) {
    // 0x100323e
    int32_t v1; // 0x100323e
    int16_t v2 = v1; // 0x100323e
    int32_t v3 = __asm_in_5(v2); // 0x100323e
    __asm_out(v2, (char)v3);
    int32_t v4; // 0x100323e
    __asm_outsb(v2, (char)v4);
    int32_t v5 = v3; // 0x1003241
    bool v6; // 0x100323e
    if (v6) {
        v5 = function_100397b();
    }
    // 0x1003247
    bool v7; // 0x100323e
    int32_t v8 = v5 - (v7 ? 133 : 132); // 0x1003248
    int32_t v9 = v8 & 255 | v5 & -256; // 0x1003248
    char * v10 = (char *)v9; // 0x1003251
    char v11 = v8; // 0x1003251
    *v10 = *v10 + v11;
    char * v12 = (char *)(v4 + 14); // 0x1003254
    int32_t v13; // 0x100323e
    *v12 = *v12 + (char)v13;
    *v10 = *v10 + v11;
    int32_t v14; // 0x100323e
    function_10093c3(v14);
    int32_t result = function_1003826(); // 0x100326d
    g56 = result;
    if (v9 == -0x13fe636c) {
        // 0x1003279
        unknown_1e50bc1();
        *(int32_t *)(v14 - 95) = v4 - 2;
        int32_t v15; // 0x100323e
        int32_t * v16 = (int32_t *)(v15 + 0x470ff00); // 0x1003289
        *v16 = *v16 + v13;
        *(int32_t *)*(int32_t *)0x163ca94 = unknown_1fb7bb7();
    }
    // 0x10032a9
    return result;
}

// Address range: 0x10032aa - 0x1003390
int32_t function_10032aa(void) {
    // 0x10032aa
    int32_t v1; // 0x10032aa
    int32_t * v2 = (int32_t *)(v1 - 0x72f3720a); // 0x10032aa
    uint32_t v3 = *v2; // 0x10032aa
    uint32_t v4; // 0x10032aa
    uint32_t v5 = v3 + v4; // 0x10032aa
    *v2 = v5;
    int32_t v6; // 0x10032aa
    unsigned char v7 = (char)v6; // 0x10032b0
    bool v8 = v7 > 153 | v5 < v3;
    int32_t v9; // 0x10032aa
    if ((v7 & 14) > 9 || (v3 & 15) + (v4 & 15) > 15) {
        v9 = (v8 ? 102 : 6) + v6 & 255 | v6 & -256;
    } else {
        v9 = (v8 ? v6 + 96 : v6) & 255 | v6 & -256;
    }
    char * v10 = (char *)v9; // 0x10032b1
    *v10 = *v10 + (char)v9;
    char * v11 = (char *)(v1 - 63); // 0x10032b3
    *v11 = *v11 + (char)(v9 / 256);
    uint32_t v12 = v4 / 4; // 0x10032b6
    int32_t v13; // 0x10032aa
    int32_t v14; // 0x10032aa
    __asm_rep_movsd_memcpy((char *)v13, (char *)v14, v12);
    int32_t v15 = *(int32_t *)(v9 - 0x6bfc1e7d); // 0x10032bb
    int32_t v16 = v1 + 1; // 0x10032c9
    unknown_5c7d7bcc();
    int32_t * v17 = (int32_t *)v15; // 0x10032da
    int32_t v18 = *v17; // 0x10032da
    *v17 = g54;
    if ((v4 & 2) != 0) {
        char * v19 = (char *)v15; // 0x100335c
        *v19 = *v19 + (char)v16;
        int32_t v20 = function_1007bd1(); // 0x1003365
        *(int32_t *)0x14d9053 = v20;
        uint32_t v21 = v20 & 0x48b1e8; // 0x100336f
        char * v22 = (char *)(v1 - 0x51feb26f); // 0x1003374
        *v22 = *v22 + (char)(v21 / 256);
        unknown_12661c1(*(int32_t *)v21);
        *(int32_t *)*(int32_t *)0x101ff90 = v16;
        return *(int32_t *)0x1011198;
    }
    char v23 = v18; // 0x10032de
    unsigned char v24 = v23 - 1; // 0x10032de
    int32_t v25 = v24; // 0x10032de
    int32_t v26 = v18 & -256; // 0x10032de
    if (((v24 ^ v23) & -v23) >= 0) {
        // 0x10032e2
        return v25 + 73 + (int32_t)(v23 != 0) & 255 | v26;
    }
    // 0x10032e6
    bool v27; // 0x10032aa
    int32_t v28 = v27 ? -4 : 4; // 0x10032b9
    int32_t v29 = v26 | v25; // 0x10032de
    char * v30 = (char *)(v1 - 0x1db26bf2); // 0x10032e6
    *v30 = *v30 + (char)v15;
    int32_t * v31 = (int32_t *)(v15 - 0x7b5e94bf); // 0x10032ec
    *v31 = *v31 + v15;
    int32_t v32 = (v27 ? -1 : 1) + v13 + v28 * v12 - 1; // 0x10032f2
    *v17 = *v17 + v29;
    int32_t v33 = *(int32_t *)(v29 + 4); // 0x10032f5
    float80_t v34; // 0x10032aa
    *(float32_t *)v16 = (float32_t)v34;
    unsigned char v35 = g58 + 13 | -115; // 0x1003304
    int32_t v36 = (int32_t)g58 & -256 | (int32_t)v35; // 0x1003306
    char * v37 = (char *)v36; // 0x1003308
    *v37 = *v37 + v35;
    *(int32_t *)v32 = *(int32_t *)v33;
    __asm_rep_movsb_memcpy((char *)(v32 + v28), (char *)(v33 + v28), v36 & -96);
    function_100bd61(g34);
    int16_t v38; // 0x10032aa
    unknown_d8000000(*(int32_t *)-0x54d1c893, 0x18000191, (int32_t)&g1, v38);
    return function_10042e5();
}

// Address range: 0x10033ba - 0x10033bf
int32_t function_10033ba(void) {
    // 0x10033ba
    return function_8ca60ec1();
}

// Address range: 0x10033ed - 0x10033f0
int32_t function_10033ed(void) {
    // 0x10033ed
    int32_t result; // 0x10033ed
    return result;
}

// Address range: 0x10033fb - 0x1003446
int32_t function_10033fb(int32_t a1, int32_t a2) {
    // 0x10033fb
    int32_t v1; // 0x10033fb
    int32_t * v2 = (int32_t *)(v1 - 0x726988); // 0x1003402
    int32_t v3; // 0x10033fb
    *v2 = *v2 + *(int32_t *)(v3 + 4);
    int32_t v4; // 0x10033fb
    int32_t v5 = v4 & 3; // 0x1003416
    __asm_rep_movsb_memcpy((char *)a1, (char *)v3, v5);
    if (*(int32_t *)-0x54b5b2a0 == v1 - 1) {
        function_1003671();
    }
    int32_t v6 = -1 * v5 + a1; // 0x1003419
    __asm_emms();
    char * v7 = (char *)v6; // 0x1003430
    *v7 = *v7 + (char)v6;
    return function_1007bd1() & 0x14ef01d;
}

// Address range: 0x1003447 - 0x1003448
int32_t function_1003447(void) {
    // 0x1003447
    int32_t result; // 0x1003447
    return result;
}

// Address range: 0x1003465 - 0x1003469
int32_t function_1003465(void) {
    // 0x1003465
    return function_1003447();
}

// Address range: 0x1003469 - 0x100346c
int32_t function_1003469(void) {
    // 0x1003469
    int32_t result; // 0x1003469
    return result;
}

// Address range: 0x100347c - 0x100348f
int32_t function_100347c(void) {
    // 0x100347c
    int32_t v1; // 0x100347c
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x100347c
    char * v3 = (char *)(v2 - 0x3e3e7408); // 0x1003484
    *v3 = *v3 - 115;
    return function_52a62791();
}

// Address range: 0x10034ba - 0x1003542
int32_t entry_point(void) {
    // 0x10034ba
    __asm_wait();
    __asm_wait();
    __asm_wait();
    __asm_wait();
    __asm_wait();
    __asm_wait();
    __asm_wait();
    return function_1003e19();
}

// Address range: 0x1003543 - 0x1003618
int32_t function_1003543(void) {
    // 0x1003543
    int32_t v1; // 0x1003543
    if ((uint32_t)(v1 & -v1) >= 0) {
        // 0x1003554
        unknown_58007b71();
        int32_t v2 = *(int32_t *)(*(int32_t *)-0x1011b270 + 4); // 0x100356f
        *(char *)v2 = *(char *)*(int32_t *)(g63 + 4);
        return function_8ca62886();
    }
    uint32_t v3 = unknown_99a42bb8(); // 0x10035b3
    int32_t v4; // 0x1003543
    int32_t * v5 = (int32_t *)v4; // 0x10035b9
    *v5 = v3 + v4;
    int32_t * v6 = (int32_t *)(v1 - 2); // 0x10035be
    *v6 = *v6 + 1;
    char * v7 = (char *)(v4 + (int32_t)&g55); // 0x10035c1
    *v7 = *v7 + (char)(v3 / 256);
    int32_t result; // 0x1003543
    if ((llvm_ctpop_i8((char)v1 - 3) & 1) == 0) {
        // 0x10035ce
        return result;
    }
    // 0x10035cf
    bool v8; // 0x1003543
    int32_t v9 = (v8 ? -4 : 4) + result; // 0x10035c9
    int32_t v10; // 0x1003543
    uint32_t v11 = (v10 & -256) + v10;
    char * v12 = (char *)((v11 & 0xff00 | v10 & -0xff01) + 0x14d4fa1); // 0x10035d7
    *v12 = *v12 + (char)v4;
    int32_t * v13 = (int32_t *)(v4 + 0x4de7a134); // 0x10035dd
    *v13 = *v13 + v4;
    *v5 = v4 + 0x66588900;
    int32_t v14; // 0x1003543
    int32_t v15 = v14 & -256; // 0x10035e6
    int32_t * v16 = (int32_t *)(v15 + 0xc8d38b5); // 0x10035ed
    *v16 = *v16 + v15;
    *(char *)-0x163eb575 = *(char *)-0x163eb575 + (char)(v11 / 256);
    int32_t v17 = *(int32_t *)(v9 + (v8 ? 1 : 3)); // 0x10035fe
    *(int32_t *)(result & -256 | (int32_t)(*(char *)v9 - 24)) = v17;
    char * v18 = (char *)(v14 + 256 * v10 & 0xff00 | v14 & -0x10000); // 0x1003611
    *v18 = *v18 + 24;
    return (int32_t)g55;
}

// Address range: 0x100361a - 0x1003655
int32_t function_100361a(int32_t a1) {
    // 0x100361a
    int32_t v1; // 0x100361a
    int32_t v2 = v1 + 161; // 0x100361a
    int32_t v3 = v1 & -256; // 0x100361a
    int32_t v4; // 0x100361a
    int32_t * v5 = (int32_t *)v4; // 0x100361e
    *v5 = (v2 & 255 | v3) + v4;
    char v6 = v2; // 0x1003622
    unsigned char v7 = v6 + 19; // 0x1003622
    int32_t result = v3 | (int32_t)v7; // 0x1003622
    if ((v7 & (v6 ^ -128)) >= 0) {
        // 0x1003626
        return result;
    }
    int32_t * v8 = (int32_t *)(v4 - 0x6f5efbbf); // 0x1003630
    *v8 = *v8 + v4;
    *v5 = result + v4;
    int32_t v9 = *(int32_t *)(result + 4); // 0x1003639
    uint32_t result2 = *(int32_t *)(v9 + 4); // 0x100363c
    int32_t v10 = *(int32_t *)((int32_t)g55 + 108); // 0x1003644
    char v11; // bp-83, 0x100361a
    char v12; // 0x100361a
    v11 = v12 + (char)(int32_t)&v11;
    __asm_rep_movsd_memcpy((char *)v10, (char *)v9, result2 / 4);
    return result2;
}

// Address range: 0x1003656 - 0x1003671
int32_t function_1003656(void) {
    // 0x1003656
    int32_t v1; // 0x1003656
    int32_t v2; // 0x1003656
    __asm_arpl(*(int16_t *)(v1 + 34), (int16_t)v2);
    bool v3; // 0x1003656
    int32_t v4 = v3 ? (int32_t)&g52 + 1 : (int32_t)&g52; // 0x100365d
    int32_t result = v2 - v4; // 0x100365d
    int32_t v5; // 0x1003656
    if (result == 0) {
        char * v6 = (char *)result; // 0x1003667
        *v6 = *v6 + (char)result;
        int32_t v7; // 0x1003656
        v5 = *(int32_t *)(v7 + 124) & v7;
    }
    // 0x1003669
    g7 = v5;
    return result;
}

// Address range: 0x1003671 - 0x1003685
int32_t function_1003671(void) {
    // 0x1003671
    int32_t v1; // 0x1003671
    int32_t v2; // 0x1003671
    if (*(int32_t *)(v1 + (int32_t)&g51) == v2) {
        int32_t v3 = __asm_sldt(); // 0x100367b
        *(int16_t *)v3 = (int16_t)v3;
    }
    // 0x100367e
    return g44;
}

// Address range: 0x1003685 - 0x10037a6
int32_t function_1003685(void) {
    // 0x1003685
    int32_t v1; // 0x1003685
    bool v2; // 0x1003685
    if (v2) {
        v1 = function_7e004061();
    }
    int32_t v3 = v1; // 0x1003692
    if (*(int32_t *)0x1dd6e48 == 1) {
        v3 = function_c600d9b8();
    }
    // 0x1003698
    char * v4; // bp-4, 0x1003685
    *(int32_t *)&v4 = (int32_t)g55;
    int32_t v5 = v3 - 1; // 0x100369e
    g44 = v5;
    int32_t v6; // 0x1003685
    char * v7 = (char *)(v6 + 1 + 0x10000000 * v5); // 0x10036a9
    uint32_t v8; // 0x1003685
    uint32_t v9; // 0x1003685
    char v10 = (char)(v9 < v8) + (char)v6 + *v7; // 0x10036a9
    *v7 = v10;
    int32_t v11 = v6 - 1; // 0x10036af
    if (v11 != 0 && v10 != 0) {
        int32_t v12 = *(int32_t *)g32; // 0x100370c
        uint32_t v13 = *(int32_t *)(v12 + 4); // 0x100370e
        int32_t v14 = *(int32_t *)0x1f74d7b; // 0x1003711
        int32_t v15 = *(int32_t *)v14; // 0x1003716
        int32_t v16 = v14 - 0xc8d0c; // 0x1003718
        char * v17 = (char *)v16; // 0x100371d
        *v17 = *v17 + (char)v16;
        __asm_rep_movsd_memcpy((char *)v15, (char *)v12, v13 / 0x10000000);
        return (int32_t)v4;
    }
    int32_t * v18 = (int32_t *)v11; // 0x10036b1
    uint32_t v19 = *v18; // 0x10036b1
    int32_t v20 = v19 + 0x2e600d89; // 0x10036b1
    *v18 = v20;
    bool v21 = (v19 & 15) > 6; // 0x10036b9
    int32_t v22 = v11; // 0x10036b9
    bool v23 = v19 > 0xd19ff276; // 0x10036b9
    int32_t v24 = (int32_t)&v4; // 0x10036b9
    int32_t v25; // 0x1003685
    if (v20 != 0) {
        int32_t v26 = function_100f5d1((int32_t)v4); // 0x10036bf
        int32_t v27; // 0x1003685
        g55 = (char *)v27;
        *(int32_t *)0x56844d98 = v26;
        int32_t v28 = *(int32_t *)v26; // 0x10036d4
        int32_t v29 = v28; // bp-8, 0x10036d4
        unknown_10136c1(v28);
        int32_t v30 = *(int32_t *)0x1644d64; // 0x10036e2
        __asm_outsd((int16_t)v9, v8);
        if ((v20 & (v19 ^ -0x80000000)) >= 0) {
            // 0x10036ec
            *(int32_t *)v8 = v30 + v8;
            return unknown_1737bfb(*(int32_t *)(v30 + 4));
        }
        unsigned char v31 = (char)v30; // 0x1003757
        unsigned char v32 = *(char *)v30; // 0x1003757
        v22 = *(int32_t *)0x1134d98;
        *(int32_t *)(v22 + 4) = v30 & -256 | (int32_t)(v31 - v32);
        v21 = (v31 & 15) - (v32 & 15) > 15;
        v23 = v32 > v31;
        v25 = 0x9593;
        v24 = &v29;
    }
    int32_t v33 = function_1007c1d(); // 0x1003773
    *(int32_t *)-0x37feb2d1 = v25;
    unsigned char v34 = (char)v33; // 0x100377e
    bool v35 = v23 | v34 > 153;
    int32_t v36; // 0x1003685
    if (v21 || (v34 & 14) > 9) {
        v36 = (v35 ? 154 : 250) + v33 & 255 | v33 & -256;
    } else {
        v36 = (v35 ? v33 + 160 : v33) & 255 | v33 & -256;
    }
    *(int32_t *)-0x5cffffbc = v36;
    int32_t v37 = 0x10000 * v36 / 0x10000; // 0x1003784
    int32_t * v38 = (int32_t *)v22; // 0x1003786
    *v38 = *v38 + v37;
    *(int32_t *)(v24 - 4) = *(int32_t *)v37;
    function_10089c1();
    return g57;
}

// Address range: 0x10037c8 - 0x10037cd
int32_t function_10037c8(void) {
    // 0x10037c8
    return function_8ca62b04();
}

// Address range: 0x10037cd - 0x10037ce
int32_t function_10037cd(void) {
    // 0x10037cd
    int32_t result; // 0x10037cd
    return result;
}

// Address range: 0x10037e3 - 0x10037e4
int32_t function_10037e3(void) {
    // 0x10037e3
    int32_t result; // 0x10037e3
    return result;
}

// Address range: 0x10037fb - 0x10037fc
int32_t function_10037fb(void) {
    // 0x10037fb
    int32_t result; // 0x10037fb
    return result;
}

// Address range: 0x100381e - 0x1003823
int32_t function_100381e(void) {
    // 0x100381e
    return function_8ca62b25();
}

// Address range: 0x1003826 - 0x1003844
int32_t function_1003826(void) {
    // 0x1003826
    int32_t v1; // 0x1003826
    int32_t v2; // 0x1003826
    int32_t v3 = v2 + v1; // 0x1003826
    int32_t v4; // 0x1003826
    *(char *)v4 = *(char *)v3;
    uint32_t v5; // 0x1003826
    bool v6; // 0x1003826
    char v7 = *(char *)(v3 + 1 + 8 * v5 + (v6 ? -1 : 1)); // 0x100382a
    int32_t v8 = v2 + 1; // 0x100382e
    g7 = 0xfd2301;
    int32_t result = 256 * (int32_t)(v7 | (char)(v5 / 256)) | v5 & -0xff01; // 0x1003839
    if (v8 < 0 == (v8 & (v2 ^ -0x80000000)) < 0) {
        result = function_88003348();
    }
    // 0x100383f
    return result;
}

// Address range: 0x1003844 - 0x10038fb
int32_t function_1003844(void) {
    int32_t v1 = function_1003232(); // 0x100385d
    uint32_t v2; // 0x1003844
    if (*(int32_t *)0x1ea4d88 < v2) {
        v1 = function_10037e3();
    }
    // 0x100385f
    *(char *)v2 = (char)v1 + (char)v2;
    uint32_t v3; // 0x1003844
    int32_t * v4 = (int32_t *)v3; // 0x100386c
    *v4 = 0x361d8900 * (v3 / 256 + v2 & 255 | v2 & -256) + v3;
    int32_t v5 = function_1013026(); // 0x100386e
    *v4 = v5 + v3;
    function_1007bc1(*(int32_t *)v5);
    *(int32_t *)g53 = v1;
    *(char *)-0x3417fb90 = *(char *)-0x3417fb90 + 112;
    *(int32_t *)g53 = -0x3417fb90;
    int32_t v6 = 4 * g53; // 0x10038aa
    int32_t * v7 = (int32_t *)(v1 - 86 + v6); // 0x10038aa
    int32_t v8; // 0x1003844
    *v7 = *v7 + v8;
    uint32_t v9 = v6 - 0x272c35f4; // 0x10038ae
    uint32_t v10 = v9 / 4; // 0x10038b7
    int32_t v11; // 0x1003844
    __asm_rep_movsd_memcpy((char *)v8, (char *)v11, v10);
    bool v12; // 0x1003844
    int32_t v13 = v10 * (v12 ? -4 : 4) + v8; // 0x10038ba
    if (v9 != 0) {
        char * v14 = (char *)v13; // 0x10038c1
        __asm_rep_movsb_memcpy(v14, v14, -1);
        return g70;
    }
    if ((2 * v13 ^ v13) >= 0) {
        // 0x10038cb
        return g70;
    }
    // 0x10038cf
    *(char *)-0x6afeb271 = *(char *)-0x6afeb271 + (char)(g70 / 256);
    *(int32_t *)(g70 - 85) = v1 + 1;
    return function_6900398e();
}

// Address range: 0x100392c - 0x1003934
int32_t function_100392c(void) {
    // 0x100392c
    uint32_t v1; // 0x100392c
    char * v2 = (char *)(v1 + 0x1154d8a); // 0x100392c
    *v2 = *v2 + (char)(v1 / 256);
    int32_t result; // 0x100392c
    return result;
}

// Address range: 0x1003950 - 0x1003955
int32_t function_1003950(void) {
    // 0x1003950
    return function_8c384357();
}

// Address range: 0x100395d - 0x100397b
int32_t function_100395d(void) {
    // 0x100395d
    int32_t v1; // 0x100395d
    int32_t * v2 = (int32_t *)v1; // 0x100395e
    int32_t v3; // 0x100395d
    *v2 = v3 + v1;
    int32_t * v4 = (int32_t *)(v1 + 66); // 0x1003963
    int32_t v5; // 0x100395d
    *v4 = *v4 | v5;
    int32_t v6 = -95 * v3; // 0x1003966
    int32_t v7; // 0x100395d
    int32_t * v8 = (int32_t *)v7; // 0x1003969
    uint32_t v9 = *v8; // 0x1003969
    *v8 = v9 / 2 | 0x80000000 * v9;
    int32_t * v10 = (int32_t *)(v1 - 0x5b72d571); // 0x100396c
    *v10 = *v10 + v1;
    *v2 = v6 + v1;
    return *(int32_t *)(v6 - 88);
}

// Address range: 0x100397b - 0x10039ab
int32_t function_100397b(void) {
    int32_t v1 = function_100994f(); // 0x1003980
    bool v2; // 0x100397b
    bool v3; // 0x100397b
    bool v4; // 0x100397b
    if (v3 == v2 == !v4) {
        v1 = function_100395d();
    }
    // 0x1003982
    int32_t v5; // 0x100397b
    *(int32_t *)v5 = v1 + v5;
    int32_t v6; // 0x100397b
    int16_t v7 = v6; // 0x1003986
    int32_t v8; // 0x100397b
    __asm_outsd(v7, v8);
    int32_t v9 = v1 & -256; // 0x1003988
    int32_t v10 = v1 + 161 & 255 | v9; // 0x1003988
    int32_t v11; // 0x100397b
    *(char *)v11 = (char)v8;
    int32_t * v12 = (int32_t *)(v5 + 1); // 0x100398c
    *v12 = *v12 + v10;
    int32_t * v13 = (int32_t *)(v10 - 100); // 0x100398e
    bool v14; // 0x100397b
    *v13 = *v13 & (v14 ? -1 : 1) + v8;
    int32_t v15 = v1 + 66; // 0x1003993
    int32_t v16 = v15 & 255 | v9; // 0x1003993
    __asm_out_2(v7, v16);
    *(int32_t *)v6 = 2 * v6;
    char * v17 = (char *)v16; // 0x10039a1
    *v17 = *v17 + (char)v15;
    return function_8ca62cad();
}

// Address range: 0x10039ab - 0x10039d7
int32_t function_10039ab(void) {
    // 0x10039ab
    int32_t v1; // bp-4, 0x10039ab
    int32_t result; // 0x10039ab
    int32_t * v2 = (int32_t *)(result + 3086 + 8 * (int32_t)&v1); // 0x10039af
    *v2 = 2 * *v2;
    int32_t v3; // 0x10039ab
    if (v3 != 1) {
        // 0x10039d5
        return result;
    }
    // 0x10039b8
    int32_t v4; // 0x10039ab
    int32_t * v5 = (int32_t *)(v4 - 23); // 0x10039bb
    uint32_t v6 = *v5; // 0x10039bb
    int32_t v7; // 0x10039ab
    uint32_t v8 = v6 + v7; // 0x10039bb
    *v5 = v8;
    int32_t v9 = unknown_33000058(v1, 0) - (v8 < v6 ? 0x3d014d63 : 0x3d014d62); // 0x10039c5
    int32_t result2 = v9 & -256 | (int32_t)(v9 == 0); // 0x10039ca
    g45 = result2;
    return result2;
}

// Address range: 0x10039d7 - 0x10039f8
int32_t function_10039d7(void) {
    int32_t result = function_1007bbf(*(int32_t *)0x1244d90); // 0x10039dd
    int32_t v1; // 0x10039d7
    int32_t v2; // 0x10039d7
    *(int32_t *)v2 = v2 | v1;
    g53 = result;
    return result;
}

// Address range: 0x1003afb - 0x1003afc
int32_t function_1003afb(void) {
    // 0x1003afb
    int32_t result; // 0x1003afb
    return result;
}

// Address range: 0x1003b0f - 0x1003bae
int32_t function_1003b0f(void) {
    // 0x1003b0f
    int32_t v1; // 0x1003b0f
    int32_t v2; // 0x1003b0f
    int32_t * v3 = (int32_t *)(v1 - 43 + v2); // 0x1003b0f
    uint32_t v4 = *v3; // 0x1003b0f
    bool v5; // 0x1003b0f
    int32_t v6 = v5; // 0x1003b0f
    int32_t v7; // 0x1003b0f
    uint32_t v8 = v7 + v6; // 0x1003b0f
    int32_t v9 = v4 - v8; // 0x1003b0f
    *v3 = v9;
    int32_t v10 = v5 ? v8 != -1 | v4 < v9 - v6 : v4 < v8 ? 142 : 141; // 0x1003b13
    int32_t v11; // 0x1003b0f
    int32_t v12 = v11 - v10 & 255 | v11 & -256; // 0x1003b19
    int32_t v13; // 0x1003b0f
    if (v13 != 1) {
        v12 = unknown_849632();
    }
    char v14 = v2; // 0x1003b21
    int32_t result; // 0x1003b0f
    *(char *)result = *(char *)&result | v14;
    char * v15 = (char *)v12; // 0x1003b26
    *v15 = *v15 + (char)v12;
    char * v16 = (char *)(v2 + 1 + (v12 ^ 133)); // 0x1003b2b
    *v16 = *v16 | v14;
    int32_t v17 = (v12 & -256 | (int32_t)__asm_in_1(-99)) + 1; // 0x1003b31
    char * v18 = (char *)v17; // 0x1003b32
    *v18 = *v18 + (char)v17;
    int32_t v19 = v1 + 1;
    int32_t v20 = g42 + v19; // 0x1003b42
    char * v21 = (char *)v20; // 0x1003b43
    *v21 = *v21 + (char)v20;
    int32_t v22 = *(int32_t *)-0x1efeb234; // 0x1003b45
    *(int32_t *)(4 * v22 + 0x101fa08) = v20;
    unknown_17b94c1(*(int32_t *)v20, v1);
    *(char *)0x14d5c0d = 32;
    int32_t v23 = v22 + v1; // 0x1003b7b
    int32_t v24; // 0x1003b0f
    char * v25 = (char *)(2 * v24 + v19); // 0x1003b7f
    char v26 = v23; // 0x1003b7f
    *v25 = *v25 | v26;
    *(int32_t *)v23 = 0x707974ad;
    int32_t v27 = *(int32_t *)g43; // 0x1003b8a
    int32_t v28; // 0x1003b0f
    int32_t v29 = *(int32_t *)(result + 8 * v28); // 0x1003b91
    char * v30 = (char *)(v23 + 1 + v29); // 0x1003b94
    *v30 = *v30 | v26;
    int32_t v31 = *(int32_t *)(v27 + 4); // 0x1003b98
    *(char *)-0x346905c7 = *(char *)-0x346905c7 + (char)v31;
    __asm_rep_movsd_memcpy((char *)v29, (char *)v27, v31);
    return result;
}

// Address range: 0x1003bae - 0x1003bb4
int32_t function_1003bae(int32_t a1) {
    // 0x1003bae
    int32_t result; // 0x1003bae
    return result;
}

// Address range: 0x1003bcd - 0x1003bd0
int32_t function_1003bcd(int32_t a1) {
    // 0x1003bcd
    int32_t result; // 0x1003bcd
    return result;
}

// Address range: 0x1003bd9 - 0x1003cff
int32_t function_1003bd9(void) {
    // 0x1003bd9
    int32_t v1; // 0x1003bd9
    char v2 = v1; // 0x1003bdc
    unsigned char v3 = v2 - 1; // 0x1003bdc
    int32_t result = v1 & -256 | (int32_t)v3; // 0x1003bdc
    if (((v3 ^ v2) & -v2) >= 0) {
        // 0x1003be0
        return result;
    }
    // 0x1003be4
    int32_t v4; // 0x1003bd9
    char * v5 = (char *)(v4 + 0x14d5c87); // 0x1003be4
    int32_t v6; // 0x1003bd9
    *v5 = *v5 + (char)v6;
    int32_t * v7 = (int32_t *)(v4 + 0x4c0878e8); // 0x1003c04
    int32_t v8 = result; // 0x1003be4
    while (true) {
        // 0x1003bea
        int32_t v9; // 0x1003bd9
        int32_t v10 = v9;
        int32_t * v11 = (int32_t *)v10; // 0x1003bea
        *v11 = *v11 + v8;
        int32_t v12 = v8 & 114 | 141; // 0x1003bec
        int32_t v13 = v12 | v8 & -256; // 0x1003bec
        uint32_t v14 = v10 & 114 | v12 | v10 & -256; // 0x1003bee
        int32_t * v15 = (int32_t *)v14; // 0x1003bf0
        *v15 = *v15 + v13;
        *(int32_t *)(v14 + 4) = v13;
        int32_t v16 = g36; // 0x1003bf5
        int32_t v17 = *(int32_t *)(v16 + 67); // 0x1003bfa
        char * v18 = (char *)(v17 + 4); // 0x1003bfd
        *v18 = *v18 | -95;
        char * v19 = (char *)v14; // 0x1003c02
        *v19 = *v19 - g36;
        *v7 = *v7 + v14;
        *v15 = *v15 + v16;
        char * v20 = (char *)v16; // 0x1003c14
        *v20 = *v20 + g36;
        int32_t v21; // 0x1003bd9
        __asm_rep_movsd_memcpy((char *)v21, (char *)v17, v14 / 4);
        int32_t v22 = (v14 & -4) + v21; // 0x1003c1b
        int32_t v23 = *(int32_t *)v22; // 0x1003c1d
        __asm_rep_movsb_memcpy((char *)v23, (char *)v22, 0);
        *(int32_t *)0x7b6f4d5c = *(int32_t *)0x7b6f4d5c + 1;
        v8 = 0x10000 * *(int32_t *)-0x14f6b2a0 / 0x10000;
        *(int32_t *)(4 * g42 + 0x19d4ba0) = v8;
        v9 = g42;
        v21 = v23;
    }
}

// Address range: 0x1003cff - 0x1003d04
int32_t function_1003cff(void) {
    // 0x1003cff
    return function_8ca63006();
}

// Address range: 0x1003d04 - 0x1003ddf
int32_t function_1003d04(void) {
    // 0x1003d04
    int32_t v1; // 0x1003d04
    uint32_t v2 = v1 - 1; // 0x1003d06
    bool v3; // 0x1003d04
    int32_t v4 = v3 ? (int32_t)&g41 + 1 : (int32_t)&g41; // 0x1003d0b
    int32_t v5; // 0x1003d04
    int32_t v6 = v5 - v4; // 0x1003d0b
    int32_t v7 = v2 / 256 + v2 & 255 | v2 & -256; // 0x1003d19
    int32_t v8; // 0x1003d04
    *(char *)v8 = (char)v6;
    bool v9; // 0x1003d04
    uint64_t v10 = (int64_t)*(int32_t *)((v9 ? -1 : 1) + v8) * (int64_t)v6; // 0x1003d1e
    int32_t v11 = 0x10000 * (int32_t)v10;
    int32_t v12 = v11 / 0x10000; // 0x1003d20
    int32_t * v13 = (int32_t *)v7;
    int32_t v14 = v12 + *v13;
    *v13 = v14;
    if (v10 <= 0xffffffff) {
        char * v15 = (char *)v12; // 0x1003d2d
        *v15 = *v15 + (char)v12;
        *v13 = *v13 + v12;
        int32_t v16 = unknown_e5007bd2(); // 0x1003d36
        g55 = (char *)v16;
        __asm_out_4(48, v16);
        function_1007bc1((int32_t)&g125);
        *(int32_t *)*(int32_t *)0x64014d4a = v7;
        return *(int32_t *)*(int32_t *)(4 * g56 + 0x19013370);
    }
    // 0x1003d6f
    int32_t v17; // 0x1003d04
    int32_t v18 = v17 + (int32_t)(v6 < 0);
    int32_t v19 = 0x10000 * *(int32_t *)(v11 / 0x4000 + (int32_t)&g33) / 0x10000; // 0x1003d7e
    *v13 = v19 + v14;
    int32_t v20 = *(int32_t *)v19; // 0x1003d82
    int32_t v21; // 0x1003d04
    __asm_rep_movsd_memcpy((char *)v20, (char *)v21, (4 * v7 + 12) / 4);
    uint32_t result = *(int32_t *)-0x6cfeb268; // 0x1003d99
    if ((v18 - 1 & 1 - v18) >= 0) {
        // 0x1003da1
        return result;
    }
    // 0x1003da5
    g122 = (char)(result / 256) + 48;
    int32_t v22 = *(int32_t *)(4 * (int32_t)g44 + (int32_t)&g33); // 0x1003db3
    char v23 = v22; // 0x1003dbc
    char v24 = v23 - 1; // 0x1003dbc
    int32_t v25 = v24; // 0x1003dbc
    if (((v24 ^ v23) & -v23) >= 0) {
        uint16_t v26 = (int16_t)(v22 & 0xff00 | v25); // 0x1003dc0
        uint16_t v27 = (int16_t)*(char *)(v18 - 2); // 0x1003dc0
        return v22 & -0x10000 | (int32_t)(v26 / v27 & 255) | (int32_t)(256 * (v26 % v27));
    }
    char v28 = llvm_ctpop_i8(v24); // 0x1003dbc
    int16_t v29 = *(int16_t *)-0x563801; // 0x1003dcb
    __asm_arpl(v29, (int16_t)(256 * (16 * (int32_t)((v23 & 15) != 0) | (int32_t)(v23 != 0) | 64 * (int32_t)(v24 == 0) | 128 * (int32_t)(v24 < 0) | 4 * (int32_t)((v28 & 1) == 0)) | v25) | 512);
    __asm_int1();
    return function_b6003e72();
}

// Address range: 0x1003df5 - 0x1003df6
int32_t function_1003df5(void) {
    // 0x1003df5
    int32_t result; // 0x1003df5
    return result;
}

// Address range: 0x1003e04 - 0x1003e05
int32_t function_1003e04(void) {
    // 0x1003e04
    int32_t result; // 0x1003e04
    return result;
}

// Address range: 0x1003e0b - 0x1003e14
int32_t function_1003e0b(void) {
    // 0x1003e0b
    bool v1; // 0x1003e0b
    if (v1) {
        function_1003df5();
    }
    // 0x1003e0d
    return function_8b00003d();
}

// Address range: 0x1003e19 - 0x1003e2c
int32_t function_1003e19(void) {
    // 0x1003e19
    return function_1003e3a();
}

// Address range: 0x1003e2c - 0x1003e3a
int32_t function_1003e2c(void) {
    // 0x1003e2c
    int32_t v1; // 0x1003e2c
    __asm_in_3((int16_t)v1);
    return *(int32_t *)-0x71ac9c05;
}

// Address range: 0x1003e3a - 0x1003e50
int32_t function_1003e3a(void) {
    int32_t v1 = function_1004141(); // 0x1003e3a
    int32_t v2; // 0x1003e3a
    int32_t v3; // 0x1003e3a
    int32_t v4; // 0x1003e3a
    int32_t v5; // 0x1003e3a
    int32_t v6; // 0x1003e3a
    int32_t v7; // 0x1003e3a
    int32_t v8; // 0x1003e3a
    return function_1003e58(v3, v4, v5, &v2, v6, v7, v8, v1);
}

// Address range: 0x1003e50 - 0x1003e58
int32_t function_1003e50(void) {
    // 0x1003e50
    return __asm_wait();
}

// Address range: 0x1003e58 - 0x1003e5c
int32_t function_1003e58(int32_t a1, int32_t a2, int32_t a3, int32_t * a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8) {
    // 0x1003e58
    return function_1003e67();
}

// Address range: 0x1003e5c - 0x1003e5d
int32_t function_1003e5c(void) {
    // 0x1003e5c
    int32_t result; // 0x1003e5c
    return result;
}

// Address range: 0x1003e5d - 0x1003e5f
int32_t function_1003e5d(void) {
    // 0x1003e5d
    return function_1003e5c();
}

// Address range: 0x1003e66 - 0x1003e67
int32_t function_1003e66(void) {
    // 0x1003e66
    int32_t result; // 0x1003e66
    return result;
}

// Address range: 0x1003e67 - 0x1003e6b
int32_t function_1003e67(void) {
    // 0x1003e67
    return __readfsdword((int32_t)&g125);
}

// Address range: 0x1003e6b - 0x1003e72
int32_t function_1003e6b(void) {
    // 0x1003e6b
    return function_a81a391e();
}

// Address range: 0x1003e75 - 0x1003e7b
int32_t function_1003e75(int32_t Offset) {
    // 0x1003e75
    __readfsdword(Offset);
    return function_1003e85();
}

// Address range: 0x1003e7b - 0x1003e85
int32_t function_1003e7b(void) {
    // 0x1003e7b
    int32_t result; // 0x1003e7b
    bool v1; // 0x1003e7b
    bool v2; // 0x1003e7b
    if (v2 != v1) {
        result = function_1003e04();
    }
    // 0x1003e7d
    return result;
}

// Address range: 0x1003e85 - 0x1003e8f
int32_t function_1003e85(void) {
    // 0x1003e85
    return function_1003e9e();
}

// Address range: 0x1003e8f - 0x1003e9e
int32_t function_1003e8f(void) {
    // 0x1003e8f
    int32_t v1; // 0x1003e8f
    if ((v1 & 64) == 0) {
        function_1003e66();
    }
    // 0x1003e95
    int32_t v2; // 0x1003e8f
    return __asm_in(152) & -256 | v2 & 255;
}

// Address range: 0x1003e9e - 0x1003eaa
int32_t function_1003e9e(void) {
    int32_t result = function_1003eb3((int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125); // 0x1003ea8
    return result;
}

// Address range: 0x1003eab - 0x1003eae
int32_t function_1003eab(int32_t a1) {
    // 0x1003eab
    int32_t result; // 0x1003eab
    return result;
}

// Address range: 0x1003eb3 - 0x1003f06
int32_t function_1003eb3(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1; // 0x1003eb3
    int32_t v2 = v1 - 1; // 0x1003ef2
    while (v2 != 0) {
        // 0x1003eb6
        v2--;
    }
    // 0x1003f04
    return function_1003f15();
}

// Address range: 0x1003f06 - 0x1003f08
int32_t function_1003f06(void) {
    // 0x1003f06
    int32_t result; // 0x1003f06
    return result;
}

// Address range: 0x1003f15 - 0x1003f29
int32_t function_1003f15(void) {
    // 0x1003f15
    int32_t v1; // 0x1003f15
    int32_t v2; // 0x1003f15
    return function_1003f36(v1, v2);
}

// Address range: 0x1003f31 - 0x1003f34
int32_t function_1003f31(int32_t a1) {
    // 0x1003f31
    int32_t result; // 0x1003f31
    return result;
}

// Address range: 0x1003f36 - 0x1003f3b
int32_t function_1003f36(int32_t a1, int32_t a2) {
    // 0x1003f36
    return function_1003f48();
}

// Address range: 0x1003f3b - 0x1003f48
int32_t function_1003f3b(int16_t a1) {
    // 0x1003f3b
    int32_t v1; // 0x1003f3b
    int32_t v2; // 0x1003f3b
    return (256 * v1 & 0xff00 | v2) ^ 186;
}

// Address range: 0x1003f48 - 0x1003f50
int32_t function_1003f48(void) {
    int32_t result = function_1003f5b((int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125); // 0x1003f4e
    return result;
}

// Address range: 0x1003f50 - 0x1003f5b
int32_t function_1003f50(void) {
    uint32_t v1 = __asm_wait(); // 0x1003f52
    int32_t v2; // 0x1003f50
    int32_t v3; // 0x1003f50
    *(int32_t *)v3 = v3 ^ v2;
    int32_t v4; // 0x1003f50
    char v5 = *(char *)(v4 + 5); // 0x1003f55
    return (256 * (int32_t)(v5 + (char)(v1 / 256)) | v1 & -0xff01) - 1;
}

// Address range: 0x1003f5b - 0x1004105
int32_t function_1003f5b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7, int32_t a8, int32_t a9, int32_t a10, int32_t a11) {
    // 0x1003f5b
    int32_t v1; // 0x1003f5b
    if (v1 == 0) {
        // 0x10040ff
        return function_1004114((int32_t)&g125, (int32_t)&g125);
    }
    // 0x1003f72
    int32_t v2; // 0x1003f5b
    int32_t v3 = v1 + v2; // 0x1003f72
    int32_t v4 = *(int32_t *)(v3 + 24); // 0x1003f8b
    while (v4 != 0) {
        // 0x1003fb3
        v4--;
        int32_t v5 = *(int32_t *)(*(int32_t *)(v3 + 32) + v2 + 4 * v4) + v2; // 0x1003fc7
        uint32_t v6 = 0;
        unsigned char v7 = *(char *)v5; // 0x1003fcc
        int32_t v8 = (v6 / 0x2000 | 0x80000 * v6) + (int32_t)v7; // 0x1003fec
        bool v9; // 0x1003f5b
        v5 += (v9 ? -1 : 1);
        while (v7 != 0) {
            // 0x1003fc9
            v6 = v8;
            v7 = *(char *)v5;
            v8 = (v6 / 0x2000 | 0x80000 * v6) + (int32_t)v7;
            v5 += (v9 ? -1 : 1);
        }
        // 0x1003ff7
        int32_t v10; // 0x1003f5b
        if (*(int32_t *)(v10 - 8) + v8 == *(int32_t *)(v10 + 36)) {
            uint16_t v11 = *(int16_t *)(2 * v4 + v2 + *(int32_t *)(v3 + 36)); // 0x100403e
            int32_t v12 = *(int32_t *)(v3 + 28); // 0x1004050
            return *(int32_t *)(v12 + v2 + 4 * (v4 & 0x3fff0000 | (int32_t)v11)) + v2;
        }
    }
    // 0x10040ff
    return function_1004114((int32_t)&g125, (int32_t)&g125);
}

// Address range: 0x1004105 - 0x100410a
int32_t function_1004105(void) {
    // 0x1004105
    return function_2b5d1885();
}

// Address range: 0x1004114 - 0x100411b
int32_t function_1004114(int32_t a1, int32_t a2) {
    // 0x1004114
    return function_1004126();
}

// Address range: 0x100411b - 0x1004126
int32_t function_100411b(void) {
    // 0x100411b
    int32_t v1; // 0x100411b
    bool v2; // 0x100411b
    if (v1 != 1 == v2) {
        function_100413c();
    }
    // 0x100411d
    return *(int32_t *)-0x129fe9c9;
}

// Address range: 0x1004126 - 0x100412e
int32_t function_1004126(void) {
    // 0x1004126
    return function_100413c();
}

// Address range: 0x1004132 - 0x1004136
int32_t function_1004132(void) {
    // 0x1004132
    int32_t result; // 0x1004132
    return result;
}

// Address range: 0x100413c - 0x1004141
int32_t function_100413c(void) {
    // 0x100413c
    return function_1003e9e();
}

// Address range: 0x1004141 - 0x1004146
int32_t function_1004141(void) {
    // 0x1004141
    return function_1004150((int32_t)&g125);
}

// Address range: 0x100414e - 0x100414f
int32_t function_100414e(void) {
    // 0x100414e
    int32_t result; // 0x100414e
    return result;
}

// Address range: 0x1004150 - 0x1004156
int32_t function_1004150(int32_t a1) {
    // 0x1004150
    return function_1004164();
}

// Address range: 0x1004156 - 0x1004164
int32_t function_1004156(void) {
    // 0x1004156
    int32_t v1; // 0x1004156
    bool v2; // 0x1004156
    bool v3 = (uint32_t)(v1 & 14) > 9 | v2; // 0x1004156
    int32_t v4; // 0x1004156
    float80_t v5; // 0x1004156
    *(int16_t *)(v4 + 0x79898196) = (int16_t)v5;
    return (v3 ? v1 + 6 : v1) & 15 | v1 & -0x10000 | 256 * (int32_t)v3 + v1 & 0xff00;
}

// Address range: 0x1004164 - 0x1004169
int32_t function_1004164(void) {
    // 0x1004164
    return function_1004178();
}

// Address range: 0x1004169 - 0x1004178
int32_t function_1004169(void) {
    // 0x1004169
    int32_t v1; // 0x1004169
    int32_t v2; // 0x1004169
    *(char *)v1 = (char)v2;
    int32_t v3; // 0x1004169
    if ((char)(v3 * v1) != 15) {
        function_100414e();
    }
    // 0x1004170
    return 0x10000 * unknown_53668edb() / 0x10000 & -256 | 245;
}

// Address range: 0x1004178 - 0x1004184
int32_t function_1004178(void) {
    // 0x1004178
    return function_100418c(64);
}

// Address range: 0x1004184 - 0x100418c
int32_t function_1004184(void) {
    int32_t result = __asm_wait(); // 0x1004187
    int32_t v1; // 0x1004184
    int32_t v2; // 0x1004184
    *(int32_t *)v1 = v1 - v2;
    return result;
}

// Address range: 0x100418c - 0x10041c3
int32_t function_100418c(int32_t a1) {
    // 0x100418c
    int32_t v1; // 0x100418c
    return function_10041d1(-0x1aac5ba8, 0, v1, 0x1000);
}

// Address range: 0x10041c1 - 0x10041c2
int32_t function_10041c1(void) {
    // 0x10041c1
    int32_t result; // 0x10041c1
    return result;
}

// Address range: 0x10041c3 - 0x10041d1
int32_t function_10041c3(int16_t a1) {
    // 0x10041c3
    int32_t v1; // 0x10041c3
    return 0x10000 * v1 / 0x10000;
}

// Address range: 0x10041d1 - 0x10041dd
int32_t function_10041d1(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x10041d1
    return function_10041e7();
}

// Address range: 0x10041e5 - 0x10041e7
int32_t function_10041e5(void) {
    // 0x10041e5
    int32_t result; // 0x10041e5
    return result;
}

// Address range: 0x10041e7 - 0x10041ef
int32_t function_10041e7(void) {
    // 0x10041e7
    return function_10041fe();
}

// Address range: 0x10041f0 - 0x10041fc
int32_t function_10041f0(void) {
    // 0x10041f0
    int32_t v1; // 0x10041f0
    return function_ff157ccd(v1);
}

// Address range: 0x10041fb - 0x10041fc
int32_t function_10041fb(void) {
    // 0x10041fb
    int32_t result; // 0x10041fb
    return result;
}

// Address range: 0x10041fe - 0x100420a
int32_t function_10041fe(void) {
    // 0x10041fe
    function_1004331((int32_t)&g125);
    return function_1004214((int32_t)&g125);
}

// Address range: 0x100420a - 0x1004214
int32_t function_100420a(void) {
    // 0x100420a
    int32_t result; // 0x100420a
    return result;
}

// Address range: 0x1004214 - 0x100422c
int32_t function_1004214(int32_t a1) {
    // 0x1004214
    int32_t v1; // 0x1004214
    *(char *)v1 = *(char *)a1;
    return function_1004235();
}

// Address range: 0x100422c - 0x100422d
int32_t function_100422c(int32_t a1) {
    // 0x100422c
    int32_t result; // 0x100422c
    return result;
}

// Address range: 0x1004235 - 0x100423f
int32_t function_1004235(void) {
    // 0x1004235
    function_10042fd();
    return function_1004248();
}

// Address range: 0x100423f - 0x1004248
int32_t function_100423f(void) {
    // 0x100423f
    int32_t v1; // 0x100423f
    int32_t v2; // 0x100423f
    *(int32_t *)v1 = v2 & -0xff01 | 2560;
    int32_t result; // 0x100423f
    return result;
}

// Address range: 0x1004248 - 0x100425a
int32_t function_1004248(void) {
    // 0x1004248
    return function_1004266(-0x62426a5a);
}

// Address range: 0x100425e - 0x1004266
int32_t function_100425e(void) {
    // 0x100425e
    int32_t v1; // 0x100425e
    return v1 - 0x5582fe0 - *(int32_t *)(v1 - 0x5583059);
}

// Address range: 0x1004266 - 0x1004270
int32_t function_1004266(int32_t a1) {
    // 0x1004266
    return function_1004279((int32_t)&g125, (int32_t)&g125);
}

// Address range: 0x1004270 - 0x1004279
int32_t function_1004270(void) {
    // 0x1004270
    int32_t v1; // 0x1004270
    *(char *)v1 = (char)v1 - 1;
    int32_t v2; // 0x1004270
    int32_t v3; // 0x1004270
    bool v4; // 0x1004270
    int32_t v5 = v3 & -0x10000 | v2 & 255 | 256 * (int32_t)(v4 | (v3 & 14) > 9) + v3 & 0xff00; // 0x1004275
    if (v2 == 0) {
        v5 = function_10042f0();
    }
    int32_t v6 = v5;
    return v6 + 135 & 255 | v6 & -256;
}

// Address range: 0x1004279 - 0x10042de
int32_t function_1004279(int32_t a1, int32_t a2) {
    // 0x1004279
    return function_10042e6(0);
}

// Address range: 0x10042e3 - 0x10042e4
int32_t function_10042e3(int32_t a1) {
    // 0x10042e3
    int32_t result; // 0x10042e3
    return result;
}

// Address range: 0x10042e5 - 0x10042e6
int32_t function_10042e5(void) {
    // 0x10042e5
    int32_t v1; // 0x10042e5
    unsigned char v2 = (char)v1; // 0x10042e5
    bool v3; // 0x10042e5
    bool v4 = v2 > 153 | v3;
    int32_t result; // 0x10042e5
    bool v5; // 0x10042e5
    if (v5 || (v2 & 14) > 9) {
        result = (v4 ? 102 : 6) + v1 & 255 | v1 & -256;
    } else {
        result = (v4 ? v1 + 96 : v1) & 255 | v1 & -256;
    }
    return result;
}

// Address range: 0x10042e6 - 0x10042ed
int32_t function_10042e6(int32_t a1) {
    // 0x10042e6
    int32_t v1; // 0x10042e6
    return function_10042fb(v1);
}

// Address range: 0x10042f0 - 0x10042fb
int32_t function_10042f0(void) {
    // 0x10042f0
    int32_t v1; // 0x10042f0
    uint32_t v2; // 0x10042f0
    uint32_t v3 = v2 + v1; // 0x10042f0
    *(int32_t *)v2 = v3;
    int32_t v4; // 0x10042f0
    if (v3 < v2 || v3 == 0) {
        v4 = function_1004321();
    }
    // 0x10042f4
    return v4 & -256 | (int32_t)*(char *)-0x10f7e0bf;
}

// Address range: 0x10042fb - 0x10042fd
int32_t function_10042fb(int32_t a1) {
    // 0x10042fb
    int32_t result; // 0x10042fb
    return result;
}

// Address range: 0x10042fd - 0x1004304
int32_t function_10042fd(void) {
    // 0x10042fd
    return __readfsdword((int32_t)&g125);
}

// Address range: 0x1004307 - 0x1004310
int32_t function_1004307(int32_t a1) {
    // 0x1004307
    int32_t result; // 0x1004307
    return result;
}

// Address range: 0x1004310 - 0x100431b
int32_t function_1004310(int32_t Offset) {
    int32_t v1 = __readfsdword(Offset); // bp-4, 0x1004310
    int32_t v2; // 0x1004310
    __writefsdword(v2, (int32_t)&v1);
    return function_100432a();
}

// Address range: 0x1004321 - 0x100432a
int32_t function_1004321(void) {
    // 0x1004321
    int32_t v1; // 0x1004321
    unsigned char v2 = (char)v1; // 0x1004323
    bool v3 = v2 > 153 | (v1 & 256) != 0;
    int32_t v4; // 0x1004321
    if ((v1 & 0x1000) != 0 || (v2 & 14) > 9) {
        v4 = (v3 ? 102 : 6) + v1 & 255 | v1 & -256;
    } else {
        v4 = (v3 ? v1 + 96 : v1) & 255 | v1 & -256;
    }
    __asm_int(86);
    return v4 & -45;
}

// Address range: 0x100432a - 0x1004331
int32_t function_100432a(void) {
    // 0x100432a
    int32_t result; // 0x100432a
    return result;
}

// Address range: 0x1004331 - 0x1004367
int32_t function_1004331(int32_t a1) {
    int32_t v1 = __asm_fnstenv(); // 0x100433d
    int32_t * v2 = (int32_t *)(a1 + 27); // 0x100434b
    *v2 = *v2 ^ v1;
    int32_t v3; // 0x1004331
    int32_t v4 = &v3; // 0x100434b
    int32_t v5 = 428; // 0x100434b
    int32_t v6 = __asm_in(49); // 0x1004351
    v4--;
    while (v4 != 0 && v5 != 1) {
        // 0x100434e
        v5--;
        v6 = __asm_in(49);
        v4--;
    }
    // 0x100435d
    int32_t v7; // 0x1004331
    int32_t v8; // 0x1004331
    *(int32_t *)v8 = v8 ^ v7;
    int32_t result = v6; // 0x1004362
    int32_t v9; // 0x1004331
    if (v7 != v9) {
        result = function_10042fd();
    }
    // 0x1004364
    return result;
}

// Address range: 0x100436f - 0x100437b
int32_t function_100436f(int32_t a1) {
    // 0x100436f
    int32_t v1; // 0x100436f
    uint32_t v2; // 0x100436f
    int32_t v3; // 0x100436f
    *(char *)(v1 - 0x2e8643ca + 4 * v3) = (char)(v2 / 256);
    int32_t result; // 0x100436f
    return result;
}

// Address range: 0x1004383 - 0x10043cc
int32_t function_1004383(void) {
    // 0x1004383
    int32_t v1; // 0x1004383
    bool v2; // 0x1004383
    int32_t * v3; // 0x100439a
    if (!v2) {
        // 0x100439a
        v3 = (int32_t *)(v1 - 86);
        *v3 = *v3 + 0x6aeccd84;
        int32_t result; // 0x1004383
        return result;
    }
    // 0x1004385
    int32_t v4; // 0x1004383
    int32_t v5 = &v4; // 0x100438c
    int32_t v6; // 0x1004383
    __asm_into(v6);
    uint32_t v7; // 0x1004383
    if (v7 < 0x98910b1d) {
        // 0x10043b3
        int32_t v8; // 0x1004383
        *(char *)-0x35f42163 = __asm_insb((int16_t)v8);
        *(int32_t *)-0x191fbdb2 = v5;
        int32_t v9; // bp+124, 0x1004383
        return &v9;
    }
    char v10 = __asm_in_1(-57); // 0x1004390
    int32_t v11; // 0x1004383
    *(int32_t *)(v7 - 4) = v7 + v11 & 255 | v11 & -256;
    // 0x100439a
    v3 = (int32_t *)(v1 - 86);
    *v3 = *v3 + 0x6aeccd84;
    return v5 & -256 | (int32_t)v10;
}

// Address range: 0x10043ce - 0x10044ed
int32_t function_10043ce(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x10043ce
    int32_t v1; // 0x10043ce
    bool v2; // 0x10043ce
    int32_t v3 = (v2 ? -1 : 1) + v1; // 0x10043ce
    int32_t v4; // 0x10043ce
    uint32_t v5; // 0x10043ce
    *(char *)(v4 - 0x7a5b7c34) = (char)(v5 / 256);
    uint32_t v6; // 0x10043ce
    int32_t v7 = (v2 ? -4 : 4) + v6; // 0x10043d7
    int32_t v8 = 256 * a1 & 0xff00 | a1 & -0xff01; // 0x10043de
    uint32_t v9; // 0x10043ce
    uint16_t v10; // 0x10043ce
    if (v6 < 0) {
        // 0x10043e3
        __asm_outsd((int16_t)v8, *(int32_t *)v7);
        char * v11 = (char *)(v8 - 0x621ebd94); // 0x10043e4
        *v11 = *v11 & (char)(v9 / 256);
        __asm_vzeroupper();
        int32_t v12 = v10; // 0x1004401
        int32_t v13; // 0x10043ce
        if (*(char *)(v7 + 123) > (char)v13) {
            v12 = function_1004383();
        }
        // 0x1004403
        *(char *)v3 = __asm_insb((int16_t)a4);
        return v12 & -0xff01 | 0x4000;
    }
    int32_t v14 = v7; // bp-4, 0x1004460
    char v15 = *(char *)(8 * v4 + (int32_t)&v14); // 0x1004462
    int32_t v16 = __asm_in_5((int16_t)v8); // 0x1004469
    uint32_t v17 = v9 / 256; // 0x1004471
    char v18 = v17; // 0x1004471
    uint32_t v19 = v6 / 256; // 0x1004471
    int32_t v20 = __asm_bound(*(int64_t *)(v7 + 0x20b5e712)); // 0x1004476
    *(int32_t *)v3 = v16;
    if (((v18 - (char)v19 ^ v18) & (char)(v17 ^ v19)) < 0) {
        int32_t result = __asm_hlt(); // 0x10044bd
        __asm_out((int16_t)(v9 & v8), (char)result);
        return result;
    }
    unsigned char v21 = v15 ^ (char)v6 | 126; // 0x1004465
    int32_t v22 = v10; // 0x1004473
    char * v23 = (char *)(4 * (v6 & 0x3fffff00 | (int32_t)v21) + v7); // 0x100447f
    *v23 = *v23 + (char)v16;
    char * v24 = (char *)(v22 + 0x21aa3666); // 0x1004482
    *v24 = v21;
    int32_t v25 = *(int32_t *)(v16 - 59) | v3 + 4; // 0x1004488
    char v26 = llvm_ctpop_i8((char)v25); // 0x1004488
    float80_t v27; // 0x10043ce
    *(int64_t *)(v22 - 86) = (int64_t)v27;
    int32_t v28 = __asm_int1(); // 0x100448f
    if ((v26 & 1) == 0) {
        char * v29 = (char *)(v20 + 0x90f45e1); // 0x10044e7
        *v29 = *v29 ^ *v24;
        return v28 & -256 | (int32_t)*(char *)-0x1f05e656;
    }
    // 0x1004498
    *(int32_t *)v25 = *(int32_t *)*(int32_t *)(v20 + 18);
    int32_t v30 = __asm_sti(); // 0x100449d
    int32_t result2 = __asm_hlt(); // 0x10044ac
    int32_t * v31 = (int32_t *)((v30 & -105 ^ 148) - 8); // 0x10044ad
    *v31 = *v31 + v20;
    int32_t * v32 = (int32_t *)(result2 - 124); // 0x10044b1
    *v32 = 0x8000 * *v32;
    return result2;
}

// Address range: 0x10044f2 - 0x1004586
int32_t function_10044f2(void) {
    // 0x10044f2
    int32_t v1; // 0x10044f2
    int32_t v2 = &v1; // bp-4, 0x10044f2
    int32_t result; // 0x10044f2
    bool v3; // 0x10044f2
    if (!v3) {
        // 0x10044f5
        return result;
    }
    // 0x1004543
    __asm_out_4(199, result);
    int32_t v4 = &v2; // 0x1004543
    int32_t v5; // 0x10044f2
    int32_t v6; // 0x10044f2
    *(int32_t *)v5 = __asm_insd((int16_t)v6 & 255 | -0x3f00);
    int32_t v7 = *(int32_t *)(v4 + 32); // 0x100454c
    uint32_t v8 = *(int32_t *)(v4 + 48); // 0x100454c
    uint32_t v9 = *(int32_t *)(v4 + 52); // 0x100454c
    uint32_t v10 = *(int32_t *)(v4 + 56); // 0x100454c
    char * v11 = (char *)v8; // 0x100454d
    *v11 = *v11 - 92;
    bool v12; // 0x10044f2
    int32_t v13 = *(int32_t *)(v4 + 36) + (v12 ? -1 : 1); // 0x1004551
    int32_t * v14 = (int32_t *)__asm_int3(); // 0x1004554
    uint32_t v15 = *v14; // 0x1004554
    *v14 = v15 / 2 | 0x80000000 * v15;
    char * v16 = (char *)(v8 + v7 & 0xffff); // 0x1004556
    *v16 = *v16 - (char)(v10 / 256) + (char)((v15 & 1) != 0);
    int32_t * v17 = (int32_t *)(v9 - 0xb255840); // 0x100455a
    *v17 = *v17 ^ v8;
    unsigned char v18 = (char)(v9 / 256); // 0x1004560
    unsigned char v19 = *(char *)(v13 - 0x1b88d2a0); // 0x1004560
    int32_t v20 = 256 * (int32_t)(v18 - v19) | v9 & -0xff01; // 0x1004560
    *(char *)(v13 + 0x3d6c21ce) = (char)(v8 / 256);
    v4 += 60;
    *(int32_t *)v4 = v20;
    int32_t result2 = __asm_in_5((int16_t)v20); // 0x100456e
    char v21; // 0x100457f
    while (v10 != 1) {
        // 0x100457d
        if (v19 <= v18) {
            // 0x100457f
            v21 = result2;
            __asm_out_6(224, v21);
            *(char *)-0x4ae4d022 = v21;
            return result2;
        }
        *(int32_t *)(v7 - 1) = __asm_insd((int16_t)v20 & 255 | -0x3f00);
        v7 = *(int32_t *)(v4 + 32);
        v8 = *(int32_t *)(v4 + 48);
        v9 = *(int32_t *)(v4 + 52);
        v10 = *(int32_t *)(v4 + 56);
        v11 = (char *)v8;
        *v11 = *v11 - 92;
        v13 = *(int32_t *)(v4 + 36) + (v12 ? -1 : 1);
        v14 = (int32_t *)__asm_int3();
        v15 = *v14;
        *v14 = v15 / 2 | 0x80000000 * v15;
        v16 = (char *)(v8 + v7 & 0xffff);
        *v16 = *v16 - (char)(v10 / 256) + (char)((v15 & 1) != 0);
        v17 = (int32_t *)(v9 - 0xb255840);
        *v17 = *v17 ^ v8;
        v18 = (char)(v9 / 256);
        v19 = *(char *)(v13 - 0x1b88d2a0);
        v20 = 256 * (int32_t)(v18 - v19) | v9 & -0xff01;
        *(char *)(v13 + 0x3d6c21ce) = (char)(v8 / 256);
        v4 += 60;
        *(int32_t *)v4 = v20;
        result2 = __asm_in_5((int16_t)v20);
    }
    // 0x100457d
    float80_t v22; // 0x10044f2
    *(float32_t *)(result2 - 9) = (float32_t)v22;
    // 0x100457f
    v21 = result2;
    __asm_out_6(224, v21);
    *(char *)-0x4ae4d022 = v21;
    return result2;
}

// Address range: 0x10045ae - 0x10045af
int32_t function_10045ae(void) {
    // 0x10045ae
    int32_t result; // 0x10045ae
    return result;
}

// Address range: 0x10045c4 - 0x10045c9
int32_t function_10045c4(int32_t a1) {
    // 0x10045c4
    return __asm_int3();
}

// Address range: 0x10045c9 - 0x10047b6
int32_t function_10045c9(int32_t a1, int32_t a2) {
    // 0x10045c9
    int32_t v1; // 0x10045c9
    int32_t * v2 = (int32_t *)(v1 - 21); // 0x10045ce
    uint32_t v3 = *v2; // 0x10045ce
    *v2 = v3 / 0x4000000;
    int32_t v4 = a1; // 0x10045d3
    if ((v3 & 0x2000000) == 0 && v3 >= 0x4000000) {
        v4 = function_10045ae();
    }
    int32_t v5; // 0x10045c9
    if (v5 != 1 != v3 < 0x4000000) {
        // 0x10045d7
        return function_44d716a7();
    }
    // 0x100461f
    int32_t v6; // 0x10045c9
    bool v7; // 0x10045c9
    int32_t v8 = v6 & -0xff01 | 0x1000 * (int32_t)v7 | 1536; // 0x1004623
    unsigned char v9 = (char)v4; // 0x100462a
    uint32_t v10 = v4 / 256; // 0x100462a
    bool v11; // 0x10045c9
    if (v5 == 2 || v9 == (char)v10) {
        // 0x100462f
        int16_t v12; // 0x10045c9
        int32_t v13 = unknown_50d3d9ee(v12, v8); // 0x100462f
        unsigned char v14 = (char)a2; // 0x100463a
        bool v15 = v14 > 153 | v9 < 164;
        int32_t v16; // 0x10045c9
        if ((v14 & 14) > 9 || (v4 & 15) == 15) {
            v16 = (v15 ? 102 : 6) + a2 & 255 | a2 & -256;
        } else {
            v16 = (v15 ? a2 + 96 : a2) & 255 | a2 & -256;
        }
        char * v17 = (char *)(v13 + 45); // 0x100464a
        *v17 = v9 + 1 + *v17;
        *(char *)0x1f44a4f8 = *(char *)0x1f44a4f8 ^ 48;
        char v18 = (char)v16 ^ -56; // 0x100465b
        int32_t result = v16 & -256 | (int32_t)v18; // 0x100465d
        if (v18 < 1) {
            result = function_24642976();
        }
        // 0x1004666
        __asm_outsd((int16_t)(result >> 31), v1);
        char * v19 = v11 ? (char *)-0x569ad076 : (char *)-0x569ad06e; // 0x100466a
        *v19 = (char)result;
        int32_t * v20 = (int32_t *)(v5 - 0x1dc56443); // 0x100466b
        uint32_t v21 = *v20; // 0x100466b
        *v20 = v21 / 0x2000000 | 128 * v21;
        return result;
    }
    // 0x1004602
    int16_t v22; // 0x10045c9
    int32_t v23 = &v22; // 0x1004626
    int32_t v24 = *(int32_t *)(v8 + 94) | v8; // 0x1004627
    *(int32_t *)(v23 - 16) = 0x1f44a479;
    *(int32_t *)(v23 - 20) = v23;
    *(int32_t *)(v23 - 24) = a2;
    unsigned char v25 = (char)v24; // 0x1004607
    int32_t result2 = v24 & -0x10000 | (int32_t)(v25 % 45) | 256 * (int32_t)(v25 / 45); // 0x1004607
    int32_t * v26 = (int32_t *)(v1 + 0x34bf064c); // 0x100460b
    *v26 = v23 - 32;
    if ((char)(v10 || v4) == 0) {
        // 0x10045fc
        bool v27; // 0x10045c9
        bool v28; // 0x10045c9
        *(int32_t *)a2 = 0x4000 * (int32_t)v27 | 1024 * (int32_t)v11 | 256 * (int32_t)v28 | 70;
        return result2;
    }
    // 0x1004614
    *(int32_t *)(*v26 - 4) = a2;
    return result2;
}

// Address range: 0x10047c1 - 0x10047c2
int32_t function_10047c1(void) {
    // 0x10047c1
    int32_t result; // 0x10047c1
    return result;
}

// Address range: 0x10047f6 - 0x10047ff
int32_t function_10047f6(int32_t a1) {
    // 0x10047f6
    int32_t v1; // 0x10047f6
    int32_t v2; // 0x10047f6
    char v3 = *(char *)(v1 + 78 + v2); // 0x10047f6
    bool v4; // 0x10047f6
    return v2 & -256 | (int32_t)(v3 + (char)v2 + (char)v4);
}

// Address range: 0x100480b - 0x100480c
int32_t function_100480b(void) {
    // 0x100480b
    int32_t result; // 0x100480b
    return result;
}

// Address range: 0x1004812 - 0x1004813
int32_t function_1004812(void) {
    // 0x1004812
    int32_t result; // 0x1004812
    return result;
}

// Address range: 0x1004820 - 0x100483c
int32_t function_1004820(void) {
    // 0x1004820
    int32_t v1; // 0x1004820
    return v1 + 0x6aa3261a;
}

// Address range: 0x100483e - 0x1004841
int32_t function_100483e(int32_t a1) {
    // 0x100483e
    int32_t result; // 0x100483e
    return result;
}

// Address range: 0x100484b - 0x1004a4d
int32_t function_100484b(int32_t a1) {
    // 0x100484b
    int32_t v1; // 0x100484b
    int32_t v2 = v1 >> 31 & -0xff01 | 0x4600; // 0x1004858
    uint32_t v3; // 0x100484b
    uint32_t v4 = v2 + v3; // 0x100485c
    *(int32_t *)v3 = v4;
    int32_t v5 = v1 & -0xff01 | 0x3600; // 0x1004860
    if (v4 < v3) {
        v5 = function_100480b();
    }
    int32_t v6 = v5 & -0x43288772; // 0x1004863
    __asm_int(106);
    int32_t v7 = v3 - 1; // 0x100486a
    int32_t v8 = v6; // 0x100486a
    if (v7 != 0) {
        v8 = function_1004812();
    }
    // 0x100486c
    int32_t v9; // 0x100484b
    __asm_into(v9);
    int32_t v10; // 0x100484b
    int32_t v11; // 0x100484b
    if (v6 < 0) {
        int32_t v12 = *(int32_t *)0x3b9eaceb + v7; // 0x100487d
        char * v13 = (char *)(v11 - 0x11854d24); // 0x1004880
        *v13 = *v13 | (char)v12;
        int32_t * v14 = (int32_t *)(v10 + 0x5c762e06); // 0x100488f
        *v14 = *v14 ^ v12;
        __asm_hlt();
        __asm_into(v9);
        return *(int32_t *)(v10 - 8) & 2048 | -2245;
    }
    uint32_t v15 = v11 & -256; // 0x10048b6
    *(int32_t *)-0x120540fc = v15;
    int32_t v16; // 0x100484b
    *(int32_t *)(v16 - 4) = *(int32_t *)(v10 - 4);
    int32_t v17 = v16 - 8 + (int32_t)(v15 > 0x9e5798c2) - *(int32_t *)(v16 - 85); // 0x10048d0
    int64_t v18; // 0x100484b
    __asm_pavgw(v18, *(int64_t *)0x3b9eacee);
    int32_t v19 = __asm_sti(); // 0x10048de
    int32_t v20 = (v19 & 14) > 9 ? v19 + 6 : v19; // 0x10048df
    int32_t v21 = v20 & 15; // 0x10048df
    int32_t v22 = v19 & -0x10000; // 0x10048df
    int32_t v23 = 256 * (int32_t)((v19 & 14) > 9) + v19 & 0xff00; // 0x10048df
    int32_t v24 = v17; // bp-47, 0x10048e0
    float80_t v25; // 0x100484b
    int16_t v26; // 0x100484b
    if ((v19 & 14) <= 9) {
        int32_t v27; // 0x100484b
        if ((v20 & 14) > 9) {
            v27 = v23 | v22 | v21 + 6;
        } else {
            v27 = v23 | v22 | v21;
        }
        int32_t v28 = 256 * (int32_t)(v15 < 0x974d8edd) | v8 & 0x4f00059 | -0x4f0095a; // 0x10048c5
        uint32_t v29 = v27;
        int16_t v30; // 0x100484b
        v24 = v30;
        __asm_outsb((int16_t)v2, *(char *)(v10 - 8));
        int32_t v31 = v2 & -0xba00; // 0x1004958
        int32_t * v32 = (int32_t *)(v28 - 0x3b5a856a); // 0x100495d
        uint32_t v33 = *v32; // 0x100495d
        *v32 = v33 / 0x2000000 | 128 * v33;
        uint32_t v34 = v3 - 2; // 0x1004969
        if (v34 == 0 || v17 == 1) {
            // 0x100496b
            __asm_outsb(-2247, *(char *)-0x50ef4ac7);
            return v28 & 0xbfa1300 | v28 + 8 & 136 | -0xbfa1b89;
        }
        char * v35 = (char *)((v31 | -0x50ef4ac7) + 0x7885a9c8); // 0x10049ae
        char v36 = *v35 ^ -69; // 0x10049ae
        *v35 = v36;
        if (v36 == 0) {
            // 0x10049b3
            *(float64_t *)v34 = (float64_t)v25;
            return (int32_t)(36 - *(char *)((v31 | 1) - 67)) | -0x29ea4500;
        }
        // 0x10049c9
        unknown_7442a2a4(v26);
        int32_t v37 = *(int32_t *)0x458c7d3c; // 0x10049d4
        *(int32_t *)0x458c7d3c = v37 | (int32_t)&v24;
        uint32_t v38 = *(int32_t *)-0x7a64f57a; // 0x10049db
        *(int32_t *)-0x7a64f57a = 0x8000 * v38 | v38 / 0x40000;
        int32_t v39 = v34 / 2 | 0x80000000 * v34; // 0x10049e6
        int32_t v40 = (v34 & 1) == 0 ? 95 : 96; // 0x1004947
        __asm_out_6(252, (char)(v29 + v40 + (int32_t)(v29 < 0x1b6a666c)) - 1);
        int32_t v41 = 0x5d6b0346; // bp-53, 0x10049f6
        int32_t v42 = unknown_3777e730(g64, 0x5d6b0346, -2247); // 0x1004a12
        char * v43 = (char *)v39; // 0x1004a1e
        *v43 = (char)v42 + 1 + *v43;
        int32_t v44; // 0x100484b
        int32_t * v45; // 0x100484b
        if (g92 == -0x50ef4ac6) {
            // 0x10049c9
            v44 = v41;
            v45 = &v41;
        } else {
            int32_t v46 = 0x5b0111; // bp-65, 0x1004a2c
            v44 = 0x5b0111;
            v45 = &v46;
        }
        int32_t * v47 = (int32_t *)v39; // 0x1004a3c
        int32_t v48 = *v47 + v44; // 0x1004a3c
        *v47 = v48;
        int32_t result = v44; // 0x1004a3e
        if (v48 != 0) {
            // 0x1004a40
            *v45 = 5;
            result = function_1004a4d((int32_t)&g125);
        }
        // 0x1004a47
        *(int32_t *)(v17 - 1) = *(int32_t *)-0x50ef4ac6;
        return result;
    }
    int32_t v49 = *(int32_t *)(v2 - 0x21006544); // 0x10048e5
    *(int32_t *)(v17 + (int32_t)((v19 & 14) > 9) - v49) = v23 | v22 | v21;
    char * v50 = (char *)(v2 - 0x5df1ae11); // 0x10048ec
    *v50 = *v50 + 44;
    __asm_wait();
    int32_t v51 = v24 + 1; // 0x10048ff
    int32_t v52 = unknown_f21cbaee(v26); // 0x1004900
    int32_t v53 = v51; // 0x1004909
    int32_t result2 = v52 & -256 | (int32_t)__asm_in_1(65); // 0x1004909
    int32_t v54 = 0x1000000 * v7 / 0x1000000; // 0x1004909
    int32_t v55; // bp-16, 0x100484b
    int32_t v56 = &v55; // 0x1004909
    int32_t v57 = -0x29ea44dc; // 0x1004909
    int32_t v58 = v51; // 0x1004909
    while (v53 != 0) {
        int32_t v59 = v56;
        int32_t v60 = v54;
        __asm_out_6(52, (char)result2);
        int32_t v61 = v59 - 4; // 0x1004911
        int32_t * v62 = (int32_t *)v61;
        *v62 = v59;
        int32_t v63 = __asm_wait(); // 0x1004915
        unsigned char v64 = (char)v60 & 31; // 0x1004916
        if (v64 != 0) {
            char * v65 = (char *)(v63 + 63); // 0x1004916
            *v65 = *v65 << v64;
        }
        int32_t v66 = *(int32_t *)(result2 + 69) & v57; // 0x1004912
        *(int32_t *)v58 = v63;
        int32_t * v67 = v62; // 0x100491a
        int32_t v68 = v63; // 0x100491a
        v54 = 0;
        int32_t v69 = v61; // 0x100491a
        v57 = v66;
        if (v60 != 0) {
            // 0x100491c
            *(int32_t *)(v59 - 6) = v66 + 0x1e91fc8d;
            v69 = v59 - 10;
            v67 = (int32_t *)v69;
            *v67 = v63;
            v68 = v60;
            v54 = __asm_emms();
            v57 = v63;
        }
        // 0x100492d
        result2 = v68;
        int32_t v70 = *v67; // 0x100492d
        *(int64_t *)v70 = (int64_t)v25;
        v53 = v70 / 2;
        v56 = v69 + 8;
        v58 -= 4;
        if ((v70 & 1) == 0) {
            // break -> 0x100493c
            break;
        }
    }
    // 0x100493c
    return result2;
}

// Address range: 0x1004a4d - 0x1004a62
int32_t function_1004a4d(int32_t a1) {
    // 0x1004a4d
    int32_t v1; // 0x1004a4d
    int32_t * v2 = (int32_t *)(v1 + 0x14dbd35); // 0x1004a58
    int32_t v3; // 0x1004a4d
    *v2 = *v2 + v3;
    int32_t v4; // 0x1004a4d
    bool v5; // 0x1004a4d
    return (v4 - (v5 ? 57 : 56) & 255 | v4 & -256) + v1;
}

// Address range: 0x1004a78 - 0x1004b20
int32_t function_1004a78(int32_t a1) {
    // 0x1004a78
    unknown_fb005a50();
    int32_t v1 = __asm_wait(); // 0x1004a8c
    int32_t v2; // 0x1004a78
    int32_t v3 = v2 + 1; // 0x1004a8d
    if (v3 == 0) {
        // 0x1004a9b
        return v1 & -256 | (int32_t)*(char *)0x460df883;
    }
    int32_t v4 = __asm_int1(); // 0x1004b06
    char * v5 = (char *)v4; // 0x1004b07
    *v5 = *v5 ^ (char)v4;
    int32_t v6; // 0x1004a78
    int32_t v7; // 0x1004a78
    char * v8 = (char *)((v7 ^ v6) + 0x1890c5b); // 0x1004b09
    *v8 = *v8 + (char)v3;
    return function_d6783ab();
}

// Address range: 0x1004b28 - 0x1004b2d
int32_t function_1004b28(void) {
    // 0x1004b28
    return function_8c7bd7c0();
}

// Address range: 0x1004b48 - 0x1004e7d
int32_t function_1004b48(int16_t a1, int32_t a2) {
    // 0x1004b48
    int32_t v1; // 0x1004b48
    int32_t v2; // 0x1004b48
    int32_t v3 = v1 + 1 + v2; // 0x1004b4a
    unsigned char v4 = (char)v3 - 1; // 0x1004b4b
    int32_t v5; // 0x1004b48
    *(int32_t *)(*(int32_t *)(v5 + 12) + 122) = v3 & -256 | (int32_t)v4;
    int32_t v6; // 0x1004b48
    if (v4 != 0) {
        int32_t v7 = *(int32_t *)0x585a60b3; // 0x1004b5f
        int32_t v8 = *(int32_t *)(v7 + 4); // 0x1004b62
        int32_t v9; // 0x1004b48
        __asm_rep_movsb_memcpy((char *)v9, (char *)v7, v8 + 1 & 3);
        int32_t v10 = unknown_bc33bd6f(v5 + 59, *(int32_t *)(v5 + 23)); // 0x1004b92
        int32_t * v11 = (int32_t *)(v10 - 24); // 0x1004b97
        *v11 = *v11 + 1;
        *(char *)-0x588a0100 = *(char *)-0x588a0100 ^ (char)v10;
        *(int32_t *)(v5 - 8) = v6 + 141 & 255 | v6 & -256;
        int32_t result = function_100bbd4(); // 0x1004ba8
        if (result == -0x17000004) {
            // 0x1004e78
            return unknown_fd34377d();
        }
        // 0x1004c11
        return result;
    }
    int32_t v12 = *(int32_t *)(v5 + 32); // 0x1004b65
    char * v13 = (char *)(v6 + 0x175103d); // 0x1004be6
    char v14 = *v13 + (char)v12; // 0x1004be6
    *v13 = v14;
    int32_t result2 = v12; // 0x1004bee
    if (v14 != 0) {
        result2 = function_13b4e95();
    }
    // 0x1004bf4
    __asm_out_4(66, result2);
    if (*(int32_t *)0x28016484 == v6) {
        // 0x1004c11
        return result2;
    }
    // 0x1004c04
    unknown_fb0102e1(*(int32_t *)(v5 + 79));
    return function_96004a19();
}

// Address range: 0x1004e7e - 0x1004e84
int32_t function_1004e7e(void) {
    // 0x1004e7e
    int32_t result; // 0x1004e7e
    return result;
}

// Address range: 0x1004e85 - 0x1004e8c
int32_t function_1004e85(void) {
    // 0x1004e85
    int32_t result; // 0x1004e85
    *(char *)result = 2 * (char)result;
    return result;
}

// Address range: 0x1004e8c - 0x1005081
int32_t function_1004e8c(void) {
    // 0x1004e8c
    int32_t v1; // 0x1004e8c
    int32_t v2 = v1 + 89; // 0x1004e8c
    int32_t v3; // 0x1004e8c
    int32_t v4 = v3 + 1; // 0x1004e8f
    int32_t * v5 = (int32_t *)v2; // 0x1004e90
    int32_t v6 = *v5 + v4; // 0x1004e90
    *v5 = v6;
    int32_t v7; // 0x1004e8c
    int16_t v8 = v7; // 0x1004e92
    __asm_out(v8, (char)v4);
    int32_t v9; // 0x1004e8c
    if (v6 != 0) {
        // 0x1004e95
        return unknown_d74ab2(v9);
    }
    char * v10 = (char *)(v3 - 0x8fefeb2); // 0x1004ea1
    unsigned char v11 = *v10; // 0x1004ea1
    *v10 = v11 / 2 | 128 * v11;
    unknown_d5dd81c();
    *(int32_t *)(v9 - 0x17a27614) = v2;
    int32_t v12; // 0x1004e8c
    *(char *)(v12 - 41) = 5;
    function_100548f((int32_t)&g125);
    int32_t v13 = v12 + 12; // 0x1004ec7
    int32_t * v14 = (int32_t *)v13;
    uint32_t v15 = v12 + 1;
    int32_t * v16 = (int32_t *)(v9 + 4);
    bool v17 = (v11 & 1) != v11 / 128; // 0x1004ec2
    int32_t v18; // 0x1004e8c
    int32_t v19 = v18;
    uint32_t v20 = v2;
    int32_t v21 = v19 - 4; // 0x1004ec7
    *(int32_t *)v21 = *v14;
    int32_t v22 = function_1007bd1(); // 0x1004eca
    int32_t v23; // 0x1004e8c
    while (false != v17) {
        int32_t v24 = v20 + v7 & 255 | v20 & -256; // 0x1004f25
        bool v25 = (v12 & 15) == 15 | (v22 & 14) > 9; // 0x1004f28
        int32_t v26 = v25 ? v22 + 6 : v22; // 0x1004f28
        *(int32_t *)((v26 & 15 | v22 & -0x10000 | 256 * (int32_t)v25 + v22 & 0xff00) - 88) = 0;
        *(int32_t *)(v19 - 8) = *(int32_t *)(*v16 - 99);
        v17 = (v15 & (v12 ^ -0x80000000)) < 0;
        if (v15 <= 0) {
            // 0x1004f3e
            __asm_outsb(v8, *(char *)&v23);
            char v27 = __asm_in_3(v8); // 0x1004f45
            int32_t v28 = *(int32_t *)(*v16 + 3); // 0x1004f4b
            uint32_t v29 = 4 * v24 + 12; // 0x1004f4e
            uint32_t v30 = v29 / 4; // 0x1004f57
            __asm_rep_movsd_memcpy((char *)v28, (char *)(v9 & -256 | (int32_t)v27), v30);
            bool v31; // 0x1004e8c
            int32_t v32 = v28 + v30 * (v31 ? -4 : 4); // 0x1004f5a
            int32_t v33 = v29 & -44; // 0x1004f5e
            char * v34 = (char *)v32; // 0x1004f62
            __asm_rep_movsb_memcpy(v34, v34, v33);
            int32_t v35 = v32 + v33 * (v31 ? -1 : 1); // 0x1004f62
            v23 = v35;
            *(int32_t *)(v19 - 12) = v13;
            function_100be29((int32_t)&g125);
            *(int864_t *)(v12 - 47) = (int864_t)__asm_fnsave();
            int32_t v36 = v35 & v7; // 0x1004f77
            int32_t * v37 = (int32_t *)(v12 - 20); // 0x1004fd3
            *(int32_t *)(v19 - 16) = *(int32_t *)(*v37 - 19);
            function_1007bc1((int32_t)&g125);
            int32_t v38 = *(int32_t *)(v12 - 73); // 0x1004fe0
            int32_t * v39 = (int32_t *)(v38 - 109); // 0x1004fe3
            *v39 = *v39 & 69;
            *(int32_t *)(v19 - 20) = *(int32_t *)(v38 + 111);
            *(int32_t *)(*v37 + 4) = v38;
            int32_t v40 = *(int32_t *)(*v14 + 4); // 0x1004ffe
            v23 = v40;
            int32_t v41 = *v37; // 0x1005004
            int32_t v42 = *(int32_t *)(v41 - 128); // 0x1005007
            char * v43 = (char *)v41; // 0x100500f
            *v43 = *v43 + (char)v41;
            int32_t * v44 = (int32_t *)(*(int32_t *)(v40 - 54) - 0x5a0cfd18); // 0x1005012
            uint32_t v45 = *v44; // 0x1005012
            *v44 = v45 / 2048 | 0x200000 * v45;
            *(int32_t *)(v19 - 24) = -0x1ef3a5f4;
            int32_t * v46 = (int32_t *)(v9 + 0x27003a2c + 8 * v40); // 0x1005021
            *v46 = v19 - 0x45a5 + *v46;
            int32_t v47 = v19 - 0x45a9; // 0x1005028
            int16_t v48 = v36; // 0x100502d
            char v49 = __asm_in_3(v48); // 0x100502d
            *(int32_t *)v47 = 256 * (int32_t)((v41 & 14) > 9) + v41 & 0xff00 | v41 & -0x10000 | (int32_t)v49;
            function_100be30();
            int32_t v50 = *(int32_t *)(v19 - 151); // 0x1005034
            *(int32_t *)(v19 - 0x45ad) = v50;
            int64_t v51 = v50; // 0x100503d
            int64_t v52 = -124 * v51; // 0x100503d
            int32_t v53 = v52; // 0x100503d
            int32_t * v54 = (int32_t *)(v53 - 0x8fefefa); // 0x1005040
            *v54 = *v54 - 1;
            int32_t v55 = ((v52 == -0x7c00000000 * v51 / 0x100000000 ? 0 : 255) | v53 & -256) - 44; // 0x100504c
            *(int32_t *)(v19 - 47) = v55;
            *(char *)-0x17af17e1 = (char)v55;
            __asm_in_3(v48);
            __asm_hlt();
            unknown_5a00be0a();
            *(int32_t *)(v19 - 51) = *(int32_t *)(v42 - 20);
            char * v56 = (char *)(v42 + 117 + 8 * v42); // 0x100506f
            *v56 = *v56 + (char)v36;
            unknown_510c9605();
            int32_t result = unknown_3200bd6f(); // 0x1005078
            *(int32_t *)(v19 - 55) = *(int32_t *)(v42 + 12);
            *(int32_t *)(v19 - 59) = (v9 & 0xff00) + v9 & 0xff00 | v9 & -0xff01;
            return result;
        }
        v19 = v21;
        v20 = v24;
        v21 = v19 - 4;
        *(int32_t *)v21 = *v14;
        v22 = function_1007bd1();
    }
    uint32_t v57 = v20 / 256; // 0x1004edb
    int32_t result2 = v20 - 1; // 0x1004edd
    int32_t v58 = (v22 + 0x7aa8ffde & -256 | v57 & 255) ^ 255; // 0x1004edd
    int32_t v59; // 0x1004e8c
    if (result2 == 0 || (char)v57 == -1) {
        // 0x1004edf
        *(int32_t *)(v19 - 8) = *v16;
        *(char *)0x308b0374 = (char)v9 | -119;
        __asm_int(56);
        v58 = v9 | 141;
        v59 = *(int32_t *)v9;
    }
    char * v60 = (char *)v58; // 0x1004f0b
    *v60 = *v60 + (char)v58;
    int32_t v61; // 0x1004e8c
    *(char *)v61 = *(char *)(v23 + v59);
    return result2;
}

// Address range: 0x1005082 - 0x10050e6
int32_t function_1005082(void) {
    // 0x1005082
    int32_t v1; // 0x1005082
    __asm_into(v1);
    int32_t v2 = unknown_b72b946c(); // 0x1005088
    int32_t v3; // 0x1005082
    char * v4 = (char *)(v3 - 0xff179b); // 0x100508d
    *v4 = *v4 + (char)v2;
    int32_t v5 = v2 & 23 | 232; // 0x1005093
    char * v6 = (char *)(v5 | v2 & -256); // 0x1005098
    *v6 = *v6 + (char)v5;
    int32_t v7; // 0x1005082
    *(int32_t *)(v7 + 12) = 0;
    return function_1ae14e0c(*(int32_t *)(v7 - 20));
}

// Address range: 0x10050e6 - 0x10050f2
int32_t function_10050e6(void) {
    // 0x10050e6
    int32_t v1; // 0x10050e6
    int32_t v2; // 0x10050e6
    return function_1012670(v2) & v1;
}

// Address range: 0x10050f4 - 0x10050fa
int32_t function_10050f4(void) {
    // 0x10050f4
    return 0x1005db2;
}

// Address range: 0x1005132 - 0x1005133
int32_t function_1005132(void) {
    // 0x1005132
    int32_t result; // 0x1005132
    return result;
}

// Address range: 0x1005145 - 0x1005147
int32_t function_1005145(void) {
    // 0x1005145
    return function_1005132();
}

// Address range: 0x1005148 - 0x100514f
int32_t function_1005148(void) {
    // 0x1005148
    return unknown_4c2c0();
}

// Address range: 0x100514f - 0x100526a
int32_t function_100514f(int16_t a1) {
    // 0x100514f
    bool v1; // 0x100514f
    bool v2; // 0x100514f
    bool v3; // 0x100514f
    bool v4; // 0x100514f
    bool v5; // 0x100514f
    bool v6; // 0x100514f
    bool v7; // 0x100514f
    bool v8; // 0x100514f
    bool v9; // 0x100514f
    bool v10; // 0x100514f
    int32_t v11 = 0x4000 * (int32_t)v6 | 2048 * (int32_t)v7 | 1024 * (int32_t)v8 | 512 * (int32_t)v9 | 256 * (int32_t)v10 | 128 * (int32_t)v1 | 64 * (int32_t)v2 | 16 * (int32_t)v3 | (int32_t)v5 | 4 * (int32_t)v4 | 2; // bp-4, 0x100514f
    int32_t v12; // 0x100514f
    int32_t * v13 = (int32_t *)(v12 + 117); // 0x1005152
    *v13 = *v13 + (int32_t)&v11;
    int32_t v14 = function_1005132(); // 0x100515b
    if (v14 == 0) {
        // 0x1005172
        return 0;
    }
    int32_t v15 = g39; // 0x1005164
    int32_t v16; // 0x100514f
    if (v15 != 0 != v15 >= 0) {
        // 0x1005179
        return *(int32_t *)(8 * v16 + 0x24643e4f);
    }
    unsigned char v17 = (char)v14; // 0x10051a4
    uint32_t v18; // 0x100514f
    unsigned char v19 = v17 + (char)(v18 / 256); // 0x10051a4
    unsigned char v20 = v19 + 48 + (char)(v19 < v17); // 0x10051a6
    *(char *)v16 = *(char *)&v16 | v20;
    int32_t v21 = v14 & -256 | (int32_t)v20; // 0x10051a8
    int32_t result = v16;
    v21 += 65;
    int32_t v22; // 0x100514f
    int32_t v23; // 0x100514f
    while (result >= v21) {
        // 0x10051b9
        int32_t v24; // 0x100514f
        int32_t v25 = v24;
        uint32_t v26 = (v25 & 0xff00) + result;
        if (result == v21) {
            // 0x10051e1
            v16 = result;
            __writefsdword(result, __readfsdword(result) + result);
            int32_t v27; // 0x100514f
            char * v28 = (char *)(v27 + 73 + result); // 0x10051ea
            *v28 = *v28 + (char)(v26 / 256);
            return result;
        }
        if (result == 0xb5b68c) {
            // 0x1005249
            v16 = 0;
            v22 = 0;
            v23 = 125;
            goto lab_0x1005249_2;
        }
        int32_t v29 = result - 0xb5b68d; // 0x10051c3
        v24 = v26 & 0xff00 | v25 & -0xff01;
        if (v29 != 0) {
            // 0x10051c6
            v16 = v29;
            char * v30 = (char *)(result - 0x2f6bf519); // 0x10051ca
            *v30 = *v30 + (char)v25;
            v22 = v16;
            v23 = 123;
            goto lab_0x1005249_2;
        }
        result = 0;
        v21 += 65;
    }
    // 0x1005179
    v16 = result;
    // 0x1005179
    return *(int32_t *)(8 * result + 0x24643e4f);
  lab_0x1005249_2:;
    // 0x1005249
    uint32_t v31; // 0x100514f
    char * v32 = (char *)(v31 - 0x45fbdbf1); // 0x100524c
    int32_t v33 = v22; // 0x1005249
    int32_t v34 = v23; // 0x1005249
    goto lab_0x100524a;
  lab_0x100524a:;
    int32_t v35 = v34;
    *v32 = *v32 + (char)v33;
    __asm_out_6(235, (char)v35);
    int32_t result2 = *(int32_t *)(v35 - 47) + v35; // 0x1005254
    int32_t v36 = v16; // 0x100525d
    int32_t v37 = v36 / 2; // 0x100525d
    v16 = v37;
    v33 = 0;
    v34 = result2;
    if (v36 >= 2) {
        // 0x1005261
        *(char *)(v37 + 0x40fb78f9) = (char)(v31 / 256);
        return result2;
    }
    goto lab_0x100524a;
}

// Address range: 0x100526a - 0x10052a9
int32_t function_100526a(void) {
    // 0x100526a
    int32_t v1; // 0x100526a
    if (v1 != 0) {
        // 0x100526c
        return function_100526a();
    }
    // 0x1005299
    abort();
    // UNREACHABLE
}

// Address range: 0x10052a9 - 0x10052b2
int32_t function_10052a9(void) {
    // 0x10052a9
    int32_t result; // 0x10052a9
    return result;
}

// Address range: 0x10052b2 - 0x10052b8
int32_t function_10052b2(int32_t a1, int32_t a2) {
    // 0x10052b2
    return unknown_165abdd();
}

// Address range: 0x100530e - 0x1005313
int32_t function_100530e(void) {
    // 0x100530e
    return function_8ca64615();
}

// Address range: 0x1005322 - 0x1005323
int32_t function_1005322(void) {
    // 0x1005322
    int32_t result; // 0x1005322
    return result;
}

// Address range: 0x1005330 - 0x1005335
int32_t function_1005330(void) {
    // 0x1005330
    return function_5fc52ca();
}

// Address range: 0x100535e - 0x1005363
int32_t function_100535e(void) {
    // 0x100535e
    return function_8ca64665();
}

// Address range: 0x1005380 - 0x1005418
int32_t function_1005380(int32_t a1) {
    int32_t v1 = a1;
    int32_t v2; // 0x1005380
    *(char *)v2 = 0;
    int32_t v3; // 0x1005380
    char * v4 = (char *)(v3 - 0xc3900e4); // 0x1005382
    char v5 = v3; // 0x1005382
    *v4 = *v4 + v5;
    uint32_t v6; // 0x1005380
    int32_t * v7 = (int32_t *)(v6 + 0x458b0020); // 0x100538d
    int32_t v8 = *v7; // 0x100538d
    int32_t v9 = v8 + 1; // 0x100538d
    *v7 = v9;
    int32_t result = v2 & -0x74ffff96; // 0x1005393
    if (v9 < 0 == (v9 & (v8 ^ -0x80000000)) < 0) {
        result = function_1005322();
    }
    uint32_t v10 = v6 / 256; // 0x1005395
    if ((char)(2 * v10 ^ v10) >= 0) {
        // 0x1005399
        return result;
    }
    int32_t v11 = 512 * v10 & 0xfe00 | v6 & -0xff01; // 0x1005395
    char * v12 = (char *)(v11 - 0x74fee7f5); // 0x100539d
    *v12 = *v12 + v5;
    int32_t * v13 = (int32_t *)v11; // 0x10053aa
    int32_t v14; // 0x1005380
    int32_t v15 = v14 + 4; // 0x10053bb
    int32_t v16 = *(int32_t *)(*v13 - 0x5fd163f) & 3; // 0x10053be
    int32_t v17; // 0x1005380
    __asm_rep_movsb_memcpy((char *)v15, (char *)(v17 + 4), v16);
    int32_t v18 = v16 + v15; // 0x10053c1
    function_100d1c1();
    int32_t v19 = *(int32_t *)(*(int32_t *)(*(int32_t *)0x44e8a87 + 4) + 4); // 0x10053d9
    int32_t v20; // 0x1005380
    int32_t v21 = unknown_1027bfb(v19, v18, v18, 0x44e8b05, &v1, v11, v20 & -256 | 112, 0, *v13); // 0x10053dc
    *(int32_t *)(*v13 + 91) = v21;
    int32_t v22 = *(int32_t *)(*(int32_t *)0x44e8b65 + 4); // 0x10053e9
    int32_t v23 = *v13; // 0x10053ef
    int32_t v24 = *(int32_t *)(v23 + 81); // 0x10053f1
    uint32_t v25 = *(int32_t *)0x44e8b07; // 0x10053fd
    *(int32_t *)0x44e8b07 = v25 / 0x2000000 | 128 * v25;
    *(int32_t *)v24 = *(int32_t *)v22;
    uint32_t v26 = v22 + 4; // 0x1005401
    int32_t v27 = v23 & -0xff01 | 0xe100; // 0x1005404
    uint32_t v28 = v26 + v11; // 0x1005406
    *(char *)(v24 + 4) = *(char *)v28;
    unsigned char v29 = (char)v23; // 0x100540e
    bool v30 = v29 > 153 | v28 < v26;
    int32_t result2; // 0x1005380
    if ((v29 & 14) > 9 || (v26 & 15) + (v6 & 15) > 15) {
        result2 = (v30 ? 102 : 6) + v23 & 255 | v27 & -0x1f00;
    } else {
        result2 = (v30 ? v23 + 96 : v23) & 255 | v27 & -0x1f00;
    }
    char * v31 = (char *)result2; // 0x100540f
    *v31 = *v31 + (char)result2;
    return result2;
}

// Address range: 0x1005418 - 0x100546b
int32_t function_1005418(int32_t a1, int32_t a2) {
    // 0x1005418
    if (g4 != (char *)10) {
        // 0x1005441
        int32_t v1; // 0x1005418
        *(int32_t *)v1 = v1 + 1;
        int32_t v2; // 0x1005418
        return function_1007cfa(v2, *(int32_t *)0x1010450, a2);
    }
    // 0x1005421
    int32_t v3; // 0x1005418
    unknown_1ff8a62(a1, v3);
    int32_t result = *(int32_t *)function_100bc54(); // 0x100543a
    int32_t * v4 = (int32_t *)result; // 0x100543c
    *v4 = -*v4;
    return result;
}

// Address range: 0x100546c - 0x100547d
int32_t function_100546c(void) {
    // 0x100546c
    int32_t v1; // 0x100546c
    int32_t result = __asm_in_5((int16_t)v1); // 0x100546c
    int32_t v2; // 0x100546c
    int32_t * v3 = (int32_t *)(v2 + 1); // 0x100546d
    uint32_t v4; // 0x100546c
    *v3 = *v3 - v4;
    int32_t v5; // 0x100546c
    char * v6 = (char *)(v2 - 67 + 16 * v5); // 0x1005474
    *v6 = *v6 | (char)(v4 / 256);
    int32_t v7; // 0x100546c
    *(char *)v7 = *(char *)&v7 + (char)v4;
    return result;
}

// Address range: 0x100547d - 0x100548f
int32_t function_100547d(void) {
    // 0x100547d
    int32_t v1; // 0x100547d
    int32_t v2; // 0x100547d
    *(int32_t *)v1 = v2 + v1;
    int32_t v3; // 0x100547d
    return function_1011502(*(int32_t *)(2 * v3 + 77 + v2));
}

// Address range: 0x100548f - 0x10054a4
int32_t function_100548f(int32_t a1) {
    // 0x100548f
    int32_t v1; // 0x100548f
    int32_t v2; // 0x100548f
    int32_t v3; // 0x100548f
    int32_t v4; // 0x100548f
    return unknown_2aba81cc(a1, v1, v2, v4, v3);
}

// Address range: 0x10054d1 - 0x10054d2
int32_t function_10054d1(int32_t a1) {
    // 0x10054d1
    int32_t result; // 0x10054d1
    return result;
}

// Address range: 0x1005517 - 0x100552e
int32_t function_1005517(void) {
    // 0x1005517
    return function_c0a64830();
}

// Address range: 0x100553d - 0x1005540
int32_t function_100553d(void) {
    // 0x100553d
    int32_t result; // 0x100553d
    return result;
}

// Address range: 0x1005546 - 0x1005549
int32_t function_1005546(int32_t a1) {
    // 0x1005546
    int32_t result; // 0x1005546
    return result;
}

// Address range: 0x1005563 - 0x1005575
int32_t function_1005563(void) {
    // 0x1005563
    int32_t v1; // 0x1005563
    *(char *)v1 = 2 * (char)v1;
    int32_t result; // 0x1005563
    return result;
}

// Address range: 0x10055a7 - 0x10055b8
int32_t function_10055a7(void) {
    // 0x10055a7
    int32_t v1; // 0x10055a7
    char * v2 = (char *)(v1 - 0x176f00fd); // 0x10055a7
    unsigned char v3 = *v2; // 0x10055a7
    unsigned char v4 = v3 + (char)v1; // 0x10055a7
    *v2 = v4;
    int32_t v5; // 0x10055a7
    char v6 = *(char *)&v5; // 0x10055ad
    uint32_t v7; // 0x10055a7
    *(char *)v5 = v6 + (char)(v7 / 256) + (char)(v4 < v3);
    int32_t v8; // 0x10055a7
    int32_t v9; // 0x10055a7
    *(char *)v8 = *(char *)&v8 + (char)v9;
    return function_8b308903();
}

// Address range: 0x10055e8 - 0x100565b
int32_t function_10055e8(int32_t a1) {
    // 0x10055e8
    int32_t v1; // 0x10055e8
    unsigned char v2 = (char)v1; // 0x10055ea
    char v3 = v2 - 4; // 0x10055ea
    char v4 = llvm_ctpop_i8(v3); // 0x10055ea
    unknown_12c7b5f();
    int32_t v5; // 0x10055e8
    char * v6 = (char *)(v5 + 0x408bfc45); // 0x10055f6
    int32_t v7; // 0x10055e8
    *v6 = *v6 + (char)v7;
    int32_t v8 = *(int32_t *)((v5 & -0x10000 | v5 + 4 & 255 | 256 * (64 * (int32_t)(v3 == 0) | (int32_t)(v2 < 4) | 128 * (int32_t)(v3 < 0) | 16 * (int32_t)((v2 & 15) > 19) | 4 * (int32_t)((v4 & 1) == 0)) | 512) - 19); // 0x10055fd
    int32_t v9 = unknown_12007bfb(v8); // 0x1005600
    uint32_t v10 = v7 + 1; // 0x1005608
    int32_t v11 = v9 + 139 & 255 | v9 & -256; // 0x1005609
    bool v12; // 0x10055e8
    int32_t v13 = v12 ? -4 : 4; // 0x100560c
    int32_t v14 = *(int32_t *)(v11 + 4); // 0x1005615
    char * v15 = (char *)(4 * v10 + 12); // 0x1005618
    *v15 = *v15 | -117;
    int32_t v16; // 0x10055e8
    *(int32_t *)v14 = *(int32_t *)(v13 + v16);
    __asm_rep_movsb_memcpy((char *)(v14 + v13), (char *)v11, v10 / 0x800000 | 512 * v10);
    int32_t v17 = function_1007bd1(); // 0x1005630
    *(int32_t *)0x850000 = 73;
    *(int32_t *)0x84fffc = 0;
    *(int32_t *)0x84fff8 = *(int32_t *)0x1046394;
    uint32_t v18; // 0x10055e8
    return (v17 | 0x14dcb35) + 0x1001117 | (int32_t)(2 * v18 < v18);
}

// Address range: 0x100565b - 0x1005a26
int32_t function_100565b(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    int32_t v1 = 0x10000 * a2;
    int32_t v2 = v1 / 0x10000; // 0x100566e
    char * v3 = (char *)v2; // 0x1005673
    char v4 = v2;
    *v3 = *v3 + v4;
    char v5 = v4; // 0x100567a
    int32_t v6 = v2; // 0x100567a
    if (v1 == 0x1100000) {
        v6 = function_bd0057b9();
        v5 = v6;
    }
    uint32_t v7 = v6;
    int32_t v8; // 0x100565b
    char v9 = *(char *)(v8 + 1); // 0x1005680
    int32_t v10 = 256 * (int32_t)(v9 + (char)(v7 / 256)) | v7 & -0xff01; // 0x1005680
    char * v11 = (char *)v10; // 0x1005683
    char v12 = *v11 + v5; // 0x1005683
    *v11 = v12;
    int32_t v13 = v10; // 0x1005685
    if (v12 == 0) {
        v13 = function_1985792();
    }
    // 0x100568b
    int32_t v14; // 0x100565b
    if (v13 == 0x240189) {
        // 0x1005698
        function_1655726();
        goto lab_0x100569e;
    } else {
        if (v13 < 0x24018a) {
            goto lab_0x100569e;
        } else {
            // 0x10056a5
            v14 = function_1005a73((int32_t)&g125, (int32_t)&g125);
            goto lab_0x10056b0;
        }
    }
  lab_0x100569e:;
    int32_t v15 = function_3b0059bb(); // 0x1005698
    if (v15 < 306) {
        // 0x10056cb
        return *(int32_t *)0x240189 & -256 | 208;
    }
    // 0x10056a5
    v14 = v15;
    if (v15 != 317) {
        // 0x10056a5
        v14 = function_1005a73((int32_t)&g125, (int32_t)&g125);
        goto lab_0x10056b0;
    } else {
        goto lab_0x10056b0;
    }
  lab_0x10056b0:;
    int32_t v16 = v14;
    float80_t v17; // 0x100565b
    *(int32_t *)(v8 + 83) = (int32_t)v17;
    int32_t v18 = v16; // bp-548, 0x10056c0
    int32_t result = unknown_d6007b0e(v16, *(int32_t *)0x5101af98, v16); // 0x10056c1
    int32_t v19; // 0x100565b
    if (v19 != -v8) {
        // 0x10059df
        return result;
    }
    // 0x10059e7
    int32_t v20; // bp-5, 0x100565b
    int32_t v21 = &v20; // 0x10059e7
    int32_t v22 = &v18; // 0x10059e8
    int32_t v23; // 0x100565b
    uint32_t v24 = v22 & -256 | (int32_t)(*(char *)&v23 + (char)v22); // 0x10059ec
    uint32_t v25 = v24 + v21; // 0x10059ee
    *(int32_t *)(result - 4) = *(int32_t *)-0x70feb2a5;
    int32_t v26 = (249 * v25 / 256 + v25 & 255 | v25 & -0x10000) + (v25 < v24 ? 0x100087b : 0x100087a); // 0x1005a02
    if (*(int32_t *)0x40014db8 == 0x27fdf085) {
        // 0x10059a1
        *(int32_t *)(result - 8) = v26;
        *(int32_t *)(result - 12) = v21;
        *(int32_t *)(result - 16) = 273;
        *(int32_t *)(result - 20) = *(int32_t *)0x101056c;
        return __asm_hlt();
    }
    // 0x1005a0f
    if (g40 == -86) {
        // 0x1005a18
        *(int32_t *)(result - 8) = v26;
        uint32_t v27; // 0x100565b
        return lstrlenW((int16_t *)(v27 / 0x80000000 | 2 * v27));
    }
    int32_t result2 = __asm_sti(); // 0x100599d
    *(int32_t *)(result - 10) = 0x27fdf085;
    return result2;
}

// Address range: 0x1005a26 - 0x1005a2a
int32_t function_1005a26(void) {
    // 0x1005a26
    int32_t result; // 0x1005a26
    return result;
}

// Address range: 0x1005a73 - 0x1005a76
int32_t function_1005a73(int32_t a1, int32_t a2) {
    // 0x1005a73
    int32_t result; // 0x1005a73
    return result;
}

// Address range: 0x1005a76 - 0x1005a7a
int32_t function_1005a76(void) {
    // 0x1005a76
    int32_t result; // 0x1005a76
    return result;
}

// Address range: 0x1005a7a - 0x1006051
int32_t function_1005a7a(int32_t a1, int32_t a2) {
    // 0x1005a7a
    unknown_1a92650();
    int32_t v1; // 0x1005a7a
    int32_t v2 = v1 & -256 | 127; // 0x1005a8e
    char * v3 = (char *)(v2 + 0x6078583); // 0x1005aa5
    *v3 = *v3 + 127;
    int32_t v4; // 0x1005a7a
    int32_t v5; // 0x1005a7a
    int32_t v6; // 0x1005a7a
    int32_t v7 = unknown_fb846a05(0, v5, v4, v6); // 0x1005ab1
    int32_t * v8 = (int32_t *)v2; // 0x1005ab6
    *v8 = *v8 + v6;
    char * v9 = (char *)(v7 + 20); // 0x1005ab8
    *v9 = *v9 + 127;
    char * v10 = (char *)v7; // 0x1005abe
    *v10 = *v10 + (char)v7;
    int32_t v11 = v7 - 1; // 0x1005ac0
    int32_t v12 = v11; // 0x1005ac1
    if (v11 == 0) {
        v12 = function_101120a((int32_t)&g125);
    }
    // 0x1005ac7
    if (v12 != 1) {
        // 0x1006049
        *(int32_t *)-0x7bf0ff14 = *(int32_t *)-0x7bf0ff14 - 62;
        return __asm_sti();
    }
    // 0x1005ace
    int32_t v13; // 0x1005a7a
    int32_t v14 = v13 + 1; // 0x1005a90
    int32_t v15; // 0x1005a7a
    int32_t v16 = v15 - 1; // 0x1005a9f
    int16_t v17 = 257 * v16 & 0xff00 | v16 & 255; // 0x1005ad8
    __asm_in_3(v17);
    function_1007bc1((int32_t)(float32_t)(float64_t)(int64_t)function_1007c26());
    char * v18 = (char *)(v6 - 0xff74fd); // 0x1005af2
    *v18 = *v18 ^ (char)*(int32_t *)12;
    int32_t v19; // bp+16751, 0x1005a7a
    int32_t v20 = 0x12191dfc * *(int32_t *)(2 * v14 + (int32_t)&v19); // 0x1005af8
    char * v21 = (char *)(v20 - 0x5474fbb2); // 0x1005b07
    *v21 = *v21 ^ (char)v16;
    char v22 = __asm_in_3(v17); // 0x1005b0d
    int32_t v23 = v6 + 3213; // 0x1005b10
    char * v24 = (char *)(v6 + 0x2e9c1c1); // 0x1005b16
    *v24 = *v24 + (char)v23;
    __asm_rep_movsd_memcpy((char *)v14, (char *)v6, v23);
    int32_t v25 = ((v19 & 1024) == 0 ? 4 : -4) * v23 + v14; // 0x1005b1c
    *(int32_t *)(v25 - 0x1b1e7c14) = v25;
    return v20 & -256 | (int32_t)v22;
}

// Address range: 0x1006059 - 0x1006067
int32_t function_1006059(void) {
    // 0x1006059
    int32_t v1; // 0x1006059
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x1006059
    *(int32_t *)(v2 - 20) = 0x7c000000;
    return unknown_a25c15();
}

// Address range: 0x1006083 - 0x1006086
int32_t function_1006083(int32_t a1) {
    // 0x1006083
    int32_t v1; // 0x1006083
    return v1 | 232;
}

// Address range: 0x100608d - 0x100611b
int32_t function_100608d(int32_t a1) {
    // 0x100608d
    uint32_t v1; // 0x100608d
    uint32_t v2 = v1 / 256; // 0x1006090
    bool v3; // 0x100608d
    char v4 = v3; // 0x1006090
    char v5 = 2 * (char)v2 | v4; // 0x1006090
    if (v5 == 0) {
        // 0x1006094
        int16_t v6; // 0x100608d
        return unknown_5c13(v6);
    }
    // 0x10060a0
    int32_t v7; // 0x100608d
    int16_t v8 = v7; // 0x10060a0
    char v9 = __asm_in_3(v8); // 0x10060a0
    if ((v5 + v4 ^ (char)v2) >= 0) {
        // 0x1006117
        int32_t v10; // 0x100608d
        uint32_t v11 = v10 & -256 | (int32_t)v9; // 0x10060a0
        int32_t v12; // 0x100608d
        char * v13 = (char *)(v12 - 117); // 0x1006117
        *v13 = *v13 + (char)(v11 / 256);
        return v11 & -256 | (int32_t)__asm_in_3(v8);
    }
    // 0x10060a3
    __asm_ud0();
    function_1007bd1();
    int32_t v14; // 0x100608d
    *(int32_t *)(v14 - 20) = 0x43390000;
    return 0x1007a15;
}

// Address range: 0x100611c - 0x1006177
int32_t function_100611c(void) {
    // 0x100611c
    int32_t v1; // 0x100611c
    char v2 = __asm_in_3((int16_t)v1); // 0x100611c
    int32_t v3; // 0x100611c
    int32_t v4 = v3 & -256 | (int32_t)v2; // 0x100611c
    int32_t v5; // 0x100611c
    char * v6 = (char *)(v5 + 86); // 0x100611d
    unsigned char v7 = *v6; // 0x100611d
    unsigned char v8 = v7 + (char)v1; // 0x100611d
    bool v9; // 0x100611c
    unsigned char v10 = v8 + (char)v9; // 0x100611d
    bool v11 = v9 ? v10 <= v7 : v8 < v7; // 0x100611d
    *v6 = v10;
    *(int32_t *)-0x45c7f068 = *(int32_t *)-0x45c7f068 + 2 + (int32_t)v11;
    char * v12 = (char *)v4; // 0x100612b
    char v13 = *v12 + v2; // 0x100612b
    *v12 = v13;
    int32_t v14 = v4; // 0x100612d
    if (v13 == 0) {
        v14 = function_11e6336();
    }
    int32_t v15 = v14 + 0x151840f; // 0x1006135
    int64_t v16; // 0x100611c
    int64_t v17; // 0x100611c
    __asm_psubb(v16, v17);
    char * v18 = (char *)v15; // 0x1006142
    char v19 = v15; // 0x1006142
    *v18 = *v18 + v19;
    char * v20 = (char *)(v5 - 0x77f0bb3f); // 0x1006144
    *v20 = *v20 + v19;
    *(int32_t *)-0x7cdbb4b2 = v15;
    *(char *)-0x52221beb = v19;
    function_1007b0e(0x10000 * v15 / 0x10000, g31);
    int32_t result = function_1006521((int32_t)&g125, (int32_t)&g125, (int32_t)&g125); // 0x1006172
    return result;
}

// Address range: 0x1006177 - 0x10061a1
int32_t function_1006177(void) {
    // 0x1006177
    int32_t v1; // 0x1006177
    if (*(int32_t *)(*(int32_t *)(v1 + 20) + 8) != -12) {
        function_dc826521();
    }
    // 0x1006187
    int32_t v2; // 0x1006177
    int32_t v3; // 0x1006177
    *(int32_t *)v2 = unknown_905132(v3);
    return function_1006201(-72);
}

// Address range: 0x10061a1 - 0x1006201
int32_t function_10061a1(void) {
    // 0x10061a1
    int32_t v1; // 0x10061a1
    unsigned char v2 = (char)v1; // 0x10061a4
    int32_t v3; // 0x10061a1
    unsigned char v4 = *(char *)(v3 + 0xd603d3) + v2; // 0x10061a4
    unsigned char v5 = v4 + (char)(v1 == 0); // 0x10061a4
    bool v6 = v1 == 0 ? v5 <= v2 : v4 < v2; // 0x10061a4
    int32_t v7 = v1 & -256 | (int32_t)v5; // 0x10061a4
    int32_t v8; // 0x10061a1
    int32_t v9 = *(int32_t *)(v8 + 24); // 0x10061aa
    char * v10 = (char *)v7; // 0x10061ad
    unsigned char v11 = *v10; // 0x10061ad
    unsigned char v12 = v11 + v5; // 0x10061ad
    unsigned char v13 = v12 + (char)v6; // 0x10061ad
    bool v14 = v6 ? v13 <= v11 : v12 < v11; // 0x10061ad
    *v10 = v13;
    char * v15 = (char *)(v9 - 41); // 0x10061b3
    uint32_t v16; // 0x10061a1
    *v15 = *v15 + (char)(v16 / 256) + (char)v14;
    char * v17 = (char *)(v7 - 119); // 0x10061b8
    unsigned char v18 = *v17; // 0x10061b8
    *v17 = v18 - v5;
    char * v19 = (char *)(v9 + 0x49109d04); // 0x10061bc
    uint32_t v20; // 0x10061a1
    *v19 = *v19 + (char)v20 + (char)(v18 < v5);
    uint32_t v21 = v7 + v20; // 0x10061c2
    *(int32_t *)v20 = v21;
    *(int32_t *)(v3 + 21) = v7;
    int32_t result = v7; // 0x10061c7
    if (v21 == 0) {
        // 0x10061d3
        int32_t v22; // 0x10061a1
        result = unknown_fc724d(v9, v7, &v22);
    }
    // 0x10061d9
    uint32_t v23; // 0x10061a1
    uint32_t v24 = 2 * v23; // 0x10061d9
    uint32_t v25 = v24 | (int32_t)(v21 < v20); // 0x10061d9
    bool v26 = v21 < v20 ? v25 <= v23 : v24 < v23; // 0x10061d9
    int32_t v27; // bp-16, 0x10061a1
    if (v25 != 0 && !v26) {
        int32_t v28 = v16 + (int32_t)&v27; // 0x10061e5
        *(int32_t *)(v28 - 4) = result;
        *(int32_t *)(v28 - 8) = -1;
        return result;
    }
    unsigned char v29 = (char)result; // 0x10061ed
    unsigned char v30 = v29 + (char)!v26; // 0x10061ed
    int32_t v31 = result & -256 | (int32_t)v30; // 0x10061ef
    if (v30 == 0 || (v26 ? v30 <= v29 : v29 != 0)) {
        v31 = function_1006201((int32_t)&g125);
    }
    int32_t v32 = v31;
    int32_t v33 = v32 & -256 | (int32_t)*(char *)((v32 & 255) + v9); // 0x10061f8
    if (v30 != 0) {
        v33 = function_1006252();
    }
    int32_t v34 = v33;
    int32_t v35; // 0x10061a1
    v27 = *(int32_t *)(v35 + 16);
    return v34 & -256 | (int32_t)*(char *)((v34 & 255) + v9);
}

// Address range: 0x1006201 - 0x1006220
int32_t function_1006201(int32_t a1) {
    uint32_t v1 = a1 - 1; // 0x1006202
    unsigned char v2 = *(char *)-0x7c624cd; // 0x1006205
    unsigned char v3 = v2 + (char)(v1 / 256); // 0x1006205
    *(char *)-0x7c624cd = v3;
    bool v4; // 0x1006201
    return a1 + 115 + (v4 ? 252 : 253) + (int32_t)(v3 < v2) & 255 | v1 & -256;
}

// Address range: 0x1006221 - 0x100624e
int32_t function_1006221(int32_t a1) {
    // 0x1006221
    uint32_t v1; // 0x1006221
    bool v2; // 0x1006221
    if ((char)(v1 / 256) + (char)v1 != (char)v2) {
        // 0x100623e
        __asm_wait();
        return g47;
    }
    int32_t v3 = (int32_t)*(char *)-0x3affee; // 0x1006223
    int32_t v4; // 0x1006221
    int32_t result = v4 & -256 | v3; // 0x100622e
    if ((v3 & 192) != 0) {
        result = function_734ac721();
    }
    // 0x1006234
    return result;
}

// Address range: 0x1006252 - 0x100626a
int32_t function_1006252(void) {
    // 0x1006252
    uint32_t v1; // 0x1006252
    bool v2; // 0x1006252
    *(int32_t *)v1 = 2 * v1 | (int32_t)v2;
    int32_t v3; // 0x1006252
    int32_t * v4 = (int32_t *)(v3 + 0x14dec1d); // 0x1006254
    uint32_t v5 = *v4; // 0x1006254
    uint32_t v6 = v5 + v3; // 0x1006254
    *v4 = v6;
    int32_t v7; // 0x1006252
    int32_t v8; // 0x1006252
    *(char *)v7 = __asm_insb((int16_t)v8);
    int32_t v9; // 0x1006252
    int32_t * v10 = (int32_t *)(v9 + 108); // 0x100625b
    *v10 = *v10 - 1;
    uint32_t v11 = v1 + v3; // 0x100625f
    uint32_t result = v11 + (int32_t)(v6 < v5); // 0x100625f
    int32_t * v12 = (int32_t *)(v9 - 0x4eff17ff); // 0x1006264
    *v12 = *v12 + result + (int32_t)(v6 < v5 ? result <= v1 : v11 < v1);
    return result;
}

// Address range: 0x100629e - 0x10062a1
int32_t function_100629e(void) {
    // 0x100629e
    int32_t v1; // 0x100629e
    int32_t v2; // 0x100629e
    return v2 + v1;
}

// Address range: 0x10062d1 - 0x10062d2
int32_t function_10062d1(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x10062d1
    int32_t result; // 0x10062d1
    return result;
}

// Address range: 0x10062e7 - 0x10063cd
int32_t function_10062e7(int16_t a1, int16_t a2) {
    struct tagPOINT Point; // 0x100636d
    // 0x10062e7
    int32_t v1; // 0x10062e7
    int32_t * v2 = (int32_t *)(v1 - 1); // 0x10062e7
    uint32_t v3 = *v2; // 0x10062e7
    int32_t v4; // 0x10062e7
    uint32_t v5 = v3 + v4; // 0x10062e7
    *v2 = v5;
    int32_t v6; // 0x10062e7
    int32_t v7 = v6 + v1 + (int32_t)(v5 < v3); // 0x10062ec
    int32_t v8; // 0x10062e7
    int32_t v9; // 0x10062e7
    int32_t * v10 = (int32_t *)(4 * v8 - 0x38a7482 + v9); // 0x10062ee
    uint32_t v11; // 0x10062e7
    int32_t v12 = *v10 + v11; // 0x10062ee
    *v10 = v12;
    int32_t v13; // 0x10062e7
    int32_t * v14 = (int32_t *)(v13 + 16); // 0x10062f5
    uint32_t v15 = *v14; // 0x10062f5
    *v14 = v15 / 2048 | 0x200000 * v15;
    int32_t v16 = v7; // 0x10062fa
    bool v17 = (v15 & 1024) == 0; // 0x10062fa
    int32_t result4; // 0x10062e7
    int32_t v18; // 0x10062e7
    int32_t v19; // 0x10062e7
    int32_t v20; // 0x10062e7
    if (v12 == 0) {
        goto lab_0x100635d;
    } else {
        // 0x1006300
        __asm_hlt();
        int32_t v21 = 22; // bp-12, 0x1006316
        int32_t result = *(int32_t *)(v7 - 7) + 0x535350f0 ^ (int32_t)&g46; // 0x1006326
        char * v22 = (char *)(result - 0x1663ffef); // 0x100632c
        char v23 = *v22 + (char)(v11 / 256); // 0x100632c
        *v22 = v23;
        if (v23 == 0) {
            // 0x1006334
            return result;
        }
        char * v24 = (char *)(v13 - 0x2a5eefa2); // 0x1006335
        *v24 = *v24 + (char)v11;
        int32_t v25 = *(int32_t *)0x3d8bbc3b + v4; // 0x100633c
        *(int32_t *)0x3d8bbc3b = v25;
        v21 = v7;
        result4 = result;
        int32_t v26; // bp-28, 0x10062e7
        v20 = &v26;
        v18 = &v21;
        if (v25 != 0) {
            goto lab_0x100638b;
        } else {
            // 0x1006348
            v19 = a2;
            int32_t v27; // bp-13, 0x10062e7
            v16 = &v27;
            v17 = (char)result < 56;
            goto lab_0x100635d;
        }
    }
  lab_0x100635d:;
    int32_t v28 = __asm_int3(); // 0x100635d
    char * v29 = (char *)(v28 + v19); // 0x100635e
    *v29 = (char)v17 + (char)v4 + *v29;
    int32_t v30 = *(int32_t *)(v16 - 8); // bp-44, 0x1006364
    uint16_t v31; // 0x10062e7
    int32_t * hWndParent = (int32_t *)(int32_t)v31; // bp-48, 0x1006367
    int32_t * v32 = (int32_t *)v19; // 0x100636b
    *v32 = *v32 + v28;
    Point = (struct {int32_t e0; int32_t e1;}){
        .e0 = 0,
        .e1 = 0
    };
    Point.e0 = v30;
    int32_t * v33 = ChildWindowFromPoint(hWndParent, Point); // 0x100636d
    int32_t result2 = (int32_t)v33; // 0x100636d
    if (v33 == NULL) {
        // 0x1006334
        return result2;
    }
    // 0x1006379
    int32_t result3; // 0x10063cb
    if (v33 == (int32_t *)g46) {
        // 0x10063c5
        *(int32_t *)((int32_t)&v30 - 4) = 123;
        result3 = DefWindowProcW(&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125);
        return result3;
    }
    // 0x1006381
    hWndParent = (int32_t *)(result2 & 0xffff);
    int32_t v34 = (int32_t)&hWndParent; // 0x1006381
    result4 = result2;
    v20 = v34;
    v18 = v16 - 1;
    if (v33 == (int32_t *)-1) {
        // 0x10063c5
        *(int32_t *)(v34 - 4) = 123;
        result3 = DefWindowProcW(&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125);
        return result3;
    }
    goto lab_0x100638b;
  lab_0x100638b:
    // 0x100638b
    *(int32_t *)(v20 - 4) = *(int32_t *)(v18 + 20);
    *(int32_t *)(v20 - 8) = *(int32_t *)-0x48feb5b8;
    return result4;
}

// Address range: 0x10063cd - 0x10063f2
int32_t function_10063cd(void) {
    // 0x10063cd
    int32_t v1; // 0x10063cd
    uint32_t v2; // 0x10063cd
    *(int32_t *)v2 = v2 ^ v1;
    int32_t v3; // 0x10063cd
    int32_t v4 = v3;
    *(int32_t *)v4 = 2 * v4;
    int32_t v5; // 0x10063cd
    int32_t v6; // 0x10063cd
    char * v7 = (char *)(v6 & v5); // 0x10063d3
    *v7 = *v7 + (char)v2;
    int32_t v8; // 0x10063cd
    char * v9 = (char *)(v8 - 0x7bf0d800); // 0x10063d7
    *v9 = *v9 + (char)(v2 / 256);
    int32_t v10 = v3;
    *(char *)v10 = *(char *)&v3 + (char)v10;
    int32_t v11; // 0x10063cd
    char * v12 = (char *)(v11 - 0x278bfa4a); // 0x10063e0
    *v12 = *v12 + (char)v3;
    uint32_t v13 = v3; // 0x10063e6
    int32_t v14 = v13 + 101; // 0x10063e6
    v3 = v14;
    int32_t v15 = v14; // 0x10063e9
    if (v14 == 0) {
        v15 = function_1006400();
        v3 = v15;
    }
    int32_t v16 = v15;
    return v16 + (v13 < 0xffffff9b ? 0 : 255) & 255 | v16 & -256;
}

// Address range: 0x10063f2 - 0x1006400
int32_t function_10063f2(int32_t * hWnd, int32_t Msg, int32_t wParam, int32_t lParam) {
    // 0x10063f2
    return DefWindowProcW(hWnd, Msg, wParam, lParam);
}

// Address range: 0x1006400 - 0x10064a7
int32_t function_1006400(void) {
    // 0x1006400
    int32_t v1; // 0x1006400
    GetDlgCtrlID((int32_t *)*(int32_t *)(v1 + 20));
    char * v2 = (char *)(v1 + 51); // 0x100640d
    unsigned char v3 = *v2; // 0x100640d
    uint32_t v4; // 0x1006400
    unsigned char v5 = v3 + (char)(v4 / 256); // 0x100640d
    *v2 = v5;
    int32_t * v6 = GetSysColorBrush(5); // 0x1006412
    int32_t color = (int32_t)v6; // 0x1006412
    if (v5 < v3) {
        // 0x10064a1
        return color;
    }
    // 0x1006428
    uint32_t v7; // 0x1006400
    unsigned char v8 = (char)(v7 / 256); // 0x1006424
    char v9 = v5 < v3; // 0x1006424
    unsigned char v10 = v9 + v8; // 0x1006424
    bool v11 = v5 < v3 ? (char)(v5 < v3) - v9 > v8 | v10 != -1 : v10 > v8; // 0x1006424
    int32_t v12 = *v6 - 1; // 0x1006428
    *v6 = v12;
    *(char *)v6 = (char)v11 + (char)v4 + (char)v12;
    char * v13 = (char *)(color - 0x2900f7bd); // 0x100642c
    *v13 = *v13 + (char)color;
    SetTextColor((int32_t *)*(int32_t *)(v1 - 41), color);
    if ((*(int32_t *)(color + 0xdfe9) & 0x7f00) != 0) {
        // 0x1006473
        return function_1146521();
    }
    int32_t hWnd = *(int32_t *)(v1 - 45); // 0x1006446
    int32_t result = DefWindowProcW((int32_t *)hWnd, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125); // 0x100644e
    return result;
}

// Address range: 0x10064a7 - 0x100650a
int32_t function_10064a7(void) {
    // 0x10064a7
    uint32_t v1; // 0x10064a7
    uint16_t v2 = *(int16_t *)(v1 + 0x144d2b5e); // 0x10064ac
    int32_t v3; // 0x10064a7
    uint32_t v4; // 0x10064a7
    *(char *)v3 = (char)(v4 / 256) + (char)v3 + (char)(v2 < 117);
    int32_t v5; // 0x10064a7
    int32_t * v6 = (int32_t *)(v5 - 91); // 0x10064bb
    int32_t v7; // 0x10064a7
    *v6 = *v6 + v7;
    *(int32_t *)(v5 + 20) = -0x68ffff93;
    if ((v4 & -0x10000) == 0x10000) {
        int32_t v8 = v4 / 0x10000 + (2 * v1 < v1 ? -0x36ffee9a : -0x36ffee9b); // 0x10064d7
        char * v9 = (char *)(v8 + 255 & 255 | v8 & -0x36fe0100); // 0x10064f6
        *v9 = *v9 + (char)v4;
        __asm_iretd();
        int32_t hWnd = *(int32_t *)(v5 + 16); // 0x10064fe
        SendMessageW((int32_t *)hWnd, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125);
    }
    // 0x1006503
    return unknown_669d();
}

// Address range: 0x1006521 - 0x100652a
int32_t function_1006521(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1006521
    int32_t v1; // 0x1006521
    return v1 | 192;
}

// Address range: 0x1006538 - 0x1006543
int32_t function_1006538(void) {
    // 0x1006538
    return function_1006564((int32_t)&g125);
}

// Address range: 0x1006564 - 0x1006568
int32_t function_1006564(int32_t a1) {
    // 0x1006564
    int32_t result; // 0x1006564
    return result;
}

// Address range: 0x1006580 - 0x100658c
int32_t function_1006580(void) {
    // 0x1006580
    int32_t v1; // 0x1006580
    int32_t * v2 = (int32_t *)(v1 + 0x11701d); // 0x1006580
    *v2 = *v2 - 1;
    int32_t v3; // 0x1006580
    int32_t v4; // 0x1006580
    *(int32_t *)v3 = v4 + v3;
    int32_t v5; // 0x1006580
    return &v5;
}

// Address range: 0x1006597 - 0x100659e
int32_t function_1006597(void) {
    // 0x1006597
    return function_6319e274();
}

// Address range: 0x10065a4 - 0x10065a5
int32_t function_10065a4(void) {
    // 0x10065a4
    int32_t result; // 0x10065a4
    return result;
}

// Address range: 0x10065e3 - 0x100660d
int32_t function_10065e3(int32_t a1) {
    // 0x10065e3
    int32_t v1; // 0x10065e3
    uint32_t v2 = v1 & 31; // 0x10065f1
    if (v2 != 0) {
        int32_t v3; // 0x10065e3
        unsigned char v4 = (char)v3; // 0x10065e3
        int32_t v5; // 0x10065e3
        bool v6; // 0x10065e3
        unsigned char v7 = *(char *)(v5 + 0x5e6a3ec6) + (char)v6; // 0x10065e3
        int32_t * v8 = (int32_t *)(v5 - 1); // 0x10065f1
        uint32_t v9 = *v8; // 0x10065f1
        bool v10 = v6 ? v7 != -1 | (char)v6 + v4 - v7 > v4 : v7 > v4; // 0x10065e3
        *v8 = v9 << v2 | (int32_t)((int64_t)v9 >> (int64_t)(33 - v2)) | (int32_t)v10 << v2 - 1;
    }
    int32_t v11; // 0x10065e3
    char * v12 = (char *)(8 * v11 + 95 + v1); // 0x10065fb
    *v12 = *v12 - 116;
    g116 = g4;
    return (int32_t)g4;
}

// Address range: 0x100660d - 0x1006626
int32_t function_100660d(int32_t a1, int32_t a2) {
    // 0x100660d
    return a2 & 0xffff;
}

// Address range: 0x1006626 - 0x1006777
int32_t function_1006626(int32_t a1) {
    // 0x1006626
    int32_t v1; // bp-20, 0x1006626
    uint32_t v2; // 0x1006626
    uint32_t v3; // 0x1006626
    uint32_t v4; // 0x1006626
    if (a1 != 10) {
        // 0x1006682
        if (g49 != 0) {
            // 0x1006695
            *(char *)-0x5cfe9594 = *(char *)-0x5cfe9594 - (char)(v3 / 256);
            return g49;
        }
        // 0x10066a2
        int32_t v5; // 0x1006626
        int32_t v6 = v5 - 0xec138ca; // 0x100668b
        v1 = v6;
        int32_t v7; // 0x1006626
        int32_t v8; // 0x1006626
        unknown_ffa4f303(0, 310, 313, v6, 0, v5, v7, v8);
        int32_t v9 = g38; // bp-48, 0x10066b6
        *(int32_t *)0x1001242 = *(int32_t *)0x1001242 + 1;
        int32_t v10 = v6 != 10; // 0x10066d9
        uint32_t v11 = *(int32_t *)1 + v10; // 0x10066d9
        uint32_t v12 = v4 - v11; // 0x10066d9
        bool v13 = v6 != 10 ? v11 != -1 | v4 < v12 - v10 : v4 < v11; // 0x10066d9
        uint32_t v14 = v12 + 78 + (int32_t)v13; // 0x10066db
        char * v15 = (char *)(v2 - 1); // 0x10066e5
        *v15 = *v15 - (char)v3;
        *(int32_t *)v3 = (int32_t)&v9;
        int32_t * v16 = (int32_t *)v14; // 0x10066eb
        *v16 = (v13 ? v14 <= v12 : v12 > 0xffffffb1 ? -0x73e7dbba : -0x73e7dbbb) & *v16;
        int32_t v17 = unknown_ce77c0cf(v9, 310, 313, v6) + 0x10011f6; // 0x10066f1
        return v17 & -256 | (int32_t)*(char *)((v17 & 255) + v2);
    }
    // 0x100663b
    int32_t v18; // 0x1006626
    __asm_out_4(1, v18 & -256 | 128);
    int32_t v19; // 0x1006626
    int32_t v20 = v19 + 334; // 0x1006644
    char v21 = __asm_in_3((int16_t)v3); // 0x100664c
    unsigned char v22 = v21 & 24; // 0x100664e
    int32_t v23 = (v18 | (int32_t)v21) & -256 | (int32_t)v22; // 0x100664e
    int32_t v24 = v23; // 0x1006650
    int32_t v25; // bp-12, 0x1006626
    int32_t * v26 = &v25; // 0x1006650
    int32_t v27 = v20; // 0x1006650
    int32_t v28; // 0x1006626
    if (v22 != 0) {
        // 0x1006652
        v1 = *(int32_t *)421;
        uint32_t v29 = v20 + v2; // 0x1006657
        int32_t * v30 = (int32_t *)v2; // 0x1006657
        *v30 = v29;
        *v30 = *(int32_t *)v20;
        bool v31; // 0x1006626
        int32_t v32 = v31 ? -4 : 4; // 0x1006659
        v24 = v23 - 0x745ee84 | (int32_t)(v29 < v2);
        v26 = &v1;
        v27 = v20 + v32;
        v28 = v32 + v2;
    }
    int32_t v33 = (int32_t)v26;
    char * v34 = (char *)(v27 + 0x1f4be); // 0x1006660
    *v34 = *v34 + 1;
    int32_t * v35 = (int32_t *)(v24 - 65); // 0x1006666
    *v35 = *v35 | v4;
    char * v36 = (char *)v24; // 0x100666b
    *v36 = *v36 + (char)v24;
    *(int32_t *)(v33 - 3) = v28;
    *(int32_t *)(v33 - 7) = g50;
    bool v37 = CheckMenuRadioItem(&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125); // 0x1006674
    int32_t result = v37; // 0x1006674
    if ((result & 0x4000) == 0) {
        // 0x100667d
        return result & -256 | (int32_t)__asm_in_1(49);
    }
    // 0x10066a1
    return result;
}

// Address range: 0x1006793 - 0x100683d
int32_t function_1006793(char a1) {
    // 0x1006793
    int32_t v1; // 0x1006793
    int32_t v2 = v1 - 1; // 0x1006795
    bool v3; // 0x1006793
    if (v2 == 0 || v3) {
        // 0x1006797
        int32_t result; // 0x1006793
        return result;
    }
    uint32_t v4 = v2 & 31; // 0x1006799
    uint32_t v5; // 0x1006793
    if (v4 != 0) {
        *(int32_t *)v5 = v5 >> v4;
    }
    int32_t v6; // 0x1006793
    int32_t v7; // 0x1006793
    *(int32_t *)v7 = v7 + v6;
    int32_t v8; // bp-4, 0x1006793
    int32_t nIDFirstButton = &v8; // 0x100679d
    int32_t v9 = *(int32_t *)347; // 0x10067a8
    int16_t v10 = v5; // 0x10067ad
    int32_t v11; // 0x1006793
    __asm_outsb(v10, *(char *)&v11);
    char v12 = *(char *)((v7 ^ nIDFirstButton) + 0x2602fffb); // 0x10067ae
    int32_t result2 = v2 & -256 | (int32_t)(v12 + (char)v2); // 0x10067ae
    int32_t * v13 = (int32_t *)result2; // 0x10067bb
    int32_t v14 = *v13; // 0x10067bb
    int32_t v15 = v14 + v9; // 0x10067bb
    *v13 = v15;
    int32_t v16 = unknown_f2126626(v11, -0x750086ff); // 0x10067be
    if (((v15 ^ v14) & (v15 ^ v9)) >= 0) {
        int32_t hWnd = v16 + 96; // 0x100681d
        *v13 = *v13 + (hWnd & -256 | v16 + 100 & 255);
        *(int32_t *)-0x4feb0a1 = (int32_t)HideCaret((int32_t *)hWnd);
        return function_1006856();
    }
    int32_t nIDCheckButton = v16 & -256 | (int32_t)__asm_in_3(v10); // 0x10067ca
    if (v15 < 0 != ((v15 ^ v14) & (v15 ^ v9)) < 0) {
        // 0x10067cc
        nIDCheckButton = (int32_t)GetMenu(NULL);
    }
    // 0x10067d6
    *(char *)0x1001108 = *(char *)0x1001108 + (char)v5;
    int32_t nIDLastButton; // 0x1006793
    *(int32_t *)nIDLastButton = nIDCheckButton;
    CheckRadioButton((int32_t *)*(int32_t *)0x1c9fa6c, nIDFirstButton, nIDLastButton, nIDCheckButton);
    g119 = v11;
    unknown_56005291();
    function_10065a4();
    function_10045c4((int32_t)&g125);
    return result2;
}

// Address range: 0x100683d - 0x1006843
int32_t function_100683d(void) {
    // 0x100683d
    int32_t result; // 0x100683d
    return result;
}

// Address range: 0x1006856 - 0x1006859
int32_t function_1006856(void) {
    // 0x1006856
    int32_t v1; // 0x1006856
    __asm_into(v1);
    int32_t result; // 0x1006856
    *(char *)result = (char)result;
    return result;
}

// Address range: 0x1006859 - 0x1006893
int32_t function_1006859(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x1006859
    uint32_t v1; // 0x1006859
    int32_t v2 = v1 + 0x64ec6eec; // 0x100685a
    int32_t v3; // 0x1006859
    int32_t * v4 = (int32_t *)(v3 + 4); // 0x1006861
    *v4 = *v4 - 1;
    int32_t * v5 = (int32_t *)v2; // 0x1006864
    *v5 = v2 + (int32_t)(v1 > 0x9b139113) + *v5;
    int32_t v6; // 0x1006859
    int32_t result = v6 - 99; // 0x100687b
    int32_t * v7 = (int32_t *)result; // 0x100688e
    *v7 = *v7 + result;
    int32_t * v8 = (int32_t *)(v3 - 61); // 0x1006890
    int32_t v9; // 0x1006859
    *v8 = *v8 + v9;
    return result;
}

// Address range: 0x1006893 - 0x1006a54
int32_t function_1006893(int32_t a1) {
    // 0x1006893
    int32_t v1; // 0x1006893
    if (v1 == a1) {
        // 0x1006904
        return g47;
    }
    // 0x100689d
    abort();
    // UNREACHABLE
}

// Address range: 0x1006a55 - 0x1006aab
int32_t function_1006a55(int32_t a1) {
    // 0x1006a55
    bool v1; // 0x1006a55
    if (v1) {
        function_1036cb2();
    }
    // 0x1006a61
    g104--;
    int32_t v2; // 0x1006a55
    int64_t v3; // 0x1006a55
    __asm_pmaddwd(v3, *(int64_t *)(v2 + 1));
    int32_t v4 = *(int32_t *)0x1974300; // 0x1006a7f
    if (v4 < *(int32_t *)0x30c0b7e5) {
        // 0x1006a8d
        return (v4 + 1 & 0xffff) - 1;
    }
    // 0x1006a89
    return -0x30c4fffe;
}

// Address range: 0x1006abd - 0x1006abe
int32_t function_1006abd(void) {
    // 0x1006abd
    int32_t result; // 0x1006abd
    return result;
}

// Address range: 0x1006b26 - 0x1006bbc
int32_t function_1006b26(void) {
    // 0x1006b26
    uint32_t v1; // 0x1006b26
    int32_t v2 = g66 + v1; // 0x1006b2d
    int32_t v3 = *(int32_t *)*(int32_t *)(v2 + 4); // 0x1006b32
    int32_t v4; // 0x1006b26
    uint32_t v5 = *(int32_t *)(v4 - 117); // 0x1006b34
    int32_t v6 = v3 - 1;
    int32_t v7 = v2 + 139; // 0x1006b38
    char * v8 = (char *)(v7 & 255 | v2 & -256); // 0x1006b40
    *v8 = *v8 + (char)v7;
    bool v9; // 0x1006b26
    int32_t v10 = v9 ? -1 : 1;
    int32_t v11 = v6; // 0x1006b47
    int32_t v12 = v5; // 0x1006b47
    if (v5 >= 4) {
        uint32_t v13 = v5 / 4; // 0x1006b44
        v11 = v6 + v13 * v10;
        v12 = (int32_t)*(char *)(v3 + v10 * (v13 - 1) - 1);
    }
    int32_t v14 = v12 & 91; // 0x1006b4b
    int32_t v15; // 0x1006b26
    __asm_rep_movsb_memcpy((char *)v15, (char *)v11, v14);
    int32_t v16 = v14 * v10 + v15; // 0x1006b4e
    int32_t v17 = *(int32_t *)(*(int32_t *)-0x1ffeb070 + v1); // 0x1006b55
    function_1007b91(*(int32_t *)(v17 + 4));
    unsigned char v18 = *(char *)0x1012226; // 0x1006b6b
    unsigned char v19 = v18 + (char)(*(int32_t *)0x1013f18 / 256); // 0x1006b6b
    *(char *)0x1012226 = v19;
    unsigned char v20 = (char)(v1 / 256); // 0x1006b79
    char v21 = v19 < v18; // 0x1006b79
    unsigned char v22 = v21 + v20; // 0x1006b79
    unsigned char v23 = (char)(v19 < v18); // 0x1006b79
    bool v24 = v19 < v18 ? v23 - v21 > v20 | v22 != -1 : v22 > v20; // 0x1006b79
    int32_t v25 = v1 & -0xff01; // 0x1006b79
    int32_t v26 = 256 * (int32_t)v23 | v25; // 0x1006b79
    int32_t v27 = function_100cdfb(); // 0x1006b7b
    int32_t v28 = *(int32_t *)(8 * v16 - 0x5efbbe77); // 0x1006b86
    char * v29 = (char *)(v16 + 1); // 0x1006b8d
    *v29 = *v29 - (char)v28 + (char)v24;
    int32_t * v30 = (int32_t *)v26; // 0x1006b90
    *v30 = *v30 + v27;
    uint32_t result = 4 * v28 + 12; // 0x1006ba1
    char * v31 = (char *)(v26 + result); // 0x1006bad
    *v31 = v23;
    char * v32 = (char *)((256 * (int32_t)*v31 | v25) - 0x5b0cefb9); // 0x1006bb6
    *v32 = *v32 + (char)(result / 4);
    return result;
}

// Address range: 0x1006bbe - 0x1006bc3
int32_t function_1006bbe(void) {
    // 0x1006bbe
    return function_1006abd();
}

// Address range: 0x1006bc3 - 0x1006c82
int32_t function_1006bc3(void) {
    // 0x1006bc3
    int32_t v1; // 0x1006bc3
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x1006bdb
    int32_t v3 = g68; // bp-32, 0x1006be4
    *(int32_t *)0x1011318 = unknown_8101014d(g68, v2, 408, 0, *(int32_t *)0x1674d78, 388, 0, 0);
    int32_t v4; // 0x1006bc3
    int32_t v5 = v4 ^ 176; // 0x1006c05
    uint32_t v6 = *(int32_t *)v5 & v5; // 0x1006c09
    uint32_t v7; // 0x1006bc3
    char * v8 = (char *)(v7 + 0x52014f18); // 0x1006c0b
    *v8 = *v8 + (char)(v6 / 256);
    int32_t v9; // 0x1006bc3
    *(int32_t *)((v9 ^ v4) + 0x443b9d95) = (int32_t)&v3;
    int32_t v10 = v6 & -177; // 0x1006c17
    int32_t v11 = v10 + v7; // 0x1006c19
    int32_t * v12 = (int32_t *)v7; // 0x1006c19
    *v12 = v11;
    if (v11 < 0 != ((v11 ^ v7) & (v11 ^ v6)) < 0) {
        char * v13 = (char *)v10; // 0x1006c70
        *v13 = (char)(v11 < v7) + (char)v10 + *v13;
        *(int32_t *)0x50739c8d = *(int32_t *)0x50739c8d + v7;
        *v12 = v11;
        return function_944f5cfc();
    }
    int32_t v14 = GlobalUnlock((int32_t *)*(int32_t *)0x14a4f20); // 0x1006c23
    *v12 = v7 + v14;
    int32_t v15 = unknown_d3f5cb77(*(int32_t *)(v14 - 64)); // 0x1006c2f
    bool v16; // 0x1006bc3
    *(int32_t *)v15 = (v16 ? -4 : 4) + v4;
    *v12 = (v15 & -177) + v7;
    return function_1006c99();
}

// Address range: 0x1006c97 - 0x1006c99
int32_t function_1006c97(void) {
    // 0x1006c97
    int32_t result; // 0x1006c97
    return result;
}

// Address range: 0x1006c99 - 0x1006cb2
int32_t function_1006c99(void) {
    // 0x1006c99
    int32_t v1; // 0x1006c99
    int32_t v2; // 0x1006c99
    *(char *)v1 = (char)v2 + (char)v1;
    int32_t v3; // 0x1006c99
    int32_t v4; // 0x1006c99
    if (v2 == v4) {
        v3 = function_1008c45((int32_t)&g125);
    }
    // 0x1006ca8
    g68 = v3;
    return function_1006e66();
}

// Address range: 0x1006cb2 - 0x1006cbe
int32_t function_1006cb2(void) {
    // 0x1006cb2
    int32_t v1; // 0x1006cb2
    return function_28006e08(v1);
}

// Address range: 0x1006cf1 - 0x1006d37
int32_t function_1006cf1(void) {
    // 0x1006cf1
    int32_t v1; // 0x1006cf1
    char * v2 = (char *)(v1 - 125); // 0x1006cf3
    int32_t v3; // 0x1006cf1
    *v2 = *v2 + (char)v3;
    int32_t v4; // 0x1006cf1
    int32_t * v5 = (int32_t *)(v4 + 0xe284); // 0x1006cf7
    *v5 = *v5 + 1;
    uint32_t v6 = function_1007bd1(); // 0x1006d04
    int32_t v7; // 0x1006cf1
    int32_t v8 = v7 - 1; // 0x1006d0c
    uint32_t v9 = v6 / 256; // 0x1006d12
    int32_t v10 = 512 * v9 & 0xfe00 | v6 & -0xff01; // 0x1006d12
    *(int32_t *)0x1434d90 = v10;
    function_1007bc1(*(int32_t *)v10);
    *(int32_t *)(v7 - 96) = v8;
    int32_t v11; // 0x1006cf1
    char * v12 = (char *)(v11 - 83); // 0x1006d2e
    char v13 = *v12; // 0x1006d2e
    *v12 = (char)(2 * (char)v9 < (char)v9) - g9 + v13;
    __asm_wait();
    return *(int32_t *)*(int32_t *)(2 * v8 + v11);
}

// Address range: 0x1006d38 - 0x1006de0
int32_t function_1006d38(int32_t a1, int32_t result2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x1006d38
    bool v1; // 0x1006d38
    if (v1) {
        // 0x1006d3a
        int32_t result; // 0x1006d38
        return result;
    }
    // 0x1006d3e
    int32_t v2; // 0x1006d38
    int32_t v3; // 0x1006d38
    if (g53 != 0) {
        int32_t * v4 = (int32_t *)g53; // 0x1006d45
        int32_t v5; // 0x1006d38
        int32_t * v6 = (int32_t *)(v5 + 0x43000d8a); // 0x1006d4a
        int32_t v7; // 0x1006d38
        *v6 = *v6 + v7;
        int32_t v8; // 0x1006d38
        *v4 = *v4 | v8;
        uint32_t v9 = *(int32_t *)(v5 - 1); // 0x1006d52
        int32_t v10; // 0x1006d38
        *(char *)(v10 + 102 + v8) = (char)(v9 / 256);
        int32_t v11 = v8 + 161 & 255 | v8 & -256; // 0x1006d59
        *v4 = *v4 + v11;
        v2 = v11;
        v3 = v9;
    }
    char * v12 = (char *)v2; // 0x1006d65
    *v12 = *v12 + (char)v2;
    int32_t * v13 = (int32_t *)(a1 - 23); // 0x1006d69
    uint32_t v14 = *v13; // 0x1006d69
    *v13 = v14 / 0x40000000 | 4 * v14;
    char * v15; // 0x1006d38
    __asm_rep_movsd_memcpy((char *)v3, v15, a4);
    int32_t * v16 = (int32_t *)(a5 - 0x5e5a0cfd); // 0x1006d71
    *v16 = *v16 - 112;
    int32_t * v17 = (int32_t *)result2; // 0x1006d79
    *v17 = *v17 + result2;
    bool v18; // 0x1006d38
    char * v19 = (char *)(v3 + (v18 ? -4 : 4) * a4); // 0x1006d7f
    unsigned char v20 = *v19; // 0x1006d7f
    unsigned char v21 = (char)result2 & 31; // 0x1006d7f
    if (v21 != 0) {
        *v19 = v20 >> v21 | v20 << 8 - v21;
    }
    // 0x1006d3a
    return result2;
}

// Address range: 0x1006de0 - 0x1006de7
int32_t function_1006de0(void) {
    // 0x1006de0
    int32_t result; // 0x1006de0
    return result;
}

// Address range: 0x1006de7 - 0x1006e21
int32_t function_1006de7(int32_t a1) {
    int32_t v1 = unknown_4c0045c4(); // 0x1006ded
    int32_t * v2 = (int32_t *)v1; // 0x1006dfd
    int32_t v3; // 0x1006de7
    *v2 = *v2 + v3;
    uint32_t v4; // 0x1006de7
    unsigned char v5 = (char)(v4 / 256); // 0x1006e01
    g48 = v1 + 80 + (int32_t)(-1 - v5 < v5);
    return function_1006e2a(*(int32_t *)(a1 + 8), 407);
}

// Address range: 0x1006e22 - 0x1006e2a
int32_t function_1006e22(void) {
    // 0x1006e22
    int32_t v1; // 0x1006e22
    int32_t * v2 = (int32_t *)(v1 + 0x35ff0a6a); // 0x1006e24
    int32_t v3; // 0x1006e22
    *v2 = *v2 + v3;
    int32_t result; // 0x1006e22
    return result;
}

// Address range: 0x1006e2a - 0x1006e58
int32_t function_1006e2a(int32_t a1, int32_t a2) {
    // 0x1006e2a
    int32_t v1; // 0x1006e2a
    int32_t result; // 0x1006e2a
    if ((v1 & 0x7fffffff) == 0) {
        // 0x1006e31
        int32_t v2; // 0x1006e2a
        *(int32_t *)-0xebba75 = *(int32_t *)-0xebba75 ^ v2;
        return result;
    }
    int32_t * v3 = (int32_t *)(result - 33); // 0x1006e41
    int32_t v4; // 0x1006e2a
    *v3 = *v3 + v4;
    int32_t v5; // 0x1006e2a
    *(int32_t *)v5 = result + v5;
    return function_1006e66();
}

// Address range: 0x1006e58 - 0x1006e60
int32_t function_1006e58(int32_t a1) {
    // 0x1006e58
    int32_t v1; // 0x1006e58
    return &v1;
}

// Address range: 0x1006e66 - 0x1006eca
int32_t function_1006e66(void) {
    // 0x1006e66
    int32_t v1; // 0x1006e66
    int32_t * v2 = (int32_t *)(v1 - 0x3da2a4a2); // 0x1006e68
    *v2 = *v2 / 2;
    int32_t v3; // 0x1006e66
    *(int32_t *)v3 = 0;
    __asm_hlt();
    int32_t v4; // 0x1006e66
    int32_t v5 = *(int32_t *)(v4 + 8); // 0x1006e76
    char * v6 = (char *)v5; // 0x1006e83
    *v6 = *v6 + (char)v5;
    int32_t v7; // 0x1006e66
    int32_t v8; // 0x1006e66
    int32_t v9 = __asm_invd(v7, v8) | -0x7cfffff7; // 0x1006e8a
    char v10 = (char)v9 + 120; // 0x1006e8f
    if (v10 < 0) {
        // 0x1006e9b
        return function_25a16ea2();
    }
    // 0x1006eaa
    bool v11; // 0x1006e66
    int32_t v12 = (v11 ? -4 : 4) + v3; // 0x1006e71
    uint32_t v13 = v9 & -256 | (int32_t)v10; // 0x1006e8f
    int32_t * v14 = (int32_t *)v12; // 0x1006eaa
    int32_t v15 = *v14 + v12; // 0x1006eaa
    *v14 = v15;
    char * v16 = (char *)v12; // 0x1006eb0
    *v16 = *v16 + 48 + (char)(v15 * v12);
    int32_t result = __asm_iretd(); // 0x1006eb3
    int32_t * v17 = (int32_t *)(v4 - 0xc8d22e); // 0x1006eb4
    *v17 = *v17 + 1;
    *(char *)(v13 + 1) = (char)v12;
    char * v18 = (char *)result; // 0x1006ec2
    *v18 = (char)result + (char)(2 * v13 < v13) + *v18;
    int32_t * v19 = (int32_t *)(v8 - 40); // 0x1006ec4
    *v19 = *v19 + result;
    return result;
}

// Address range: 0x1006f1e - 0x1006f26
int32_t function_1006f1e(void) {
    // 0x1006f1e
    int32_t result; // 0x1006f1e
    return result;
}

// Address range: 0x1006f2f - 0x100709d
int32_t function_1006f2f(void) {
    // 0x1006f2f
    bool v1; // 0x1006f2f
    if (v1) {
        function_1009363();
    }
    // 0x1006f35
    int64_t v2; // 0x1006f2f
    uint32_t v3 = __asm_pextrw(v2, 233); // 0x1006f36
    uint32_t v4; // 0x1006f2f
    uint32_t v5 = v3 + 0x10011d5 + (int32_t)(g48 > -1 - (char)(v4 / 256)); // 0x1006f45
    bool v6 = g48 > -1 - (char)(v4 / 256) ? v5 <= v3 : v3 > 0xfeffee2a; // 0x1006f45
    *(int32_t *)0x14fc30d = v5;
    int32_t v7; // 0x1006f2f
    char * v8 = (char *)(v7 + 1); // 0x1006f5e
    int32_t v9; // 0x1006f2f
    *v8 = *v8 - (char)v9 + (char)v6;
    function_1007bd1();
    int64_t v10 = (int64_t)*(int32_t *)(g69 - 0x74fffef4); // 0x1006f78
    int64_t v11 = 13 * v10; // 0x1006f78
    char * v12 = (char *)(2 * v7 | 1); // 0x1006f7f
    char v13 = *v12; // 0x1006f7f
    *v12 = v13 - (char)g69 + (char)(v11 != 0xd00000000 * v10 / 0x100000000);
    int32_t * v14 = (int32_t *)(g69 + 0x18a19104); // 0x1006f88
    *v14 = *v14 + g69;
    int32_t * v15 = (int32_t *)g69; // 0x1006f8f
    *v15 = *v15 + 101;
    unsigned char v16 = *(char *)&g69; // 0x1006f92
    unsigned char v17 = *(char *)((int32_t)v11 - 14); // 0x1006f97
    int32_t v18; // 0x1006f2f
    int32_t v19 = v18 & -256 | (int32_t)v17; // 0x1006f97
    int32_t v20 = *(int32_t *)(g66 & -256 | (int32_t)v16); // 0x1006f9a
    function_1014bc1(v20);
    uint32_t v21 = g69; // 0x1006fa6
    int32_t v22 = *(int32_t *)(4 * v21 - 0x6f5ee777); // 0x1006fac
    int32_t * v23 = (int32_t *)v21; // 0x1006fb4
    *v23 = *v23 + v22;
    int32_t v24 = *(int32_t *)v22; // 0x1006fb6
    uint32_t v25 = *(int32_t *)(2 * v24); // 0x1006fbc
    char * v26 = (char *)(v24 + 1); // 0x1006fc8
    *v26 = *v26 - (char)v21 + (char)(v21 >= v25);
    int32_t * v27 = (int32_t *)(v19 + 0x189da0c); // 0x1006fcb
    *v27 = *v27 + v21;
    int32_t v28 = *(int32_t *)0x1f14f18; // 0x1006fd8
    int32_t v29 = *(int32_t *)v28; // 0x1006fe9
    int32_t v30 = v28 + v19; // 0x1006feb
    char * v31 = (char *)(v19 + 0x2e9c1c1); // 0x1006ff1
    *v31 = *v31 + (char)v30;
    __asm_rep_movsd_memcpy((char *)v29, (char *)v20, v30);
    bool v32; // 0x1006f2f
    int32_t v33 = v32 ? -4 : 4; // 0x1006ff7
    int32_t v34 = v30 * v33 + v29; // 0x1006ff7
    char * v35 = (char *)v34; // 0x1006ffe
    __asm_rep_movsb_memcpy(v35, v35, 3);
    int32_t v36 = v34 + (v32 ? -3 : 3); // 0x1006ffe
    int32_t v37 = v36; // bp-44, 0x1007001
    int32_t * v38 = (int32_t *)(v19 + 0x72518804); // 0x100700a
    *v38 = v19 + 0x14f240d + *v38;
    int32_t v39 = v36 + 232 & 255 | v36 & -256; // 0x1007010
    *(int32_t *)v36 = v39;
    int32_t v40 = v36 + v33; // 0x1007012
    char * v41 = (char *)(v19 + 0x2507325); // 0x1007015
    *v41 = *v41 + (char)((*(int32_t *)v39 | v36) / 256);
    if (v19 != -0x14f240c) {
        // 0x1007077
        *(char *)v40 = *(char *)((v28 | 195) + v19);
        g69++;
        unknown_f177e736(*(int32_t *)0x1c44d74, 0x50e798, -0x40000069, (int32_t)v17);
        return function_1015257();
    }
    char v42 = v11;
    int32_t v43 = *(int32_t *)-0x14f240c; // 0x100702a
    *(int32_t *)-0x14f240c = v43 + (int32_t)&v37;
    int32_t v44 = ((int32_t)(v42 - 1) & -256 | (int32_t)(v42 - 96)) + 1; // 0x100702d
    char v45 = v44; // 0x100702e
    unsigned char v46 = v45 - 1; // 0x100702e
    int32_t result = v44 & -256 | (int32_t)v46; // 0x100702e
    if (((v46 ^ v45) & -v45) >= 0) {
        // 0x1007032
        return result;
    }
    // 0x1007036
    *(int32_t *)(*(int32_t *)(4 * v28) + 4) = result;
    int32_t v47 = *(int32_t *)(g53 + 36); // 0x100704e
    uint32_t v48 = __asm_in(12); // 0x1007065
    __asm_rep_movsd_memcpy((char *)v40, (char *)v47, v48 / 2 & 0x3fffffff);
    return 2 * v48;
}

// Address range: 0x100709d - 0x10070a7
int32_t function_100709d(void) {
    // 0x100709d
    unknown_47026859();
    return function_1007a63();
}

// Address range: 0x10070a7 - 0x10071b9
int32_t function_10070a7(int32_t a1, uint32_t a2) {
    // 0x10070a7
    int32_t v1; // 0x10070a7
    *(int32_t *)(v1 + 8) = 0;
    *(int32_t *)(a2 - 8) = 0;
    int64_t v2; // 0x10070a7
    int64_t v3; // 0x10070a7
    __asm_pcmpeqb(v3, v2);
    int32_t v4; // 0x10070a7
    unsigned char v5 = *(char *)&v4; // 0x10070bd
    unsigned char v6 = v5 + (char)v4; // 0x10070bd
    *(char *)v4 = v6;
    function_1007bd1();
    *(int32_t *)-0x68fe1fa4 = 0;
    uint32_t v7 = function_1007c26(); // 0x10070d0
    *(int32_t *)-0x27feb243 = v7;
    int32_t v8; // 0x10070a7
    int32_t v9 = *(int32_t *)(v8 - 0x4bf51f18); // 0x10070da
    int32_t v10; // 0x10070a7
    char * v11 = (char *)(v10 + 0x10014f90); // 0x10070e0
    *v11 = *v11 + (char)(v7 / 256);
    int32_t v12; // 0x10070a7
    *(int32_t *)v12 = (int32_t)(v6 < v5) + a1 - v9;
    int32_t v13 = v12;
    *(int32_t *)v13 = v13 - 1;
    int32_t v14; // 0x10070a7
    __asm_into(v14);
    unsigned char v15 = *(char *)&v12 + 11; // 0x10070f3
    int32_t v16 = *(int32_t *)*(int32_t *)0x1b94f84 & -256 | (int32_t)v15; // 0x10070f3
    char * v17 = (char *)v16; // 0x10070f5
    *v17 = *v17 + v15;
    int32_t v18 = *(int32_t *)0x12c1d90; // 0x10070f7
    *(int32_t *)v18 = v16;
    __asm_int3();
    *(int32_t *)0x44e3d30 = *(int32_t *)0x44e3d30 + v18;
    *(char *)v8 = *(char *)(v12 + 1);
    *(int32_t *)(v8 + 1) = *(int32_t *)(v12 + 2);
    int32_t v19 = (4 * v18 + 12) / 0x1000000 - a2 / 256 & 255; // 0x1007120
    __asm_frstor(*(int864_t *)(v19 + 0x1c4ab90));
    int16_t v20; // 0x10070a7
    unknown_12007bc1(v20);
    *(int32_t *)-78 = v19;
    int32_t v21 = *(int32_t *)(*(int32_t *)0x1424f84 + 12); // 0x100713f
    function_100fffb(0x10000 * *(int32_t *)(v21 - 10) / 0x10000);
    *(int32_t *)0x4e8b0413 = *(int32_t *)0x4e8b0413 + g19;
    abort();
    // UNREACHABLE
}

// Address range: 0x10071b9 - 0x1007305
int32_t function_10071b9(int32_t a1, int32_t a2) {
    // 0x10071b9
    uint32_t v1; // 0x10071b9
    char v2 = v1; // 0x10071b9
    uint32_t v3; // 0x10071b9
    bool v4; // 0x10071b9
    *(char *)v3 = (char)v3 - v2 + (char)v4;
    int32_t v5; // 0x10071b9
    int32_t * v6 = (int32_t *)(v5 - 117); // 0x10071bd
    int32_t v7; // 0x10071b9
    *v6 = *v6 + v7;
    char * v8 = (char *)(v5 + 112); // 0x10071c0
    *v8 = *v8 + (char)(v3 / 256);
    int32_t v9; // 0x10071b9
    int32_t v10 = v9 + 232; // 0x10071c3
    int32_t v11 = v10 & 255 | v9 & -256; // 0x10071c3
    int32_t v12; // 0x10071b9
    int32_t v13 = (int32_t)(*(char *)&v12 ^ v2); // 0x10071c5
    int32_t v14 = v1 & -256 | v13; // 0x10071c5
    char * v15 = (char *)v11; // 0x10071c7
    *v15 = *v15 + (char)v10;
    *(int32_t *)v14 = 2 * v11;
    int32_t v16; // 0x10071b9
    int32_t v17 = v16 - 1; // 0x10071d9
    int32_t v18 = *(int32_t *)(v14 + (int32_t)&g60) * v11; // 0x10071da
    int32_t v19 = *(int32_t *)v18; // 0x10071e0
    *(int32_t *)v19 = *(int32_t *)v17;
    bool v20; // 0x10071b9
    int32_t v21 = v20 ? -4 : 4; // 0x10071e2
    int32_t v22 = v19 + v21; // 0x10071e2
    int32_t v23 = v18 & 112 | 143; // 0x10071e5
    char * v24 = (char *)(v23 | v18 & -256); // 0x10071e7
    *v24 = *v24 + (char)v23;
    uint32_t v25 = v1 / 1024; // 0x10071eb
    __asm_rep_movsd_memcpy((char *)v22, (char *)(v21 + v17), v25);
    char * v26 = (char *)(v22 + v21 * v25); // 0x10071f5
    __asm_rep_movsb_memcpy(v26, v26, v13 & 3);
    abort();
    // UNREACHABLE
}

// Address range: 0x1007305 - 0x1007306
int32_t function_1007305(void) {
    // 0x1007305
    int32_t result; // 0x1007305
    return result;
}

// Address range: 0x1007307 - 0x1007308
int32_t function_1007307(void) {
    // 0x1007307
    return __asm_hlt();
}

// Address range: 0x1007308 - 0x10073a6
int32_t function_1007308(void) {
    // 0x1007308
    int32_t v1; // 0x1007308
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x1007308
    unknown_12007bd1(*v2);
    *(char *)-0x3517500 = *(char *)-0x3517500 | (char)unknown_14d7c26();
    int32_t v3; // 0x1007308
    int32_t v4 = 4 * v3; // 0x100732c
    int32_t v5 = *(int32_t *)(*(int32_t *)0x1012b0e + v4); // 0x100732c
    int32_t v6 = unknown_1997bfb(*(int32_t *)(*(int32_t *)v5 + 4)); // 0x1007334
    *v2 = *v2 | 0x18a10189;
    int32_t v7; // 0x1007308
    *(int32_t *)v7 = v6 + v7;
    int32_t v8; // 0x1007308
    *(char *)(v8 - 1) = (char)v3;
    bool v9; // 0x1007308
    int32_t v10 = (v9 ? -1 : 1) + v3; // 0x1007346
    int32_t v11; // 0x1007308
    int32_t * v12 = (int32_t *)(v11 + 0x458b044e); // 0x1007347
    uint32_t v13 = *v12; // 0x1007347
    *v12 = v13 / 2 | 0x80000000 * v13;
    int32_t v14 = *(int32_t *)*(int32_t *)(v6 + v4); // 0x100734e
    int32_t v15 = 4 * v7; // 0x1007350
    uint32_t v16 = v15 + 0x94009f; // 0x1007350
    int32_t v17 = *(int32_t *)(v1 - 0x5a7c3775); // 0x100735c
    int32_t v18 = v16 / 4 + v16; // 0x1007362
    *(char *)v14 = *(char *)v10;
    int32_t v19; // 0x1007308
    __asm_outsd((int16_t)v19, *(int32_t *)(v10 + 1));
    *(int32_t *)(v17 - 4) = *(int32_t *)(v15 + 0x940030);
    __asm_out_4(132, function_1007bc1((int32_t)&g125));
    int32_t * v20 = (int32_t *)*(int32_t *)(v1 - 18); // 0x100737e
    *(int32_t *)(v17 - 8) = *(int32_t *)(*(int32_t *)(*v20 + 4) + 4);
    int32_t v21 = unknown_1f37bc7(); // 0x1007387
    *(int32_t *)(v14 + 1) = v21;
    *v20 = v14 + 5;
    char * v22 = (char *)(v14 - 56); // 0x1007393
    *v22 = (char)((char)v21 > 94) - (char)v18 + *v22;
    int32_t * v23 = (int32_t *)(v11 + 0x708bb097); // 0x1007396
    *v23 = *v23 + v18;
    return v21 + 225 & 255 | v21 & -256;
}

// Address range: 0x10073a7 - 0x10073a8
int32_t function_10073a7(int32_t a1) {
    // 0x10073a7
    int32_t result; // 0x10073a7
    return result;
}

// Address range: 0x10073a9 - 0x10073c1
int32_t function_10073a9(void) {
    // 0x10073a9
    int32_t v1; // 0x10073a9
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x10073a9
    int32_t v3; // 0x10073a9
    uint32_t v4; // 0x10073a9
    __asm_rep_movsd_memcpy((char *)v2, (char *)v3, v4 / 4);
    *(int32_t *)v4 = v4 + 3 + (int32_t)((v4 & 2) != 0);
    int32_t v5; // 0x10073a9
    return __asm_in_5((int16_t)v5);
}

// Address range: 0x10073c1 - 0x1007438
int32_t function_10073c1(void) {
    // 0x10073c1
    int32_t v1; // 0x10073c1
    function_100bc53(v1);
    int32_t v2; // 0x10073c1
    unknown_6a007bd1(*(int32_t *)(v2 - 8));
    unknown_1207c26();
    int32_t v3; // 0x10073c1
    *(char *)0xcfe0e8 = *(char *)0xcfe0e8 + (char)v3;
    int32_t v4; // 0x10073c1
    uint32_t v5; // 0x10073c1
    *(char *)v4 = *(char *)&v4 + (char)(v5 / 256);
    int32_t v6 = *(int32_t *)*(int32_t *)(v2 - 3); // 0x10073e9
    int32_t * v7 = (int32_t *)(v6 + 4); // 0x10073eb
    int32_t v8; // 0x10073c1
    *v7 = *v7 ^ v8;
    int32_t v9 = *(int32_t *)(v6 ^ -0x3ba74ff); // 0x10073fb
    int32_t v10 = *(int32_t *)(v2 - 7); // 0x1007400
    int32_t v11 = *(int32_t *)(*(int32_t *)(v9 + 4) - 0x2472f373); // 0x1007403
    char * v12 = (char *)v10; // 0x1007409
    *v12 = *v12 + (char)v10;
    char * v13 = (char *)(v3 + 0x226c1c1); // 0x100740b
    *v13 = *v13 + (char)v11;
    __asm_hlt();
    __asm_rep_movsb_memcpy((char *)v5, (char *)v9, v11);
    char v14; // bp-11, 0x10073c1
    v14 += (char)(int32_t)&v14;
    abort();
    // UNREACHABLE
}

// Address range: 0x1007438 - 0x1007671
int32_t function_1007438(int16_t a1, int32_t a2) {
    // 0x1007438
    int32_t v1; // 0x1007438
    int32_t v2 = *(int32_t *)(v1 - 4); // 0x100743f
    int32_t v3 = *(int32_t *)(v2 + 4); // 0x1007442
    int32_t v4 = v2 & 94 | 161; // 0x1007451
    char * v5 = (char *)(v4 | v2 & -256); // 0x1007453
    *v5 = *v5 + (char)v4;
    int32_t v6 = v1 + 1; // bp-2, 0x100745d
    int32_t v7 = __readgsdword((int32_t)&v6 - 4); // 0x1007461
    int32_t v8; // bp-10, 0x1007438
    int32_t v9; // 0x1007438
    int32_t v10 = function_1013454("XZ", v9, &v8, v7); // 0x1007477
    int32_t v11 = v10; // 0x1007487
    int32_t v12; // 0x1007438
    if (v12 + 1 < v10) {
        v11 = function_1007305();
    }
    // 0x100748d
    uint32_t v13; // 0x1007438
    uint32_t v14 = 8 * *(int32_t *)(v3 + 4) + v13; // 0x100744e
    unknown_7b548f(v11);
    int32_t result3; // bp+7779, 0x1007438
    int32_t v15 = &result3; // 0x1007497
    int32_t v16 = function_100f926(v13); // 0x10074a2
    uint32_t v17; // 0x1007438
    int16_t v18 = v17; // 0x10074aa
    __asm_out_2(v18, v16);
    int32_t v19 = v16 ^ v14 / 64 & 255; // 0x10074ab
    *(char *)0x45014f24 = *(char *)0x45014f24 + (char)v19;
    __asm_out_2(v18, v19);
    char * v20 = (char *)(v13 - 0x17603a5); // 0x10074b0
    *v20 = *v20 + (char)(v14 / 0x40000000 | 4 * v14);
    int32_t v21 = *(int32_t *)a2; // 0x10074b9
    int32_t v22 = v21 ^ 112; // 0x10074bb
    int32_t v23 = v22 + 232; // 0x10074bd
    int32_t v24 = v21 & -256; // 0x10074bd
    char * v25 = (char *)(v23 & 255 | v24); // 0x10074c1
    char v26 = *v25; // 0x10074c1
    char v27 = v23; // 0x10074c1
    char v28 = v26 + v27; // 0x10074c1
    *v25 = v28;
    __asm_arpl(*(int16_t *)0x308b08ed, v18);
    if (v28 < 0 == ((v28 ^ v26) & (v28 ^ v27)) < 0) {
        int32_t v29 = v22 + 194 & 255 | v24; // 0x10074d8
        __asm_arpl(*(int16_t *)v29, (int16_t)v29);
        int32_t v30 = *(int32_t *)(v17 - 23 + v15 + 8 * v29); // 0x10074dc
        __asm_rep_movsb_memcpy((char *)0x45014f24, (char *)v3, v29 & -67);
        function_1007bc1(*(int32_t *)(*(int32_t *)(v30 - 4) + 4));
        return *(int32_t *)(v30 - 111);
    }
    int32_t v31 = v23 & 114 | 141; // 0x100751f
    char * v32 = (char *)(v31 | v24); // 0x1007523
    unsigned char v33 = *v32; // 0x1007523
    unsigned char v34 = v33 + (char)v31; // 0x1007523
    *v32 = v34;
    int32_t result = (v16 ^ 128) + (int32_t)(v34 < v33) & 255 | v16 & -256; // 0x1007527
    *(int32_t *)0x45014f24 = *(int32_t *)v3;
    if (v16 != 1 != ((char)(v17 / 256) == -(char)v13)) {
        // 0x100763e
        return result;
    }
    // 0x1007534
    int32_t v35; // bp-1, 0x1007438
    int32_t v36 = &v35; // 0x100748f
    if ((char)(v17 / 256) == -(char)v13) {
        int32_t result2 = v36 - 4; // 0x1007536
        *(int32_t *)(v15 - 4) = result2;
        return result2;
    }
    uint32_t v37 = v13 / 128;
    unsigned char v38 = (char)v37 & -2; // 0x100753e
    if (v38 != 0) {
        // 0x100763e
        return result;
    }
    int32_t v39 = v38; // 0x100753e
    int32_t v40 = 2 * v39;
    char v41 = v40; // 0x100754a
    if (v41 == 0) {
        // 0x100754e
        return function_1007bd1();
    }
    int32_t v42 = *(int32_t *)0x4824e8; // 0x1007545
    int32_t * v43 = (int32_t *)(v36 + 8); // 0x100755b
    *v43 = v42;
    int32_t * v44 = (int32_t *)(v15 - 4); // 0x100755e
    *v44 = *(int32_t *)v42;
    if (v41 < 0 != (char)(v40 ^ v37) < 0) {
        // 0x1007562
        *(int16_t *)(v15 - 6) = a1;
        char * v45 = (char *)v42; // 0x1007563
        *v45 = *v45 + (char)v42;
        int32_t v46 = *v43 ^ v42; // 0x1007565
        char v47 = llvm_ctpop_i8((char)v46); // 0x1007565
        *(int32_t *)v46 = 512 * v39 & 0xfc00 | v13 & -0xff01;
        int32_t v48 = *(int32_t *)g53; // 0x100756f
        return 0x8000 * (int32_t)(v46 < 0) | 0x4000 * (int32_t)(v46 == 0) | v48 & -0xff01 | 1024 * (int32_t)((v47 & 1) == 0) | 512;
    }
    // 0x10075be
    function_1007cba((int32_t)&g125);
    bool v49; // 0x1007438
    int32_t v50 = v3 + (v49 ? -5 : 3); // 0x10075d2
    char v51 = __asm_in_3(484); // 0x10075dd
    char * v52 = (char *)v50; // 0x10075de
    *v52 = *v52 + (char)((*(int32_t *)0x19287408 | (int32_t)v51) / 256);
    *(int32_t *)*(int32_t *)(v16 - 125) = *(int32_t *)v50;
    int32_t v53 = *(int32_t *)(v15 + 4); // 0x10075ed
    int32_t * v54 = (int32_t *)(v15 + 16); // 0x10075ed
    int32_t * v55 = (int32_t *)(v15 + 20); // 0x10075ed
    int32_t v56 = *v55; // 0x10075ed
    int32_t v57 = v53 + 8; // 0x10075f2
    *(int32_t *)(v15 + 24) = v57;
    function_100be9c();
    *v55 = *(int32_t *)v57;
    function_100bd61((int32_t)&g125);
    uint32_t v58 = *(int32_t *)(result3 - 0xaf0000); // 0x1007605
    function_1007bd1();
    char * v59 = (char *)(v53 - 17); // 0x1007618
    char v60 = v56; // 0x1007618
    *v59 = *v59 + v60;
    int32_t v61 = v15 - 0x5cffaf75 + v53; // 0x100761d
    uint32_t v62 = __readgsdword(v56); // 0x1007623
    uint32_t v63 = v62 + v61; // 0x1007623
    __writegsdword(v56, v63);
    *v54 = *(int32_t *)v61;
    unknown_7b007bc1();
    *(int16_t *)(v15 + 14) = a1;
    char * v64 = (char *)(v56 + (int32_t)&g87); // 0x1007633
    *v64 = (char)(v63 < v62) - (char)(g53 / 256) + *v64;
    __asm_out((int16_t)*v54 - 1, (char)g53);
    uint32_t v65 = v58 / 256; // 0x100763a
    if ((char)(2 * v65 ^ v65) >= 0) {
        // 0x100763e
        return g53;
    }
    int32_t v66 = 512 * v65 & 0xfe00 | v58 & -0xff01; // 0x100763a
    char * v67 = (char *)(v66 + 0x3902050d); // 0x1007642
    *v67 = *v67 + v60;
    int32_t * v68 = (int32_t *)(v66 + 0x4f84a101); // 0x1007648
    *v68 = *v68 + v56;
    int32_t * v69 = (int32_t *)v56; // 0x100764e
    *v69 = *v69 + g53;
    *(int32_t *)*v44 = *(int32_t *)g53;
    return result3;
}

// Address range: 0x1007673 - 0x10076a9
int32_t function_1007673(void) {
    int32_t v1 = *(int32_t *)0x77014f84; // 0x1007686
    char v2 = v1; // 0x100768d
    unsigned char v3 = v2 - 1; // 0x100768d
    int32_t result = v1 & -256 | (int32_t)v3; // 0x100768d
    if (((v3 ^ v2) & -v2) >= 0) {
        // 0x1007691
        return result;
    }
    // 0x1007695
    int32_t v4; // 0x1007673
    int32_t * v5 = (int32_t *)(v4 - 0x7b5efbbf); // 0x100769b
    *v5 = *v5 + v4;
    *(int32_t *)v4 = v4 + 1 + result;
    int32_t v6; // 0x1007673
    int32_t result2 = function_100776c(v6 - 1, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125); // 0x10076a4
    return result2;
}

// Address range: 0x10076a9 - 0x10076ae
int32_t function_10076a9(void) {
    // 0x10076a9
    return function_3e4dfecb();
}

// Address range: 0x10076ae - 0x10076b8
int32_t function_10076ae(int32_t a1) {
    // 0x10076ae
    int32_t v1; // 0x10076ae
    int32_t * v2 = (int32_t *)(v1 + 83); // 0x10076ae
    int32_t v3; // 0x10076ae
    *v2 = *v2 + v3;
    int32_t result; // 0x10076ae
    return result;
}

// Address range: 0x10076b8 - 0x1007703
int32_t function_10076b8(void) {
    // 0x10076b8
    int32_t v1; // 0x10076b8
    int32_t v2; // 0x10076b8
    __asm_outsd((int16_t)v2, v1);
    int32_t v3; // 0x10076b8
    *(char *)v3 = 2 * (char)v3;
    int32_t v4; // 0x10076b8
    *(int32_t *)(v1 - 4) = *(int32_t *)(v4 + 30);
    int32_t v5 = v4 + 9; // 0x10076c3
    *(int32_t *)(v1 - 8) = v5;
    unknown_15ebd6f();
    *(int32_t *)(v1 - 12) = g90;
    int32_t v6 = v1 - 16; // 0x10076d5
    *(int32_t *)v6 = v5;
    *(int32_t *)(v1 - 20) = v6;
    int32_t v7; // 0x10076b8
    uint32_t v8 = -0x74ca0100 * *(int32_t *)(v7 - 108); // 0x10076d7
    int32_t * v9 = (int32_t *)(v2 + 0x4ebe8); // 0x10076df
    *v9 = *v9 + v4;
    char * v10 = (char *)v8; // 0x10076e5
    unsigned char v11 = *v10; // 0x10076e5
    int32_t v12; // 0x10076b8
    unsigned char v13 = v11 + (char)v12; // 0x10076e5
    *v10 = v13;
    uint32_t v14 = v13 < v11 ? 0x101f291 : 0x101f290; // 0x10076e7
    int32_t * v15 = (int32_t *)(function_1007c26() - 0xfefeb3); // 0x10076f1
    *v15 = *v15 + 0x4c43430 + (int32_t)(v13 < v11 | v8 < v14);
    return function_14d90a1();
}

// Address range: 0x1007703 - 0x1007714
int32_t function_1007703(void) {
    // 0x1007703
    int32_t v1; // 0x1007703
    __asm_in_5((int16_t)v1);
    return function_8b00004e();
}

// Address range: 0x1007714 - 0x100771e
int32_t function_1007714(int32_t a1) {
    // 0x1007714
    int32_t v1; // 0x1007714
    int32_t result; // 0x1007714
    *(int32_t *)v1 = result + v1;
    return result;
}

// Address range: 0x100771e - 0x100772a
int32_t function_100771e(void) {
    // 0x100771e
    return function_1007736();
}

// Address range: 0x100772a - 0x1007736
int32_t function_100772a(void) {
    // 0x100772a
    int32_t v1; // 0x100772a
    int32_t v2; // 0x100772a
    uint32_t v3; // 0x100772a
    __asm_rep_movsd_memcpy((char *)v1, (char *)v2, v3 / 64 & 0x1ffffff);
    return 2 * v3;
}

// Address range: 0x1007736 - 0x1007769
int32_t function_1007736(void) {
    // 0x1007736
    int32_t v1; // 0x1007736
    int32_t v2; // 0x1007736
    int32_t v3; // 0x1007736
    __asm_rep_movsb_memcpy((char *)v1, (char *)v2, v3 & 3);
    function_1007bc1(*(int32_t *)(g53 + 4));
    unknown_579765f();
    int32_t result = unknown_3d007bfb(); // 0x100775b
    *(int32_t *)-0x4a2add = result;
    return result;
}

// Address range: 0x100776c - 0x1007820
int32_t function_100776c(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    unsigned char v1 = (char)a7 + 13; // 0x1007771
    int32_t v2 = a7 & -256 | (int32_t)v1; // 0x1007771
    if (v1 >= 0) {
        // 0x1007775
        *(int32_t *)a1 = v2;
        int32_t * v3 = (int32_t *)(a4 + 0xc8d3878); // 0x1007776
        *v3 = *v3 + a6;
        char * v4 = (char *)v2; // 0x100777f
        *v4 = *v4 + v1;
        __asm_outsd((int16_t)a5, *(int32_t *)(a2 - 1));
        return function_8ca66a8b();
    }
    int32_t * v5 = (int32_t *)v2; // 0x10077c2
    *v5 = *v5 + a5;
    *(int32_t *)0x1013d18 = v2;
    int32_t v6 = a4 & 0xff00 & a5 | a4 & -0xff01; // 0x10077c9
    char * v7 = (char *)(a2 + 0x14d901c); // 0x10077cd
    *v7 = *v7 + (char)a6;
    uint32_t v8 = a6 & 31; // 0x10077d8
    if (v8 != 0) {
        uint32_t v9 = a3 - 1; // 0x10077d5
        int32_t * v10 = (int32_t *)(v6 + 0x306c0101); // 0x10077da
        uint32_t v11 = *v10; // 0x10077da
        *v10 = v11 << v8 | (int32_t)(((v9 >> 32 - v8 | v9 << v8) & 1) != 0) << v8 - 1 | (int32_t)((int64_t)v11 >> (int64_t)(33 - v8));
    }
    // .thread
    unknown_10152c1();
    *(int32_t *)*(int32_t *)0x1152e90 = v6;
    int32_t v12 = function_10110fb(*(int32_t *)(*(int32_t *)g95 + 4)); // 0x10077f6
    *(int32_t *)g61 = v12;
    int32_t v13 = *(int32_t *)*(int32_t *)0x1854f84; // 0x1007808
    char * v14 = (char *)v13; // 0x1007819
    *v14 = *v14 + (char)v13;
    return function_3ea39e1();
}

// Address range: 0x100782a - 0x100782e
int32_t function_100782a(int32_t a1) {
    // 0x100782a
    int32_t v1; // 0x100782a
    unsigned char v2 = (char)v1 & 31; // 0x100782a
    if (v2 != 0) {
        int32_t v3; // 0x100782a
        char * v4 = (char *)(v3 + 1); // 0x100782a
        unsigned char v5 = *v4; // 0x100782a
        *v4 = v5 >> v2 | v5 << 8 - v2;
    }
    int32_t result; // 0x100782a
    return result;
}

// Address range: 0x1007848 - 0x100784b
int32_t function_1007848(int32_t a1) {
    // 0x1007848
    int32_t result; // 0x1007848
    return result;
}

// Address range: 0x1007874 - 0x1007879
int32_t function_1007874(void) {
    // 0x1007874
    return function_8caa6b7b();
}

// Address range: 0x1007883 - 0x10079fd
int32_t function_1007883(void) {
    // 0x10078d9
    uint32_t v1; // 0x1007883
    int32_t * v2 = (int32_t *)(v1 - 1); // 0x1007883
    *v2 = *v2 + v1;
    int32_t v3; // 0x1007883
    int32_t v4 = v3 / 256 + v1 & 255 | v1 & -256; // 0x1007890
    int32_t v5; // 0x1007883
    function_1007c2b(*(int32_t *)(v5 - 4), 0x1a68e);
    int32_t v6 = __asm_sti(); // 0x100789e
    int32_t v7; // 0x1007883
    *(int32_t *)v7 = 0;
    uint16_t v8 = (int16_t)v6; // 0x10078a3
    uint16_t v9 = v8 & 255; // 0x10078a3
    uint16_t v10 = v8 % v9; // 0x10078a3
    unsigned char v11 = *(char *)v4 + (char)(v8 / v9); // 0x10078aa
    int32_t v12; // 0x1007883
    char * v13 = (char *)(v12 + 0x18a11e89); // 0x10078ad
    *v13 = *v13 + (char)v10;
    int32_t v14 = v5 - 1; // 0x10078b3
    *(char *)v3 = *(char *)&v3 ^ v11;
    int32_t v15 = *(int32_t *)((v6 & -0x10000 | (int32_t)(256 * v10) | (int32_t)v11) + 4 * v14); // 0x10078b6
    int32_t v16 = *(int32_t *)v15; // 0x10078b9
    char * v17 = (char *)v16; // 0x10078be
    *v17 = *v17 & (char)(v1 / 256);
    int32_t v18 = unknown_e8b9150(*(int32_t *)(v16 + 4), v12); // 0x10078c2
    char * v19 = (char *)v5; // 0x10078c7
    *v19 = *v19 + (char)(*(int32_t *)v16 > -1 - v16) - (char)v3;
    int32_t * v20 = (int32_t *)(v12 + 0x16f48bf9 + 8 * v12); // 0x10078ca
    *v20 = *v20 + v18;
    int32_t result = v18 & -256 | v18 + 13 & 114 | 141; // 0x10078d6
    char * v21 = (char *)(v4 - 0x3e417408); // 0x10078d9
    *v21 = *v21 + (char)v3;
    *(int32_t *)v14 = *(int32_t *)(v12 - 1);
    __asm_rep_movsb_memcpy((char *)(v5 + 3), (char *)(v12 + 3), result - 1);
    return result;
}

// Address range: 0x10079fd - 0x1007a0a
int32_t function_10079fd(void) {
    // 0x10079fd
    int32_t result; // 0x10079fd
    bool v1; // 0x10079fd
    if (v1) {
        result = function_1007a51();
    }
    // 0x1007a07
    int32_t v2; // 0x10079fd
    *(int32_t *)v2 = result;
    return result;
}

// Address range: 0x1007a0a - 0x1007a2c
int32_t function_1007a0a(void) {
    // 0x1007a0a
    int32_t v1; // 0x1007a0a
    int32_t * v2 = (int32_t *)(v1 - 12); // 0x1007a0a
    *v2 = *v2 + 1;
    int32_t v3 = *(int32_t *)-0x23feb0dc; // 0x1007a0d
    int32_t v4 = v3; // 0x1007a15
    if (*(int32_t *)(v1 + 97) < v3) {
        v4 = function_d4ff9a2a();
    }
    // 0x1007a1b
    int32_t v5; // 0x1007a0a
    char * v6 = (char *)(v5 - 24); // 0x1007a27
    int32_t v7; // 0x1007a0a
    *v6 = *v6 | (char)v7;
    return v4 & 0x7576087d;
}

// Address range: 0x1007a2e - 0x1007a30
int32_t function_1007a2e(void) {
    // 0x1007a2e
    int32_t result; // 0x1007a2e
    return result;
}

// Address range: 0x1007a51 - 0x1007a61
int32_t function_1007a51(void) {
    // 0x1007a51
    int32_t v1; // 0x1007a51
    int32_t result = v1 & -256 | 136; // 0x1007a51
    char * v2 = (char *)result; // 0x1007a55
    *v2 = *v2 - 120;
    int32_t v3; // 0x1007a51
    char * v4 = (char *)(v3 - 0x2900feff); // 0x1007a59
    int32_t v5; // 0x1007a51
    *v4 = *v4 & (char)v5;
    return result;
}

// Address range: 0x1007a63 - 0x1007a68
int32_t function_1007a63(void) {
    // 0x1007a63
    return function_c3c9d5c6();
}

// Address range: 0x1007a68 - 0x1007aaf
int32_t function_1007a68(void) {
    // 0x1007a68
    int32_t v1; // 0x1007a68
    *(char *)0x5814e04d = *(char *)0x5814e04d & (char)v1;
    __asm_int_7(17);
    int32_t * v2 = (int32_t *)(v1 - 123); // 0x1007a84
    uint32_t v3; // 0x1007a68
    *v2 = *v2 | v3;
    int32_t v4 = v1 - 2; // 0x1007a9c
    uint32_t v5; // 0x1007a68
    int32_t v6; // 0x1007a68
    if (v4 < v5) {
        // 0x1007aa4
        *(int32_t *)v5 = v6 + 1;
        return *(int32_t *)(v3 + 12);
    }
    char * v7 = (char *)(v3 + 80); // 0x1007a98
    char v8 = *v7; // 0x1007a98
    for (int32_t i = v4; i >= v5 + 1; i -= 2) {
        // 0x1007a93
        v8 += (char)(v3 < 0x89da118b) + (char)v3;
    }
    // 0x1007a9b
    *v7 = v8;
    // 0x1007aa4
    *(int32_t *)v5 = v6 + 1;
    return *(int32_t *)(v3 + 12);
}

// Address range: 0x1007aaf - 0x1007ad5
int32_t function_1007aaf(int32_t a1) {
    // 0x1007aaf
    int32_t phkResult; // 0x1007aaf
    return RegOpenKeyExA(-0x7fffffd2, (char *)-0x10ffea60, 0, -0x79fdffe7, (int32_t **)phkResult);
}

// Address range: 0x1007ac8 - 0x1007ac9
int32_t function_1007ac8(void) {
    // 0x1007ac8
    int32_t result; // 0x1007ac8
    return result;
}

// Address range: 0x1007b03 - 0x1007b07
int32_t function_1007b03(void) {
    // 0x1007b03
    return function_1007b09();
}

// Address range: 0x1007b07 - 0x1007b09
int32_t function_1007b07(void) {
    // 0x1007b07
    return 0;
}

// Address range: 0x1007b09 - 0x1007b0e
int32_t function_1007b09(void) {
    // 0x1007b09
    return function_1053dd7();
}

// Address range: 0x1007b0e - 0x1007b49
int32_t function_1007b0e(int32_t a1, int32_t a2) {
    // 0x1007b0e
    int32_t v1; // 0x1007b0e
    int32_t v2; // 0x1007b0e
    __asm_arpl(*(int16_t *)(v1 + 0x4ec63ec), (int16_t)v2);
    int32_t v3; // 0x1007b0e
    *(char *)v3 = 2 * (char)v3;
    if (g71 != g72) {
        // 0x1007b41
        int32_t v4; // bp-4, 0x1007b0e
        return &v4;
    }
    // 0x1007b2a
    int32_t v5; // 0x1007b0e
    return function_1007aaf(v5);
}

// Address range: 0x1007b4d - 0x1007b86
int32_t function_1007b4d(int32_t a1) {
    // 0x1007b4d
    int32_t v1; // 0x1007b4d
    __asm_in_3((int16_t)v1);
    int32_t v2 = (int32_t)g74; // 0x1007b6b
    int32_t v3 = v2; // 0x1007b72
    if (g74 != NULL) {
        v3 = function_1007b94();
    }
    char v4 = llvm_ctpop_i8((char)v2); // 0x1007b70
    int32_t v5; // 0x1007b4d
    __asm_sqrtps(*(int128_t *)(v5 - 0x16efd72a));
    int32_t result = v3; // 0x1007b7c
    if ((v4 & 1) == 0) {
        result = function_1007b03();
    }
    // 0x1007b86
    return result;
}

// Address range: 0x1007b87 - 0x1007b8c
int32_t function_1007b87(void) {
    // 0x1007b87
    int32_t v1; // 0x1007b87
    return v1 + (int32_t)&g71;
}

// Address range: 0x1007b8d - 0x1007b94
int32_t function_1007b8d(void) {
    // 0x1007b8d
    int32_t result; // 0x1007b8d
    return result;
}

// Address range: 0x1007b91 - 0x1007b92
int32_t function_1007b91(int32_t a1) {
    // 0x1007b91
    int32_t result; // 0x1007b91
    return result;
}

// Address range: 0x1007b94 - 0x1007b95
int32_t function_1007b94(void) {
    // 0x1007b94
    int32_t result; // 0x1007b94
    return result;
}

// Address range: 0x1007b96 - 0x1007ba7
int32_t function_1007b96(void) {
    // 0x1007b96
    int32_t v1; // 0x1007b96
    char * v2 = (char *)(v1 - 55); // 0x1007ba1
    *v2 = *v2 / 2;
    int32_t v3; // 0x1007b96
    bool v4; // 0x1007b96
    return v3 + 255 + (int32_t)v4 & 255 | v3 & -256;
}

// Address range: 0x1007ba3 - 0x1007ba4
int32_t function_1007ba3(void) {
    // 0x1007ba3
    int32_t result; // 0x1007ba3
    return result;
}

// Address range: 0x1007ba4 - 0x1007ba5
int32_t function_1007ba4(void) {
    // 0x1007ba4
    int32_t result; // 0x1007ba4
    return result;
}

// Address range: 0x1007ba5 - 0x1007ba6
int32_t function_1007ba5(void) {
    // 0x1007ba5
    int32_t result; // 0x1007ba5
    return result;
}

// Address range: 0x1007ba8 - 0x1007baf
int32_t function_1007ba8(int32_t a1) {
    // 0x1007ba8
    int32_t v1; // 0x1007ba8
    bool v2; // 0x1007ba8
    bool v3; // 0x1007ba8
    bool v4; // 0x1007ba8
    if (v4 || v3 != v2) {
        v1 = function_1007b96();
    }
    // 0x1007baa
    return v1 ^ 42;
}

// Address range: 0x1007bb0 - 0x1007bbb
int32_t function_1007bb0(void) {
    // 0x1007bb0
    int32_t v1; // 0x1007bb0
    *(int32_t *)(v1 - 4) = -0x7ffffff9;
    return v1 - 63;
}

// Address range: 0x1007bbf - 0x1007bc0
int32_t function_1007bbf(int32_t a1) {
    // 0x1007bbf
    int32_t result; // 0x1007bbf
    return result;
}

// Address range: 0x1007bc1 - 0x1007bd1
int32_t function_1007bc1(int32_t a1) {
    // 0x1007bc1
    int32_t v1; // 0x1007bc1
    if ((char)v1 == 112) {
        // 0x1007bce
        return v1 & -256;
    }
    // 0x1007bc8
    return (int32_t)LocalFree(&g125);
}

// Address range: 0x1007bd1 - 0x1007c37
int32_t function_1007bd1(void) {
    // 0x1007bd1
    int32_t v1; // 0x1007bd1
    int32_t v2; // 0x1007bd1
    if (v2 != 0) {
        unsigned char v3 = (char)v1; // 0x1007bdc
        int32_t result; // 0x1007bd1
        if ((v3 & 14) > 9) {
            result = (v3 > 153 ? 102 : 6) + v1 & 255 | v1 & -256;
        } else {
            result = (v3 > 153 ? v1 + 96 : v1) & 255 | v1 & -256;
        }
        // 0x1007bdf
        return result;
    }
    int32_t v4; // 0x1007bd1
    if (v1 != 1 == v4 == -1) {
        function_1007b87();
    }
    unsigned char v5 = *(char *)-0x29a90857; // 0x1007c03
    *(char *)-0x29a90857 = v5 - 87;
    uint32_t v6 = v1 - 2; // 0x1007c0b
    int32_t v7 = v5 > 86 ? -0x29bf9e06 : -0x29bf9e07; // 0x1007c0b
    if (v6 != 0) {
        v7 = function_1007b8d();
    }
    char * v8 = (char *)v7; // 0x1007c0d
    char v9 = v7; // 0x1007c0d
    *v8 = v9 + 1 + *v8;
    int32_t v10; // 0x1007bd1
    int32_t * v11 = (int32_t *)(v10 + 0x751619f0); // 0x1007c0f
    *v11 = *v11 + v6;
    char v12 = *(char *)(v7 - 53); // 0x1007c15
    *v8 = *v8 + v9;
    int32_t v13 = unknown_47007ba7(); // 0x1007c1b
    uint32_t v14 = v13 + 1; // 0x1007c22
    int32_t v15 = v13 + 111 + (v14 / 32 & 248); // 0x1007c27
    char * v16 = (char *)(256 * (int32_t)(v12 | (char)(v6 / 256)) | v6 & -0xff01); // 0x1007c2f
    *v16 = *v16 + (char)v15;
    int32_t v17; // 0x1007bd1
    *(char *)*(int32_t *)(v17 - 123) = -1;
    return v15 & 255 | v14 & -0x10000;
}

// Address range: 0x1007c0e - 0x1007c0f
int32_t function_1007c0e(int32_t a1) {
    // 0x1007c0e
    int32_t result; // 0x1007c0e
    return result;
}

// Address range: 0x1007c18 - 0x1007c19
int32_t function_1007c18(void) {
    // 0x1007c18
    int32_t result; // 0x1007c18
    return result;
}

// Address range: 0x1007c19 - 0x1007c1a
int32_t function_1007c19(int32_t a1) {
    // 0x1007c19
    int32_t result; // 0x1007c19
    return result;
}

// Address range: 0x1007c1d - 0x1007c1e
int32_t function_1007c1d(void) {
    // 0x1007c1d
    int32_t result; // 0x1007c1d
    return result;
}

// Address range: 0x1007c26 - 0x1007c27
int32_t function_1007c26(void) {
    // 0x1007c26
    int32_t result; // 0x1007c26
    return result;
}

// Address range: 0x1007c2b - 0x1007c2c
int32_t function_1007c2b(int32_t a1, int32_t a2) {
    // 0x1007c2b
    int32_t result; // 0x1007c2b
    return result;
}

// Address range: 0x1007c2f - 0x1007c30
int32_t function_1007c2f(int32_t a1) {
    // 0x1007c2f
    int32_t result; // 0x1007c2f
    return result;
}

// Address range: 0x1007c30 - 0x1007c31
int32_t function_1007c30(int32_t a1) {
    // 0x1007c30
    int32_t result; // 0x1007c30
    return result;
}

// Address range: 0x1007c36 - 0x1007c37
int32_t function_1007c36(int32_t a1) {
    // 0x1007c36
    int32_t result; // 0x1007c36
    return result;
}

// Address range: 0x1007c38 - 0x1007c8e
int32_t function_1007c38(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t result, int32_t a6) {
    // 0x1007c38
    int32_t v1; // 0x1007c38
    char * v2 = (char *)(v1 - 0x2a18); // 0x1007c3a
    *v2 = *v2 + (char)v1;
    int32_t v3; // 0x1007c38
    int32_t * v4 = (int32_t *)(v3 + 0x66a50026); // 0x1007c40
    *v4 = *v4 + 1;
    *(char *)(v3 - 98) = 86;
    int32_t v5 = unknown_ffd1fb(33); // 0x1007c4f
    char * v6 = (char *)(v3 - 0x77fffb58); // 0x1007c59
    *v6 = *v6 | (char)v5;
    char * v7 = (char *)a6; // 0x1007c60
    *v7 = *v7 | (char)a6;
    int32_t * v8 = (int32_t *)result;
    int32_t v9; // 0x1007c38
    if (a6 >= 0) {
        // 0x1007c70
        *v8 = 1;
        v9 = a6;
    } else {
        // 0x1007c69
        *v8 = -1;
        v9 = -a6;
    }
    int32_t * v10 = (int32_t *)(result + 4);
    uint32_t v11 = v9;
    int32_t v12; // bp+28, 0x1007c38
    int32_t v13 = &v12; // 0x1007c7d
    uint32_t v14 = *(int32_t *)(v13 + 12); // 0x1007c78
    *(int32_t *)33 = __asm_insd((int16_t)(v11 % v14));
    v13 -= 2;
    *v10 = *v10 + 1;
    while (v14 <= v11) {
        // 0x1007c76
        v11 /= v14;
        v14 = *(int32_t *)(v13 + 12);
        *(int32_t *)33 = __asm_insd((int16_t)(v11 % v14));
        v13 -= 2;
        *v10 = *v10 + 1;
    }
    // 0x1007c88
    return result;
}

// Address range: 0x1007c8e - 0x1007c8f
int32_t function_1007c8e(int32_t a1, int32_t a2) {
    // 0x1007c8e
    int32_t result; // 0x1007c8e
    return result;
}

// Address range: 0x1007c93 - 0x1007c94
int32_t function_1007c93(void) {
    // 0x1007c93
    int32_t result; // 0x1007c93
    return result;
}

// Address range: 0x1007cba - 0x1007cc3
int32_t function_1007cba(int32_t a1) {
    // 0x1007cba
    int32_t result; // 0x1007cba
    bool v1; // 0x1007cba
    bool v2; // 0x1007cba
    bool v3; // 0x1007cba
    if (v2 == v1 == !v3) {
        result = function_1007d2a();
    }
    // 0x1007cbc
    return result;
}

// Address range: 0x1007cc4 - 0x1007cd3
int32_t function_1007cc4(int32_t a1) {
    // 0x1007cc4
    int32_t v1; // 0x1007cc4
    return v1 & -240;
}

// Address range: 0x1007cd3 - 0x1007ce2
int32_t function_1007cd3(int32_t a1) {
    // 0x1007cd3
    int32_t v1; // 0x1007cd3
    return function_3bc03357(v1);
}

// Address range: 0x1007cfa - 0x1007d16
int32_t function_1007cfa(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1007cfa
    int32_t v1; // 0x1007cfa
    char * v2 = (char *)(v1 - 0x3fcccf3a); // 0x1007cfd
    char v3 = *v2; // 0x1007cfd
    uint32_t v4; // 0x1007cfa
    int32_t v5; // 0x1007cfa
    *v2 = (char)(-1 - (char)v4 < (char)(v4 / 256)) - (char)v5 + v3;
    int128_t v6; // 0x1007cfa
    int128_t v7; // 0x1007cfa
    __asm_movhlps(v7, v6);
    int32_t v8; // 0x1007cfa
    int32_t * v9 = (int32_t *)(v8 - 0x63fbb56b); // 0x1007d0f
    *v9 = 2 * *v9;
    return v5 + 1;
}

// Address range: 0x1007d16 - 0x1007d22
int32_t function_1007d16(int32_t a1, int32_t a2) {
    // 0x1007d16
    int32_t v1; // 0x1007d16
    int32_t v2; // 0x1007d16
    *(int32_t *)v1 = v2 + v1;
    int32_t result; // 0x1007d16
    return result;
}

// Address range: 0x1007d2a - 0x1007d3a
int32_t function_1007d2a(void) {
    // 0x1007d2a
    int32_t v1; // 0x1007d2a
    int32_t v2; // 0x1007d2a
    *(int32_t *)(v2 - 4) = *(int32_t *)(v1 + 16);
    *(int32_t *)(v2 - 8) = 1;
    int32_t v3; // bp-1, 0x1007d2a
    return &v3;
}

// Address range: 0x1007d3b - 0x1007e0e
int32_t function_1007d3b(void) {
    // 0x1007d3b
    bool v1; // 0x1007d3b
    int32_t v2 = v1 ? -4 : 4; // 0x1007d3b
    int32_t v3; // 0x1007d3b
    int32_t v4 = v2 + v3; // 0x1007d3b
    int32_t v5; // 0x1007d3b
    int32_t v6; // 0x1007d3b
    bool v7; // 0x1007d3b
    bool v8; // 0x1007d3b
    if (v8 != v7) {
        int32_t * v9 = (int32_t *)v4; // 0x1007dac
        int32_t v10 = *v9; // 0x1007dac
        unknown_2d34c1(v10);
        int32_t v11 = *(int32_t *)(v6 - 4); // 0x1007db3
        *v9 = v11;
        char * v12 = (char *)(v6 - 117); // 0x1007dbd
        *v12 = (char)v5 + 12 + *v12;
        return v11 & -256 | (int32_t)*(char *)((v11 & 255) + v10);
    }
    // 0x1007d46
    int32_t v13; // 0x1007d3b
    uint32_t v14 = v2 + v13; // 0x1007d3b
    int32_t v15 = *(int32_t *)(v6 + 62 + v5); // bp-6, 0x1007d49
    int32_t v16 = __asm_insd((int16_t)v5); // 0x1007d56
    int32_t * v17 = (int32_t *)v4; // 0x1007d56
    *v17 = v16;
    *(int32_t *)0x5737d610 = *(int32_t *)0x5737d610 - 1;
    unknown_b7011aa0();
    uint32_t v18; // 0x1007d3b
    *(char *)v5 = (char)(v18 / 256);
    int32_t v19 = 256 * (int32_t)*(char *)&v5 | v18 & -0xff02; // 0x1007d69
    int32_t v20 = *v17; // 0x1007d6b
    int32_t v21 = v5; // 0x1007d70
    int32_t v22 = (int32_t)&v15 - *(int32_t *)(v21 + 64); // 0x1007d72
    uint32_t v23 = *(int32_t *)0x1344f5c; // 0x1007d78
    int32_t v24 = v14 - v23; // 0x1007d78
    int32_t * v25 = (int32_t *)(v24 + 0x2b2252c2); // 0x1007d7e
    *v25 = *v25 - (v14 < v23 ? -57 : -58);
    int32_t v26 = __asm_sti(); // 0x1007d8c
    int32_t v27 = v22 - 2; // 0x1007d8d
    *(int32_t *)v27 = v26;
    memmove(&g125, &g125, (int32_t)&g125);
    *(int32_t *)v21 = v21 - v27;
    int32_t v28 = v21 + 139; // 0x1007d9c
    int32_t v29 = v21 & -256; // 0x1007d9c
    int32_t result = v28 & 255 | v29; // 0x1007d9c
    int32_t * v30 = (int32_t *)(result + 8); // 0x1007da2
    *v30 = *v30 + v24;
    if (v19 >= 0 != v19 != 0) {
        // 0x1007dab
        return result;
    }
    int32_t v31 = 4 * *(int32_t *)(v20 + 4); // 0x1007d85
    int32_t v32 = v28 & 204 | 51; // 0x1007dc8
    int32_t v33 = v32 | v29; // 0x1007dc8
    *(char *)(v33 - 119) = 0;
    *(int32_t *)(v31 - 169) = v33;
    *(int32_t *)(v4 - 0x2eff97be + v21) = __asm_bound(*(int64_t *)(v31 - 196));
    int32_t v34 = v29 | (int32_t)((char)v32 - *(char *)(v33 + 0x67fe65e8)); // 0x1007de0
    int32_t * v35 = (int32_t *)v20; // 0x1007deb
    *v35 = v34 + *v35;
    int32_t v36 = *(int32_t *)(v31 - 71); // 0x1007ded
    *(int32_t *)(v31 - 87) = v34;
    uint64_t v37 = 0x100000000 * (int64_t)v5 | (int64_t)*(int32_t *)(v36 - 78); // 0x1007e00
    uint64_t v38 = (int64_t)*(int32_t *)(v31 - 67); // 0x1007e00
    int32_t result2 = v37 / v38; // 0x1007e00
    *(int32_t *)(v22 - 129) = result2;
    char * v39 = (char *)*(int32_t *)(v36 + 8); // 0x1007e0c
    *v39 = *v39 - (char)(v37 % v38);
    return result2;
}

// Address range: 0x1007e28 - 0x1007e69
int32_t function_1007e28(void) {
    // 0x1007e28
    int32_t v1; // 0x1007e28
    char * v2 = (char *)(v1 + 0x75ff4000); // 0x1007e28
    char v3 = *v2; // 0x1007e28
    uint32_t v4; // 0x1007e28
    char v5 = v4 / 256; // 0x1007e28
    char v6 = v3 + v5; // 0x1007e28
    *v2 = v6;
    int32_t v7; // 0x1007e28
    int32_t v8 = v7;
    *(char *)v8 = *(char *)&v7 + (char)v8;
    int32_t v9 = *(int32_t *)(8 * v7 + 0x7f30385); // 0x1007e3b
    int32_t v10 = *(int32_t *)(v1 - 4); // 0x1007e42
    int32_t * v11 = (int32_t *)(v10 + 12); // 0x1007e45
    *v11 = *v11 | 1;
    int32_t * v12 = (int32_t *)(v1 + 8); // 0x1007e49
    uint32_t v13 = *v12; // 0x1007e49
    *v12 = v13 / 2;
    int32_t v14 = ((v13 & 1) == 0 ? 0 : 255) | v10 & -256; // 0x1007e4e
    v7 = v14;
    int32_t * v15; // 0x1007e28
    if (v13 >= 2) {
        // 0x1007e28
        v15 = (int32_t *)v9;
    } else {
        int64_t v16 = (int64_t)*(int32_t *)(v1 + 0x39fffc45); // 0x1007e2e
        int32_t v17 = 0x1e844ce * v16 != 0x1e844ce00000000 * v16 / 0x100000000; // 0x1007e38
        char v18 = llvm_ctpop_i8(v6); // 0x1007e28
        int32_t * v19 = (int32_t *)(v9 - 4);
        *v19 = v14;
        bool v20; // 0x1007e28
        bool v21; // 0x1007e28
        bool v22; // 0x1007e28
        bool v23; // 0x1007e28
        unknown_a0011a6d(0x4000 * (int32_t)v20 | 1024 * (int32_t)v21 | 512 * (int32_t)v22 | 256 * (int32_t)v23 | 64 * (int32_t)(v6 == 0) | 128 * (int32_t)(v6 < 0) | 16 * (int32_t)((v3 & 15) + (v5 & 15) > 15) | 4 * (int32_t)((v18 & 1) == 0) | v17 | 2048 * v17 | 2);
        v15 = v19;
    }
    // 0x1007e63
    return *v15;
}

// Address range: 0x1007e6a - 0x1007f35
int32_t function_1007e6a(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1007e6a
    int32_t v1; // 0x1007e6a
    int32_t * v2 = (int32_t *)(v1 - 0x3b274fa); // 0x1007e6a
    uint32_t v3 = *v2; // 0x1007e6a
    *v2 = v3 - 1;
    int32_t result; // 0x1007e6a
    if (v3 <= 1) {
        // 0x1007e76
        return result;
    }
    // 0x1007ee5
    int32_t v4; // 0x1007e6a
    if (result < *(int32_t *)(v1 + 4)) {
        int32_t v5 = result + 195 & 234 | 21; // 0x1007f12
        char * v6 = (char *)(v5 | result & -256); // 0x1007f16
        *v6 = *v6 + (char)v5;
        return function_101239e(v4 - 4);
    }
    int32_t * v7 = (int32_t *)(v4 - 4); // 0x1007eea
    int32_t v8 = unknown_3f7bc1(*v7); // 0x1007eed
    int32_t v9 = *(int32_t *)(v8 - 67); // 0x1007ef2
    int32_t v10; // 0x1007e6a
    *(int32_t *)v10 = v8 + v10;
    int32_t * v11 = (int32_t *)(v1 + 0x70ffa4fc); // 0x1007ef7
    *v11 = *v11 & 4;
    *v7 = v9;
    return v9 ^ v8;
}

// Address range: 0x1007f4e - 0x1007f57
int32_t function_1007f4e(void) {
    // 0x1007f4e
    int32_t v1; // 0x1007f4e
    int32_t * v2 = (int32_t *)(v1 - 0x4da4070c); // 0x1007f4e
    int32_t v3; // 0x1007f4e
    *v2 = *v2 + v3;
    int32_t result; // 0x1007f4e
    return result;
}

// Address range: 0x1007f57 - 0x1007f58
int32_t function_1007f57(void) {
    // 0x1007f57
    int32_t result; // 0x1007f57
    return result;
}

// Address range: 0x1007f61 - 0x1007f62
int32_t function_1007f61(void) {
    // 0x1007f61
    int32_t result; // 0x1007f61
    return result;
}

// Address range: 0x1007f77 - 0x1007f8a
int32_t function_1007f77(void) {
    // 0x1007f77
    int32_t v1; // 0x1007f77
    int32_t v2; // 0x1007f77
    __asm_outsb((int16_t)v2, (char)v1);
    unknown_1a6c7bfb();
    return function_1007fce();
}

// Address range: 0x1007fa0 - 0x1007fa1
int32_t function_1007fa0(void) {
    // 0x1007fa0
    int32_t result; // 0x1007fa0
    return result;
}

// Address range: 0x1007fce - 0x1007fdc
int32_t function_1007fce(void) {
    // 0x1007fce
    int32_t v1; // 0x1007fce
    int32_t v2; // 0x1007fce
    __asm_arpl(*(int16_t *)(v1 + 1), (int16_t)v2);
    int32_t v3; // 0x1007fce
    int32_t * v4 = (int32_t *)(v3 - 38); // 0x1007fd2
    *v4 = *v4 + v2;
    return function_1007f61();
}

// Address range: 0x1007fdc - 0x1007fed
int32_t function_1007fdc(void) {
    int32_t v1 = __asm_wait(); // 0x1007fdd
    uint32_t v2; // 0x1007fdc
    int32_t v3; // 0x1007fdc
    *(char *)v1 = (char)(v3 & v2 / 256);
    int32_t v4 = v1 & 0xbd3bc00; // 0x1007fe0
    int32_t v5 = v4 | v1 + 9 & 124 | -0xbd3bc7d; // 0x1007fe2
    uint32_t v6; // 0x1007fdc
    uint32_t v7 = v5 + v6; // 0x1007fe7
    *(int32_t *)v6 = v7;
    return v4 | v5 + 117 & 252 | (int32_t)(v7 < v6) | -0xbd3bd00;
}

// Address range: 0x1007fed - 0x1008123
int32_t function_1007fed(int32_t a1, int32_t a2) {
    int32_t v1 = a1 & 0x6a0c; // 0x1007ff6
    int32_t v2; // 0x1007fed
    bool v3; // 0x1007fed
    int32_t v4 = *(int32_t *)(v1 + 28) & (v3 ? -4 : 4) + v2; // 0x100800a
    uint32_t v5; // 0x1007fed
    int32_t * v6 = (int32_t *)(v5 - 0x7cfa81d2); // 0x1008011
    *v6 = *v6 + 23;
    int32_t v7; // 0x1007fed
    char * v8 = (char *)(v7 + 14); // 0x1008018
    *v8 = *v8 ^ (char)(v5 / 256);
    if (*(int32_t *)0x18f4010 != 57) {
        // 0x1008029
        __asm_wait();
        return (int32_t)*(char *)v4 & -256 | 1;
    }
    int32_t v9 = v1 - 46; // 0x100800e
    int32_t v10; // 0x1007fed
    int32_t v11 = 256 * (int32_t)*(char *)(v4 + 0x43949b07) | v10 & -0xff01; // 0x1008033
    char * v12 = (char *)v9; // 0x1008039
    *v12 = *v12 - (char)v1;
    if (v11 <= 9) {
        if (v11 == 9) {
            function_1301c78();
        }
        // 0x1008068
        return function_f40df47a();
    }
    int32_t v13 = v1 - 0x5b0e6a41; // 0x10080d3
    char v14 = *(char *)(v7 - 0xfa011e); // 0x10080df
    int32_t v15 = v13 & -0x5b0e0100 | (int32_t)((char)v13 + 73 + v14); // 0x10080df
    int32_t v16 = v11 - 5; // 0x10080e5
    *(char *)(2 * v15 - 0x47d0000) = (char)(v16 < 0 == (4 - v11 & v10) < 0 == (v16 != 0));
    int32_t v17; // 0x1007fed
    if (*(int32_t *)(v4 + 101) >= v17) {
        // 0x1008168
        return v15 | 0xa3640f;
    }
    // 0x1008100
    *(int32_t *)(*(int32_t *)(v17 + 8) + 8) = v9;
    return function_11681a6(v17);
}

// Address range: 0x1008123 - 0x1008130
int32_t function_1008123(void) {
    // 0x1008123
    return function_8a0b077c();
}

// Address range: 0x1008130 - 0x1008133
int32_t function_1008130(void) {
    // 0x1008130
    int32_t result; // 0x1008130
    return result;
}

// Address range: 0x1008134 - 0x1008135
int32_t function_1008134(int32_t a1) {
    // 0x1008134
    int32_t result; // 0x1008134
    return result;
}

// Address range: 0x1008136 - 0x100813b
int32_t function_1008136(void) {
    // 0x1008136
    return function_4a07f545();
}

// Address range: 0x1008142 - 0x1008168
int32_t function_1008142(void) {
    // 0x1008142
    int32_t v1; // 0x1008142
    int32_t v2 = v1 | (int32_t)&g5; // 0x1008142
    int32_t v3; // 0x1008142
    int32_t v4 = v3 + 36; // 0x1008147
    int32_t wc = v2; // 0x100814a
    int32_t v5; // 0x1008142
    if (v5 >= 11 && v4 < 0 == (v4 & (v3 ^ -0x80000000)) < 0 != v4 != 0) {
        // 0x1008151
        wc = v2 + 0x10031c8 + (int32_t)((v2 & 256) != 0);
    }
    // 0x1008159
    int32_t wstr; // 0x1008142
    int16_t * v6 = wcschr((int16_t *)wstr, (int16_t)wc); // 0x100815b
    int32_t * v7 = (int32_t *)(wstr - 124); // 0x1008164
    int32_t v8; // 0x1008142
    *v7 = *v7 - v8;
    return (int32_t)v6;
}

// Address range: 0x1008178 - 0x1008185
int32_t function_1008178(void) {
    // 0x1008178
    int32_t v1; // 0x1008178
    int32_t v2; // 0x1008178
    return v2 / 2 + v1;
}

// Address range: 0x1008195 - 0x100819a
int32_t function_1008195(void) {
    // 0x1008195
    int32_t result; // 0x1008195
    return result;
}

// Address range: 0x100819a - 0x100819d
int32_t function_100819a(void) {
    // 0x100819a
    int32_t result; // 0x100819a
    return result;
}

// Address range: 0x100819d - 0x10081b4
int32_t function_100819d(void) {
    // 0x100819d
    int32_t v1; // 0x100819d
    int64_t v2; // 0x100819d
    __asm_pcmpgtd(v2, *(int64_t *)&v1);
    int32_t v3; // 0x100819d
    char * v4 = (char *)(v3 - 0x1476fbba); // 0x10081a0
    *v4 = *v4 + (char)v3;
    int32_t v5; // 0x100819d
    char * v6 = (char *)(v5 - 24); // 0x10081ab
    int32_t v7; // 0x100819d
    *v6 = *v6 | (char)v7;
    int64_t v8; // 0x100819d
    __asm_psubd(v8, v8);
    return 0x7500047e;
}

// Address range: 0x10081b4 - 0x10081b6
int32_t function_10081b4(void) {
    // 0x10081b4
    int32_t result; // 0x10081b4
    return result;
}

// Address range: 0x10081b6 - 0x10081c0
int32_t function_10081b6(void) {
    // 0x10081b6
    int32_t v1; // 0x10081b6
    int32_t v2; // 0x10081b6
    *(int32_t *)v1 = v2 + v1;
    int32_t v3; // 0x10081b6
    return function_1007cd3(v3);
}

// Address range: 0x10081c1 - 0x10081c2
int32_t function_10081c1(void) {
    // 0x10081c1
    int32_t result; // 0x10081c1
    return result;
}

// Address range: 0x10081c2 - 0x10081cc
int32_t function_10081c2(int32_t a1, int32_t a2) {
    // 0x10081c2
    int32_t result; // 0x10081c2
    return result;
}

// Address range: 0x10081cc - 0x10081f8
int32_t function_10081cc(void) {
    // 0x10081cc
    int32_t v1; // 0x10081cc
    *(int32_t *)v1 = unknown_cd7c4c();
    int32_t v2; // 0x10081cc
    return unknown_f3007c4c(8, v2);
}

// Address range: 0x10081f8 - 0x10081fa
int32_t function_10081f8(void) {
    // 0x10081f8
    return function_1008213();
}

// Address range: 0x10081fa - 0x1008213
int32_t function_10081fa(void) {
    // 0x10081fa
    int32_t v1; // 0x10081fa
    __asm_in_3((int16_t)v1);
    int32_t v2; // 0x10081fa
    int32_t * v3 = (int32_t *)(v2 + 0x6256085d); // 0x10081fc
    uint32_t v4 = *v3; // 0x10081fc
    *v3 = v4 / 0x80000000 | 2 * v4;
    return function_1008d44();
}

// Address range: 0x1008213 - 0x10082de
int32_t function_1008213(void) {
    // 0x1008213
    int32_t v1; // 0x1008213
    unsigned char v2 = (char)v1;
    *(char *)v1 = v2 / 32 | 8 * v2;
    uint32_t v3 = function_1008f17(); // 0x1008222
    char v4 = -64 * (char)(v3 / 256) + (char)v3; // 0x1008227
    int32_t v5 = v3 & -0x10000 | (int32_t)v4; // 0x1008229
    if (v4 != 0) {
        v5 = function_1012b40();
    }
    int32_t result; // 0x1008213
    if (v4 >= 0) {
        // 0x1008231
        unknown_1000db0();
        function_1007c26();
        return result;
    }
    // 0x10082a6
    int32_t v6; // 0x1008213
    int32_t v7 = v6 + 1; // 0x10082a6
    int32_t v8 = *(int32_t *)(v5 + 18); // 0x10082a8
    *(int32_t *)v8 = __asm_insd((int16_t)result);
    char * v9 = (char *)(v6 + 0x10000d); // 0x10082ac
    unsigned char v10 = *v9; // 0x10082ac
    int32_t v11; // 0x1008213
    *v9 = (char)v11;
    int32_t v12; // 0x1008213
    __asm_rep_movsd_memcpy((char *)v8, (char *)v12, (v11 & -256 | (int32_t)v10) / 4);
    char * v13 = (char *)v7; // 0x10082c9
    unsigned char v14 = *v13; // 0x10082c9
    unsigned char v15 = v14 + (char)v7; // 0x10082c9
    *v13 = v15;
    char * v16 = (char *)(v12 + 0x70cbf545); // 0x10082d6
    *v16 = *v16 + (v10 & 45);
    return *(int32_t *)(v6 - 3) & -256 | (v15 < v14 ? 29 : 28);
}

// Address range: 0x1008315 - 0x100831a
int32_t function_1008315(void) {
    // 0x1008315
    return function_8ca6761c();
}

// Address range: 0x1008322 - 0x1008340
int32_t function_1008322(void) {
    // 0x1008322
    int32_t v1; // 0x1008322
    function_1007c8e(v1, -0x7fff5500);
    int32_t result = unknown_60c80f24(); // 0x1008335
    int32_t v2; // 0x1008322
    *(char *)v2 = (char)result;
    return result;
}

// Address range: 0x1008356 - 0x1008357
int32_t function_1008356(int32_t a1) {
    // 0x1008356
    int32_t result; // 0x1008356
    return result;
}

// Address range: 0x1008358 - 0x100846f
int32_t function_1008358(void) {
    // 0x1008358
    int32_t v1; // 0x1008358
    char v2 = __asm_in_3((int16_t)v1); // 0x1008358
    *(int32_t *)(*(int32_t *)0x19d4f5c - 4) = 0;
    int32_t v3; // 0x1008358
    int32_t * v4 = (int32_t *)(v3 + 8); // 0x100836c
    int32_t v5; // bp-36, 0x1008358
    int32_t v6 = *(int32_t *)(v3 + 12) - (int32_t)&v5; // 0x100836f
    int32_t * v7 = (int32_t *)(v6 + 0x5d879051 + 4 * *v4); // 0x1008371
    *v7 = *v7 & -16;
    int32_t v8; // 0x1008358
    *v4 = v8 & -256 | (int32_t)v2;
    int32_t v9 = function_1007cd3(v5); // 0x100837c
    int32_t v10 = *(int32_t *)(v9 + 75); // 0x1008384
    int32_t v11 = *(int32_t *)0x1484fdd; // 0x100838a
    int32_t * v12 = (int32_t *)(v3 - 12); // 0x1008393
    *v12 = v10;
    if (!((v6 != 0 | *(int32_t *)(v9 + 8) + v10 <= v11))) {
        // 0x100839c
        *(int32_t *)(v3 + 33) = 0xa00ca01;
    }
    if (v10 > v11) {
        // 0x10083a7
        *v12 = v11;
        int32_t v13 = v3 + 32 + 2 * v1; // 0x10083aa
        return v13 - (v10 < v11 ? 98 : 97) & 255 | v13 & -256;
    }
    // 0x10083b5
    int64_t v14; // 0x1008358
    __asm_psubusb(v14, *(int64_t *)(v3 - 0x13a27626));
    if (v3 == 1) {
        // 0x10083c6
        return *(int32_t *)0x108015 & -256;
    }
    int32_t * v15 = (int32_t *)(v3 + 7); // 0x10083d0
    int32_t v16 = function_100c318(*v15); // 0x10083d3
    int32_t v17 = g77; // 0x10083da
    int32_t v18 = v16; // 0x10083e0
    int32_t v19 = v10; // 0x10083e0
    int32_t v20 = v17; // 0x10083e0
    int32_t v21; // 0x1008358
    if (v16 == 0) {
        int32_t v22 = v17 + 1; // 0x10083ec
        int32_t * v23 = (int32_t *)v10; // 0x10083ed
        *v23 = *v23 + v22;
        int32_t v24 = unknown_a7007c4c(v22, v22); // 0x10083f1
        char * v25; // bp-52, 0x1008358
        *(int32_t *)&v25 = (int32_t)g4;
        *(int32_t *)(v3 - 5) = v24;
        int32_t v26 = v10 & -256 | 53; // 0x10083ff
        function_100b0e7(v24, -0x3ffefeb1, (int32_t)v25);
        int32_t v27 = *(int32_t *)(__asm_int1() + 4); // 0x100841a
        int32_t v28 = *(int32_t *)0x1a6c95c; // 0x100841d
        v18 = *(int32_t *)(v3 + 6);
        int32_t * v29 = (int32_t *)(v3 - 6); // 0x1008429
        *v29 = *v29 | -116;
        *(int32_t *)v26 = v18;
        v19 = g77;
        v21 = *(int32_t *)(*v4 + 5) - *(int32_t *)(v26 + 4) + v27 - v28;
        v20 = *v15 - 0x4c7c5d48;
    }
    int32_t * v30 = (int32_t *)(v6 + 0x3a75000c); // 0x1008436
    *v30 = *v30 + 127;
    int32_t v31 = v18 - v20; // 0x1008443
    int32_t result = v6;
    while (result <= v21) {
        char * v32 = (char *)(v31 - 0x3dccf53a); // 0x100844e
        *v32 = *v32 & (char)v19;
        int32_t v33 = *(int32_t *)(result + 0x7ff056f7) + result - v21; // 0x1008456
        unsigned char v34 = (char)v33; // 0x100845c
        int32_t v35 = v33 & -0x10000 | (int32_t)(v34 % 19) | 256 * (int32_t)(v34 / 19); // 0x100845c
        v31++;
        if (v35 != 0) {
            int32_t * v36 = (int32_t *)(v35 + 71); // 0x1008464
            *v36 = *v36 - v19;
            return function_1008476();
        }
        result = 0;
    }
    // 0x100846f
    return result;
}

// Address range: 0x1008472 - 0x1008476
int32_t function_1008472(void) {
    // 0x1008472
    int32_t v1; // 0x1008472
    *(int32_t *)v1 = 2 * v1;
    int32_t result; // 0x1008472
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x1008476 - 0x100849a
int32_t function_1008476(void) {
    // 0x1008476
    int32_t v1; // 0x1008476
    char * v2 = (char *)(v1 + 77); // 0x1008479
    uint32_t v3; // 0x1008476
    *v2 = *v2 + (char)(v3 / 256);
    int32_t v4; // 0x1008476
    function_1011a3c(0x10000 * v4 / 0x10000, (int32_t)g4);
    int32_t v5; // 0x1008476
    return function_2c08c6c5(v5);
}

// Address range: 0x10084a5 - 0x1008642
int32_t function_10084a5(int32_t a1) {
    function_1007bc1((int32_t)&g125);
    int32_t v1; // 0x10084a5
    *(int32_t *)(v1 - 4) = 0;
    // 0x10084a5
    int32_t v2; // 0x10084a5
    while (v2 != 0) {
        // 0x10084ab
        function_1007bc1((int32_t)&g125);
        *(int32_t *)(v1 - 4) = 0;
    }
    // 0x10084d2
    int32_t v3; // 0x10084a5
    uint32_t v4; // 0x10084a5
    __asm_outsd((int16_t)v4, v3);
    char v5 = v4 / 256;
    int32_t v6 = unknown_3a414516(); // 0x10084de
    int32_t v7; // 0x10084a5
    int32_t v8 = v7;
    int32_t v9; // 0x10084a5
    int32_t v10 = v9;
    int32_t v11 = v6 | 106; // 0x10084e4
    char v12 = *(char *)116; // 0x10084e6
    int32_t v13 = v10 & -256 | (int32_t)(v12 + (char)v10); // 0x10084e6
    int32_t v14; // 0x10084a5
    int32_t v15; // 0x10084a5
    while (*(int32_t *)(v8 + 14) != 0) {
        // 0x10084ef
        v6 = v11 - 17;
        char v16 = *(char *)-92; // 0x10084f2
        char v17 = v16 + v5; // 0x10084f2
        *(char *)-92 = v17;
        if (v17 < 0 != ((v17 ^ v16) & (v17 ^ v5)) < 0) {
            // 0x10084f8
            int32_t v18; // bp-8, 0x10084a5
            v15 = &v18;
            int16_t v19; // 0x10084a5
            v14 = v19;
            goto lab_0x10084f9;
        }
        v8++;
        v10 = v13;
        v11 = v6 | 106;
        v12 = *(char *)116;
        v13 = v10 & -256 | (int32_t)(v12 + (char)v10);
    }
    // 0x10084f9
    v6 = v11 - 1;
    v14 = 0;
    goto lab_0x10084f9;
  lab_0x10084f9:;
    int32_t result = v6;
    int32_t * v20 = (int32_t *)(v14 + v13 & 0xffff); // 0x10084ff
    int32_t v21 = *v20 & v14; // 0x10084ff
    *v20 = v21;
    if (v21 >= 0) {
        // 0x100855f
        int32_t v22; // 0x10084a5
        __asm_rep_stosd_memset((char *)v13, 0x300030, *(int32_t *)(v22 - 0x1bf7393b) / 2);
        *(int32_t *)(v15 - 4) = 2;
        return 0x300030;
    }
    if (v21 == 0) {
        // 0x1008507
        *(int32_t *)(v15 - 4) = 3;
        int64_t v23 = 0x100000000 * (int64_t)(result >> 31) | (int64_t)result; // 0x100850e
        int32_t * v24 = (int32_t *)(v8 - 5); // 0x1008512
        *v24 = *v24 - (int32_t)(v23 % 3);
        return *(int32_t *)(v13 + 0x6d8303b9) | (int32_t)(v23 / 3);
    }
    int32_t * v25 = (int32_t *)(v14 + 85); // 0x1008523
    uint32_t v26 = *v25; // 0x1008523
    *v25 = v26 - 117;
    int32_t * v27 = (int32_t *)(v13 + 0x7269f47d); // 0x1008527
    *v27 = *v27 + result + (int32_t)(v26 < 117);
    char * v28 = (char *)(v13 - 0x97afd3d); // 0x1008535
    char v29 = *v28; // 0x1008535
    char v30 = result; // 0x1008535
    char v31 = v29 + v30; // 0x1008535
    *v28 = v31;
    if (v31 < 0 == ((v31 ^ v29) & (v31 ^ v30)) < 0 == (v31 != 0)) {
        int32_t * v32 = (int32_t *)v13; // 0x1008544
        *v32 = -0x5e22ffd0;
        int32_t v33 = result + 192 & 255 | result & -256; // 0x100854a
        int32_t * v34 = (int32_t *)(v33 + v13); // 0x100854c
        *v34 = *v34 + v15;
        __asm_fbld(*(float80_t *)(result - 119));
        return *v32 + v33;
    }
    int32_t * v35 = (int32_t *)(v8 - 13); // 0x100853d
    if (result < 0 | *v35 == 0) {
        // 0x1008543
        return result;
    }
    uint32_t v36 = v13 + v4; // 0x1008533
    int32_t v37 = v13; // 0x100857c
    if (result < 1) {
      lab_0x10085be:;
        uint32_t v38 = v36 / 256; // 0x10085be
        int32_t v39 = 2 * v38;
        char v40 = v39; // 0x10085be
        int32_t v41 = v37; // 0x10085c0
        if (v40 < 0 == (char)(v39 ^ v38) < 0 == (v40 != 0)) {
            while (true) {
                // 0x10085a9
                *(int16_t *)v41 = 48;
                unknown_1402ca1();
                v41 += v14;
            }
        }
        int16_t * v42 = (int16_t *)v37;
        if (*v35 == -34) {
            // 0x1008634
            *v42 = 0;
            return v37 & -256 | (int32_t)__asm_in_3((int16_t)(512 * v38 | v36 & 255));
        }
        // 0x10085c8
        *v42 = 176;
        *(char *)result = (char)(*(int32_t *)(v8 - 5) < 0);
        *(int32_t *)(v8 - 0x35933772) = v8 + 3;
        return -91;
    }
    int32_t * v43 = (int32_t *)(result - 74); // 0x1008582
    int32_t * v44 = (int32_t *)(result + 102); // 0x100858a
    int32_t v45 = *(int32_t *)(v8 - 21);
    int32_t v46 = result;
    bool v47 = false | (v46 & 14) > 9; // 0x1008581
    int32_t v48 = v47 ? v46 + 10 : v46; // 0x1008581
    uint32_t v49 = *v43; // 0x1008582
    uint32_t v50 = v49 + v15; // 0x1008582
    uint32_t v51 = v50 + (int32_t)v47; // 0x1008582
    bool v52 = v47 ? v51 <= v49 : v50 < v49; // 0x1008582
    *v43 = v51;
    char * v53 = (char *)(v13 + 1); // 0x1008587
    *v53 = *v53 | (char)((v48 & 15) + 85 + (int32_t)v52);
    *v44 = *v44 + v45;
    *(int32_t *)v13 = v36;
    int32_t v54 = v13 + v14; // 0x100858f
    int32_t v55 = v45 - 4; // 0x1008591
    int32_t v56 = unknown_168beba7(); // 0x1008596
    int32_t v57 = v56 + 192; // 0x100859b
    int32_t v58 = v56 & -256; // 0x100859b
    int32_t v59 = v57 & 255 | v58; // 0x100859b
    int32_t * v60 = (int32_t *)v55; // 0x100859d
    uint32_t v61 = *v60; // 0x100859d
    uint32_t v62 = v59 + v61; // 0x100859d
    *v60 = v62;
    *(int16_t *)v54 = (int16_t)v36;
    while (v62 >= v61 && v62 != 0) {
        int32_t v63 = v59 - 1; // 0x10085a4
        v37 = v54;
        if (v63 == 0) {
            goto lab_0x10085be;
        }
        v45 = v55;
        v46 = v63;
        v47 = (v57 & 15) > 16 | (v46 & 14) > 9;
        v48 = v47 ? v46 + 10 : v46;
        v49 = *v43;
        v50 = v49 + v15;
        v51 = v50 + (int32_t)v47;
        v52 = v47 ? v51 <= v49 : v50 < v49;
        *v43 = v51;
        v53 = (char *)(v54 + 1);
        *v53 = *v53 | (char)((v48 & 15) + 85 + (int32_t)v52);
        *v44 = *v44 + v45;
        *(int32_t *)v54 = v36;
        v54 += v14;
        v55 = v45 - 4;
        v56 = unknown_168beba7();
        v57 = v56 + 192;
        v58 = v56 & -256;
        v59 = v57 & 255 | v58;
        v60 = (int32_t *)v55;
        v61 = *v60;
        v62 = v59 + v61;
        *v60 = v62;
        *(int16_t *)v54 = (int16_t)v36;
    }
    int32_t * v64 = (int32_t *)(result - 124); // 0x1008603
    *v64 = *v64 + v15;
    int32_t v65 = v59 + 85; // 0x1008606
    int32_t v66 = v65 & 255 | v58; // 0x1008606
    char * v67 = (char *)(v54 + 1); // 0x1008608
    char v68 = v65; // 0x1008608
    *v67 = *v67 | v68;
    int32_t * v69 = (int32_t *)(result - 119); // 0x100860b
    *v69 = *v69 + v15;
    char * v70 = (char *)(v66 + 1); // 0x1008614
    char v71 = *v70; // 0x1008614
    *v70 = v71 + v68 + (char)(*(int32_t *)(v54 + 0x3df799c1) > 3 - v45);
    int32_t * v72 = (int32_t *)(v54 + 67); // 0x1008617
    *v72 = *v72 + v66;
    int32_t v73 = *(int32_t *)v66; // 0x1008623
    *(int32_t *)(v15 - 4) = v54 - ((v73 & v65) + 54 & 255 | v73 & v58);
    return (int32_t)_wcsrev(&g125);
}

// Address range: 0x1008648 - 0x1008649
int32_t function_1008648(int32_t a1) {
    // 0x1008648
    int32_t result; // 0x1008648
    return result;
}

// Address range: 0x100865c - 0x10086c8
int32_t function_100865c(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x100865c
    int32_t v1; // 0x100865c
    char v2 = *(char *)(v1 + 125); // 0x100865c
    uint32_t v3; // 0x100865c
    int32_t v4; // 0x100865c
    unsigned char v5 = *(char *)(v3 + 0x7dd285d0) + (char)v4; // 0x100865f
    uint32_t v6; // 0x100865c
    char v7 = (char)(v6 / 256) + (char)v3; // 0x1008665
    unsigned char v8 = v5 & 31; // 0x1008667
    char v9 = v7; // 0x1008667
    int32_t v10; // 0x100865c
    if (v8 != 0) {
        v9 = (char)(v3 / 256) >> v8;
        v10 = 256 * (int32_t)v9 | v3 & -0xff01;
    }
    int32_t v11; // 0x100865c
    if (v9 == 0) {
        // 0x100866b
        return *(int32_t *)(v11 + 7);
    }
    char * v12 = (char *)(v10 - 0x17cf1403); // 0x1008677
    *v12 = *v12 | v5;
    if (v11 == -9) {
        int32_t result = __asm_in_5(256 * (int16_t)v7 | (int16_t)(v2 | (char)v6)); // 0x1008684
        int32_t * v13 = (int32_t *)(v10 + 0x470ff06); // 0x1008686
        *v13 = *v13 - (v4 & -256 | (int32_t)v5);
        return result;
    }
    int32_t result3 = v11 + 0x6be850fc; // 0x1008697
    int32_t result2 = 0x10000 * v11 / 0x10000; // 0x100869d
    char v14 = 2 * (char)v11; // 0x100869e
    *(char *)result2 = v14;
    if (v14 == 0) {
        // 0x10086a3
        *(char *)result3 = (char)result2;
        return result2;
    }
    int32_t * v15 = (int32_t *)((v10 & -0xff01 | 0x2f00) + 0x5600fc76); // 0x10086b5
    *v15 = *v15 + 1;
    function_1007bc1((int32_t)&g125);
    return result3;
}

// Address range: 0x10086c8 - 0x10086ea
int32_t function_10086c8(int32_t a1, int32_t a2) {
    // 0x10086c8
    int32_t v1; // 0x10086c8
    int32_t result; // 0x10086c8
    if ((*(int32_t *)(a1 - 0x74e38258) & v1) != 0) {
        // 0x10086df
        return result;
    }
    // 0x10086d7
    int32_t v2; // 0x10086c8
    return result * v2;
}

// Address range: 0x10086ee - 0x10086f0
int32_t function_10086ee(void) {
    int32_t result = function_100874e((int32_t)&g125, (int32_t)&g125, (int32_t)&g125); // 0x10086ee
    return result;
}

// Address range: 0x10086fb - 0x1008742
int32_t function_10086fb(void) {
    // 0x10086fb
    int32_t v1; // 0x10086fb
    int32_t v2 = *(int32_t *)(v1 - 82); // 0x10086fb
    int32_t * v3 = (int32_t *)(v1 + 12); // 0x10086fe
    int32_t v4; // 0x10086fb
    *v3 = *v3 & v4;
    int32_t result; // 0x10086fb
    int32_t v5; // 0x10086fb
    if (v5 >= 0 != v5 != 0) {
        // 0x1008742
        return result;
    }
    // 0x1008703
    int32_t v6; // 0x10086fb
    unsigned char v7 = (char)v6 & 31;
    int32_t v8; // 0x10086fb
    int32_t v9 = v8;
    char * v10 = (char *)(v9 + 118); // 0x1008703
    char v11 = *v10; // 0x1008703
    *v10 = -v11;
    int32_t v12; // 0x10086fb
    int32_t v13 = v12; // 0x1008706
    int32_t v14; // 0x1008708
    int32_t v15; // 0x100870a
    int32_t v16; // 0x100871b
    char * v17; // 0x1008723
    unsigned char v18; // 0x1008723
    int32_t v19; // 0x10086fb
    if (v11 != 0) {
        // 0x100871d
        v14 = *(int32_t *)v2;
        v15 = v12 - 4;
        *(int32_t *)v15 = *(int32_t *)v14;
        v16 = v14 | 131;
        *(char *)(v16 + 2 * v19) = -1;
        __asm_int(155);
        v17 = (char *)v16;
        v18 = *v17;
        v13 = v15;
        if (v7 != 0) {
            *v17 = v18 >> 8 - v7 | v18 << v7;
            v13 = v15;
        }
    }
    // 0x1008725
    if (v6 == 0) {
        function_100875d();
    }
    // 0x1008727
    *(int32_t *)(v13 - 4) = v2;
    function_100bbd4();
    *(int32_t *)(v13 - 8) = v1 - 62;
    function_100aa6b();
    int32_t v20 = v13 - 12; // 0x1008736
    *(int32_t *)v20 = v2;
    v8 = v9 / 2;
    result = function_1009209();
    while (v9 >= 0 == v9 >= 2) {
        // 0x1008703
        v9 = v8;
        int32_t v21 = v20;
        v10 = (char *)(v9 + 118);
        v11 = *v10;
        *v10 = -v11;
        v13 = v21;
        if (v11 != 0) {
            // 0x100871d
            v14 = *(int32_t *)v2;
            v15 = v21 - 4;
            *(int32_t *)v15 = *(int32_t *)v14;
            v16 = v14 | 131;
            *(char *)(v16 + 2 * v19) = -1;
            __asm_int(155);
            v17 = (char *)v16;
            v18 = *v17;
            v13 = v15;
            if (v7 != 0) {
                *v17 = v18 >> 8 - v7 | v18 << v7;
                v13 = v15;
            }
        }
        // 0x1008725
        if (v6 == 0) {
            function_100875d();
        }
        // 0x1008727
        *(int32_t *)(v13 - 4) = v2;
        function_100bbd4();
        *(int32_t *)(v13 - 8) = v1 - 62;
        function_100aa6b();
        v20 = v13 - 12;
        *(int32_t *)v20 = v2;
        v8 = v9 / 2;
        result = function_1009209();
    }
    // 0x1008742
    return result;
}

// Address range: 0x100874e - 0x1008754
int32_t function_100874e(int32_t a1, int32_t a2, int32_t a3) {
    // 0x100874e
    int32_t result; // 0x100874e
    return result;
}

// Address range: 0x1008754 - 0x1008755
int32_t function_1008754(void) {
    // 0x1008754
    int32_t result; // 0x1008754
    return result;
}

// Address range: 0x100875d - 0x100875e
int32_t function_100875d(void) {
    // 0x100875d
    int32_t result; // 0x100875d
    return result;
}

// Address range: 0x100877e - 0x100877f
int32_t function_100877e(int32_t a1) {
    // 0x100877e
    int32_t result; // 0x100877e
    return result;
}

// Address range: 0x10087b7 - 0x10087e1
int32_t function_10087b7(int32_t a1) {
    // 0x10087b7
    int32_t v1; // 0x10087b7
    int32_t * v2 = (int32_t *)(v1 + 0x7038ffaf); // 0x10087b7
    *v2 = *v2 - 1;
    int32_t v3; // 0x10087b7
    *(int32_t *)v1 = v3 + v1;
    int32_t v4; // 0x10087b7
    int32_t result; // 0x10087b7
    *(int32_t *)(v4 + 3) = unknown_f007e82(result, a1);
    int32_t v5; // 0x10087b7
    function_1007bc1(v5);
    int32_t v6; // 0x10087b7
    *(int32_t *)(v4 - 1) = __asm_insd((int16_t)v6);
    bool v7; // 0x10087b7
    int32_t * v8 = (int32_t *)(result + 0x5e5fc78b + (v7 ? -4 : 4)); // 0x10087d7
    *v8 = *v8 - 1;
    return result;
}

// Address range: 0x1008818 - 0x100881e
int32_t function_1008818(void) {
    // 0x1008818
    int32_t result; // 0x1008818
    return result;
}

// Address range: 0x1008822 - 0x1008827
int32_t function_1008822(void) {
    // 0x1008822
    return function_c0008963();
}

// Address range: 0x1008827 - 0x10088c1
int32_t function_1008827(void) {
    // 0x1008827
    int32_t v1; // 0x1008827
    int32_t v2; // 0x1008827
    if (*(int32_t *)(v1 - 96) == v2) {
        function_1010535();
    }
    // 0x1008832
    int32_t v3; // 0x1008827
    int64_t v4; // 0x1008827
    __asm_psubb(v4, *(int64_t *)(v3 + 0x53002100));
    int32_t v5 = function_1007c26(); // 0x1008844
    *(int32_t *)(v1 - 4) = v5;
    int32_t v6 = *(int32_t *)v5; // 0x100884c
    unknown_10001c1(v6);
    int32_t v7; // 0x1008827
    int32_t v8; // 0x1008827
    *(char *)(v7 + 1) = (char)v8;
    int32_t * v9 = (int32_t *)(v2 + 0x470feff); // 0x100885c
    *v9 = *v9 + v8;
    *(int32_t *)v8 = *(int32_t *)(v1 + 22);
    __asm_int3();
    __asm_wait();
    unknown_b1007bc1(*(int32_t *)(*(int32_t *)(v6 - 4) + 4));
    int32_t v10 = *(int32_t *)(*(int32_t *)-0x1efeb078 + 88); // 0x10088a6
    int32_t v11 = unknown_21007bfb(*(int32_t *)(v10 + 4)); // 0x10088ac
    *(int32_t *)(*(int32_t *)(*(int32_t *)(v6 + 0x45889fc) + 96) + 4) = v11;
    return function_1008942();
}

// Address range: 0x10088e2 - 0x10088e7
int32_t function_10088e2(void) {
    // 0x10088e2
    return function_71908972();
}

// Address range: 0x10088ec - 0x1008910
int32_t function_10088ec(void) {
    // 0x10088ec
    int32_t v1; // 0x10088ec
    int32_t * v2 = (int32_t *)(v1 + 0x1892d4d); // 0x10088ec
    *v2 = *v2 - 1;
    int32_t v3 = (int32_t)g87; // 0x10088f2
    int32_t v4 = v3 & 114 | 141; // 0x1008902
    char * v5 = (char *)(v4 | v3 & -256); // 0x1008906
    *v5 = *v5 + (char)v4;
    __asm_int3();
    return function_8c067c12();
}

// Address range: 0x1008920 - 0x1008923
int32_t function_1008920(void) {
    // 0x1008920
    int32_t result; // 0x1008920
    return result;
}

// Address range: 0x1008934 - 0x100893b
int32_t function_1008934(void) {
    // 0x1008934
    int32_t result; // 0x1008934
    return result;
}

// Address range: 0x1008942 - 0x1008968
int32_t function_1008942(void) {
    // 0x1008942
    int32_t v1; // 0x1008942
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x1008942
    int32_t v3 = *(int32_t *)(v2 + 4); // 0x1008945
    int32_t v4; // 0x1008942
    int32_t v5 = *(int32_t *)(v4 - 4); // 0x1008948
    int32_t v6 = v5 + 0xc10c8d; // 0x100894e
    char * v7 = (char *)(v5 + 0xc10cb1); // 0x1008954
    *v7 = *v7 + (char)v3;
    uint32_t v8; // 0x1008942
    *(int32_t *)v8 = v8 / 4 | 0x40000000 * v8;
    __asm_rep_movsd_memcpy((char *)*(int32_t *)(v5 + 4), (char *)v2, v3);
    __asm_out_6(139, (char)v6);
    return v6 & -256 | v5 + 200 & 255;
}

// Address range: 0x100896c - 0x1008997
int32_t function_100896c(void) {
    // 0x100896c
    uint32_t v1; // 0x100896c
    int32_t v2; // 0x100896c
    char * v3 = (char *)(v1 - 88 + v2); // 0x100896c
    unsigned char v4 = *v3; // 0x100896c
    uint32_t v5; // 0x100896c
    uint32_t v6 = v5 / 256; // 0x100896c
    bool v7; // 0x100896c
    char v8 = v7; // 0x100896c
    unsigned char v9 = v8 + (char)v6; // 0x100896c
    char v10 = v4 - v9; // 0x100896c
    *v3 = v10;
    int32_t v11 = function_1007f57(); // 0x1008970
    uint32_t v12; // 0x100896c
    if (v1 == v12) {
        // 0x100897e
        return function_1c48996();
    }
    int32_t v13 = v11 + v6 + (int32_t)(v7 ? v9 != -1 | v4 < v10 - v8 : v4 < v9); // 0x1008975
    unsigned char v14 = (char)v13; // 0x1008996
    bool v15 = v1 < v12 | v14 > 153;
    int32_t v16 = v15 ? 102 : 6;
    int32_t v17 = v15 ? v13 + 96 : v13;
    return ((v1 & 15) - (v12 & 15) > 15 | (v14 & 14) > 9 ? v16 + v13 : v17) & 255 | v11 & -256;
}

// Address range: 0x10089ba - 0x10089bd
int32_t function_10089ba(void) {
    // 0x10089ba
    int32_t result; // 0x10089ba
    return result;
}

// Address range: 0x10089c1 - 0x10089c9
int32_t function_10089c1(void) {
    // 0x10089c1
    int32_t v1; // 0x10089c1
    int32_t result = function_1012390(v1); // 0x10089c2
    int32_t v2; // 0x10089c1
    int32_t v3; // 0x10089c1
    *(int32_t *)v2 = __asm_insd((int16_t)v3);
    return result;
}

// Address range: 0x10089fb - 0x1008a3f
int32_t function_10089fb(int32_t a1) {
    // 0x10089fb
    int32_t v1; // 0x10089fb
    int32_t v2 = v1 - 1; // 0x1008a02
    int32_t result; // 0x10089fb
    bool v3; // 0x10089fb
    if (v2 != 0 != v3) {
        // 0x1008a05
        int32_t v4; // 0x10089fb
        int32_t v5; // 0x10089fb
        __asm_rep_movsb_memcpy((char *)v4, (char *)v5, v2);
        int32_t v6; // 0x10089fb
        function_1007bc1(*(int32_t *)(v6 - 69));
        *(int32_t *)(v6 - 8) = 0;
        int32_t v7; // 0x10089fb
        result = unknown_3a00be29(v6 - 4, v7);
    }
    // 0x1008a3e
    return result;
}

// Address range: 0x1008a3f - 0x1008a85
int32_t function_1008a3f(void) {
    // 0x1008a3f
    int32_t v1; // 0x1008a3f
    int32_t v2; // 0x1008a3f
    bool v3; // 0x1008a3f
    if (v3) {
        // 0x1008a5f
        int32_t v4; // 0x1008a3f
        *(int32_t *)(v4 - 37) = 0;
        if (unknown_1671a18(v2) != 0) {
            function_1a009b79();
        }
        // 0x1008a73
        return function_1011913(*(int32_t *)(v1 + 4));
    }
    char * v5 = (char *)(v1 + 0x5eb7fc45); // 0x1008a49
    unsigned char v6 = *v5; // 0x1008a49
    bool v7; // 0x1008a3f
    char v8 = v7; // 0x1008a49
    int32_t v9; // 0x1008a3f
    unsigned char v10 = v8 + (char)v9; // 0x1008a49
    char v11 = v6 - v10; // 0x1008a49
    bool v12 = v7 ? v10 != -1 | v6 < v11 - v8 : v6 < v10; // 0x1008a49
    char v13 = llvm_ctpop_i8(v11); // 0x1008a49
    *v5 = v11;
    return v2 & -0xff01 | 256 * (128 * (int32_t)(v11 < 0) | 64 * (int32_t)(v11 == 0) | 16 * (int32_t)(v8 - (v10 & 15) + (v6 & 15) > 15) | (int32_t)v12 | 4 * (int32_t)((v13 & 1) == 0)) | 512;
}

// Address range: 0x1008a86 - 0x1008b22
int32_t function_1008a86(void) {
    // 0x1008a86
    int32_t v1; // 0x1008a86
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x1008a86
    char v3 = llvm_ctpop_i8((char)v2 + 1); // 0x1008a8a
    int32_t v4; // 0x1008a86
    int32_t v5; // 0x1008a86
    bool v6; // 0x1008a86
    int32_t hMem = unknown_7e8642(v5 - v4 + (int32_t)v6, *(int32_t *)0x6a0140ad, v4); // 0x1008a94
    int32_t v7; // 0x1008a86
    if ((v3 & 1) == 0) {
        // 0x1008b18
        return *(int32_t *)(v7 - 4);
    }
    int32_t * v8 = (int32_t *)((8 * v7 | 2) + (int32_t)LocalFree((int32_t *)hMem)); // 0x1008aab
    *v8 = *v8 + 1;
    return __asm_int1();
}

// Address range: 0x1008b1c - 0x1008b1d
int32_t function_1008b1c(void) {
    // 0x1008b1c
    int32_t result; // 0x1008b1c
    return result;
}

// Address range: 0x1008b22 - 0x1008b25
int32_t function_1008b22(int32_t a1) {
    // 0x1008b22
    int32_t v1; // 0x1008b22
    return v1 + 232 & 255 | v1 & -256;
}

// Address range: 0x1008b2e - 0x1008c01
int32_t function_1008b2e(int32_t a1) {
    // 0x1008b2e
    int32_t v1; // 0x1008b2e
    int32_t v2; // 0x1008b2e
    if (v1 > 0) {
        unsigned char v3 = *(char *)0x458b044e; // 0x1008b47
        int32_t v4 = v2 & -256; // 0x1008b47
        return v4 | (int32_t)(*(char *)(v4 | (int32_t)v3) ^ v3);
    }
    int32_t v5 = *(int32_t *)(v2 + 4); // 0x1008b44
    int32_t v6; // 0x1008b2e
    uint32_t v7 = (4 * v6 + 12) / 4; // 0x1008b59
    int32_t v8 = __asm_iretd(); // 0x1008b5c
    int32_t v9; // 0x1008b2e
    *(int32_t *)v9 = v9 - 109;
    __asm_rep_movsb_memcpy((char *)-0x74000010, (char *)v5, v7);
    int32_t v10 = *(int32_t *)-0x49feb0fd; // bp-4, 0x1008b65
    if (v9 < 109) {
        int32_t v11 = unknown_ffeec1(*(int32_t *)(*(int32_t *)(v1 - 5) + 123)); // 0x1008bec
        char * v12 = (char *)(v1 + 0x70ff0442); // 0x1008bf7
        *v12 = *v12 + (char)v11;
        int32_t result = v11 + 232 & 255 | v11 & -256; // 0x1008bfd
        int32_t v13; // 0x1008b2e
        __asm_out_2((int16_t)v13, result);
        return result;
    }
    int32_t v14 = &v10;
    int32_t v15 = v14 - 4; // 0x1008b6e
    *(int32_t *)v15 = 0x36f2e8;
    int32_t v16; // 0x1008b2e
    unsigned char v17 = (char)(v16 / 128) & -2; // 0x1008b73
    int32_t v18 = 256 * (int32_t)v17 | v16 & -0xff01; // 0x1008b73
    while (v17 != 0) {
        // 0x1008b6d
        v14 = v15;
        v15 = v14 - 4;
        *(int32_t *)v15 = 0x36f2e8;
        v17 = (char)(v18 / 128) & -2;
        v18 = 256 * (int32_t)v17 | v18 & -0xff01;
    }
    // 0x1008b77
    *(int32_t *)(v14 - 8) = v18;
    return v8 & (v7 | -256);
}

// Address range: 0x1008c19 - 0x1008c1a
int32_t function_1008c19(int32_t a1) {
    // 0x1008c19
    int32_t result; // 0x1008c19
    return result;
}

// Address range: 0x1008c45 - 0x1008c5c
int32_t function_1008c45(int32_t a1) {
    // 0x1008c45
    int32_t v1; // 0x1008c45
    int32_t * v2 = (int32_t *)(v1 - 0x58010000); // 0x1008c45
    int32_t v3; // 0x1008c45
    bool v4; // 0x1008c45
    *v2 = *v2 + v3 + (int32_t)v4;
    int32_t v5; // 0x1008c45
    *(int32_t *)(v5 - 0x10811710) = -1;
    int32_t result; // 0x1008c45
    return result;
}

// Address range: 0x1008c96 - 0x1008c97
int32_t function_1008c96(void) {
    // 0x1008c96
    int32_t result; // 0x1008c96
    return result;
}

// Address range: 0x1008cab - 0x1008cb0
int32_t function_1008cab(void) {
    // 0x1008cab
    return function_8ca67fb2();
}

// Address range: 0x1008ce5 - 0x1008ce6
int32_t function_1008ce5(void) {
    // 0x1008ce5
    int32_t result; // 0x1008ce5
    return result;
}

// Address range: 0x1008cef - 0x1008d44
int32_t function_1008cef(void) {
    // 0x1008cef
    int32_t v1; // 0x1008cef
    int32_t v2; // 0x1008cef
    int32_t v3; // 0x1008cef
    *(char *)v1 = *(char *)(v3 + v2);
    int32_t v4; // 0x1008cef
    int32_t v5 = *(int32_t *)(v4 - 113); // 0x1008cfc
    int32_t v6; // 0x1008cef
    unknown_1015e54(-0x380c0c75 * v6);
    unknown_65011a18(*(int32_t *)*(int32_t *)(v4 - 4));
    function_1007bd1();
    bool v7; // 0x1008cef
    return *(int32_t *)(v1 + 0x458d5618 + (v7 ? -1 : 1) + 8 * v5) + 1;
}

// Address range: 0x1008d44 - 0x1008d48
int32_t function_1008d44(void) {
    // 0x1008d44
    int32_t result; // 0x1008d44
    return result;
}

// Address range: 0x1008d7b - 0x1008d7c
int32_t function_1008d7b(int32_t a1, int32_t a2) {
    // 0x1008d7b
    int32_t result; // 0x1008d7b
    return result;
}

// Address range: 0x1008d93 - 0x1008d98
int32_t function_1008d93(void) {
    // 0x1008d93
    return function_8ca6809a();
}

// Address range: 0x1008dba - 0x1008e2c
int32_t function_1008dba(int32_t a1) {
    // 0x1008dba
    int32_t v1; // 0x1008dba
    int32_t * v2 = (int32_t *)(v1 + 0x4189fc4d); // 0x1008dba
    *v2 = *v2 - 1;
    int32_t v3; // 0x1008dba
    bool v4; // 0x1008dba
    int32_t v5 = (v4 ? -1 : 1) + v3; // 0x1008de6
    int32_t * v6 = (int32_t *)*(int32_t *)v5; // 0x1008de9
    *v6 = -*v6;
    uint16_t v7; // 0x1008dba
    int32_t v8 = v7; // 0x1008def
    *(char *)v8 = 2 * (char)v7;
    int32_t * v9 = (int32_t *)(v8 & 0xff00 | (int32_t)*(char *)v5); // 0x1008df7
    *v9 = -*v9;
    if (*(int32_t *)(*(int32_t *)(a1 - 0x37745e0e) - 4) == 0) {
        // 0x1008e0a
        int32_t v10; // 0x1008dba
        int32_t v11; // 0x1008dba
        if ((4 * v11 + 12) / 4 * v10 == 1) {
            // 0x1008e1d
            function_1007bd1();
            return 1;
        }
    }
    // 0x1008e1d
    function_1007bd1();
    return 0;
}

// Address range: 0x1008e56 - 0x1008e62
int32_t function_1008e56(int32_t a1) {
    // 0x1008e56
    int32_t result; // 0x1008e56
    return result;
}

// Address range: 0x1008e73 - 0x1008e80
int32_t function_1008e73(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x1008e73
    int32_t v1; // 0x1008e73
    bool v2; // 0x1008e73
    int32_t v3 = v1 + 12 + (int32_t)v2; // 0x1008e73
    char * v4 = (char *)(v3 & 255 | v1 & -256); // 0x1008e75
    *v4 = *v4 + (char)v3;
    int32_t v5; // 0x1008e73
    char * v6 = (char *)(v5 - 63); // 0x1008e77
    int32_t v7; // 0x1008e73
    *v6 = *v6 + (char)v7;
    return function_8ca68182();
}

// Address range: 0x1008e90 - 0x1008ed6
int32_t function_1008e90(void) {
    // 0x1008e90
    int32_t v1; // 0x1008e90
    int32_t * v2 = (int32_t *)(v1 + 0x70d9fc45); // 0x1008e90
    *v2 = *v2 - 1;
    int32_t v3 = unknown_ea0089fb(*(int32_t *)(*(int32_t *)(v1 + 4) + 121)); // 0x1008e9e
    int32_t v4; // 0x1008e90
    int32_t v5; // 0x1008e90
    *(int32_t *)(v5 + 0x4da8b04) = v4 - 1;
    uint32_t v6 = *(int32_t *)(v1 + 125); // 0x1008eac
    int32_t v7 = *(int32_t *)v6; // 0x1008eb2
    char * v8 = (char *)(v1 - 63 + 4 * v6); // 0x1008eba
    *v8 = *v8 + (char)(v6 / 256);
    int32_t v9; // 0x1008e90
    __asm_rep_movsb_memcpy((char *)(v7 + 4), (char *)(v9 + 4), v3 + 1 & 2 | 1);
    return function_56180406();
}

// Address range: 0x1008ed6 - 0x1008f0b
int32_t function_1008ed6(void) {
    // 0x1008ed6
    int32_t result; // 0x1008ed6
    unsigned char v1 = (char)result;
    if (v1 >= 81) {
        // 0x1008f08
        return result;
    }
    // 0x1008edb
    *(char *)result = 2 * v1;
    int32_t v2; // 0x1008ed6
    uint32_t v3 = result - v2; // 0x1008edd
    uint32_t v4 = *(int32_t *)(v3 - 117); // 0x1008edf
    uint32_t v5; // 0x1008ed6
    int32_t v6 = (0x100000000 * (int64_t)v5 | (int64_t)v3) / (int64_t)v4; // 0x1008edf
    return v6 - 1 & -256 | v6 + 138 & 255;
}

// Address range: 0x1008f0f - 0x1008f16
int32_t function_1008f0f(int32_t a1, int32_t a2) {
    // 0x1008f0f
    int32_t result; // 0x1008f0f
    return result;
}

// Address range: 0x1008f17 - 0x1008f7a
int32_t function_1008f17(void) {
    // 0x1008f17
    uint32_t v1; // 0x1008f17
    int32_t v2; // 0x1008f17
    *(char *)v2 = (char)(v1 / 256);
    int32_t v3; // 0x1008f17
    char * v4 = (char *)(v3 + 51); // 0x1008f1f
    *v4 = -1 - *v4;
    function_1007bd1();
    int32_t v5 = function_1007c26(); // 0x1008f2c
    bool v6; // 0x1008f17
    if (!v6) {
        // 0x1008f78
        return v5 & -256 | (int32_t)__asm_in_3((int16_t)v1);
    }
    // 0x1008f33
    int32_t v7; // 0x1008f17
    *(char *)(9 * v7) = (char)*(int32_t *)v5;
    int32_t v8; // 0x1008f17
    int32_t * v9 = (int32_t *)(v8 + 0x5d8bfc45); // 0x1008f3a
    *v9 = *v9 - 1;
    int32_t v10; // bp-4, 0x1008f17
    *(int32_t *)v8 = (int32_t)&v10;
    int32_t * v11 = (int32_t *)(v8 & -256); // 0x1008f5a
    *v11 = *v11 & v7;
    int32_t result; // 0x1008f17
    if ((v2 & 0x100000) != 0) {
        result = function_1008f0f((int32_t)&g125, (int32_t)&g125);
    }
    // 0x1008f6a
    return result;
}

// Address range: 0x1008f7b - 0x1008ffb
int32_t function_1008f7b(int32_t a1, int32_t a2) {
    // 0x1008f7b
    int32_t v1; // 0x1008f7b
    int32_t * v2 = (int32_t *)(v1 + 0x6083fc45); // 0x1008f7b
    *v2 = *v2 - 1;
    int32_t v3; // 0x1008f7b
    unsigned char v4 = (char)v3; // 0x1008f81
    unsigned char v5 = v4 - 115; // 0x1008f81
    int32_t v6 = v3 & -256; // 0x1008f81
    if (v4 > 114 || v5 == 0) {
        // 0x1008f85
        return v3 + 193 & 255 | v6;
    }
    // 0x1008feb
    return (v6 | (int32_t)v5) - 0x14b909f5;
}

// Address range: 0x1008ffc - 0x1009002
int32_t function_1008ffc(int32_t a1, int32_t a2) {
    // 0x1008ffc
    int32_t result; // 0x1008ffc
    return result;
}

// Address range: 0x1009010 - 0x100901a
int32_t function_1009010(void) {
    // 0x1009010
    int32_t v1; // 0x1009010
    int32_t * v2 = (int32_t *)(v1 + 0x8e85e71); // 0x1009013
    *v2 = *v2 - 1;
    int32_t v3; // 0x1009010
    int32_t v4; // 0x1009010
    return v4 & -256 | (int32_t)__asm_in_3((int16_t)v3);
}

// Address range: 0x1009020 - 0x1009095
int32_t function_1009020(int32_t a1) {
    int32_t result = __asm_wait(); // 0x1009022
    int32_t v1; // 0x1009020
    int32_t * v2 = (int32_t *)(v1 + 0x5d8bfc45); // 0x1009025
    *v2 = *v2 - 1;
    int32_t v3; // 0x1009020
    char * v4 = (char *)(v3 - 0xfc74d0); // 0x100902b
    *v4 = *v4 | (char)v3;
    return result;
}

// Address range: 0x1009095 - 0x10090cc
int32_t function_1009095(void) {
    int32_t v1 = __asm_int3(); // 0x100909c
    bool v2; // 0x1009095
    int32_t v3 = v2 ? -4 : 4; // 0x100909d
    int32_t v4; // 0x1009095
    int32_t v5 = v3 + v4; // 0x100909d
    int32_t * v6 = (int32_t *)v5; // 0x10090a0
    uint32_t v7 = *v6; // 0x10090a0
    int32_t v8; // 0x1009095
    uint32_t v9 = (v8 & 2) != 0 ? 4 : 3; // 0x10090a0
    *v6 = v7 - v9;
    int32_t v10; // 0x1009095
    __asm_rep_movsb_memcpy((char *)(v3 + v10), (char *)v5, v1);
    int32_t v11; // 0x1009095
    char * v12 = (char *)(v11 - 0x17af03bb); // 0x10090ab
    *v12 = *v12 - (char)((v8 & 2) != 0 | v7 < v9);
    int32_t result = function_1011a00((int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125); // 0x10090ba
    *(int32_t *)(*(int32_t *)-9 - 4) = *(int32_t *)(v11 - 3);
    return result;
}

// Address range: 0x10090ce - 0x10090d7
int32_t function_10090ce(int32_t a1) {
    // 0x10090ce
    int32_t result; // 0x10090ce
    return result;
}

// Address range: 0x10090d7 - 0x10091ac
int32_t function_10090d7(int32_t a1, int32_t a2) {
    // 0x10090d7
    int32_t v1; // 0x10090d7
    int32_t v2 = v1 & -0xff01; // 0x10090d8
    int32_t result; // 0x10090d7
    int32_t v3; // 0x10090d7
    bool v4; // 0x10090d7
    if (v4) {
        // 0x100912f
        int32_t v5; // 0x10090d7
        int32_t v6; // 0x10090d7
        __asm_rep_movsb_memcpy((char *)v5, (char *)v6, v3);
        int32_t v7 = unknown_c4ffb2c1(*(int32_t *)(a1 + 4)); // 0x100913b
        result = v7;
        bool v8; // 0x10090d7
        bool v9; // 0x10090d7
        if (!v9 && !v8) {
            // 0x1009142
            bool v10; // 0x10090d7
            int32_t v11 = v10 ? -1 : 1; // 0x1009133
            *(int32_t *)(v7 + 4) = 0;
            int32_t v12 = unknown_6a7bac(); // 0x100914f
            *(int32_t *)((v2 | 0xec00) + 0x4708003) = 1;
            int32_t v13 = v12 + 116; // 0x1009161
            uint32_t v14 = v13 & 255 | v12 & -256; // 0x1009161
            char * v15 = (char *)v14; // 0x100916d
            *v15 = *v15 + (char)v13;
            int32_t v16; // 0x10090d7
            __asm_rep_movsd_memcpy((char *)(v16 + 1), (char *)(v5 - 1 + v11 * v3), v14 / 2 & 0x3fffffff);
            abort();
            // UNREACHABLE
        }
    } else {
        // 0x10090dc
        int32_t v17; // 0x10090d7
        int32_t * v18 = (int32_t *)(v17 - 4); // 0x10090e1
        *v18 = 0;
        function_1007bd1();
        *v18 = 0;
        int32_t v19 = function_1007c26(); // 0x10090ec
        *v18 = v19;
        unknown_fff4c1(*(int32_t *)v19);
        char * v20 = (char *)(v3 - 0xe1274d0); // 0x1009100
        *v20 = *v20 | (char)v3;
        int32_t v21 = v3 - 1; // 0x1009108
        result = *(int32_t *)(v17 - 107);
        if (v21 != 0) {
            int32_t v22 = v2 | 0xd800; // 0x1009106
            int32_t * v23 = (int32_t *)(v22 + 0x189fc4d); // 0x100910e
            *v23 = *v23 | -117;
            int32_t v24 = *(int32_t *)(v22 + 0x44e8b3f) + v21; // 0x1009115
            *(char *)(4 * v24 + 0xb9000c) = (char)v24;
            int16_t v25; // 0x10090d7
            return function_8ca68431(v25);
        }
    }
    // 0x100910a
    return result;
}

// Address range: 0x10091ad - 0x10091bb
int32_t function_10091ad(void) {
    // 0x10091ad
    int32_t v1; // 0x10091ad
    unsigned char v2 = (char)v1; // 0x10091ad
    bool v3; // 0x10091ad
    bool v4 = v2 > 153 | v3;
    int32_t v5; // 0x10091ad
    bool v6; // 0x10091ad
    if (v6 || (v2 & 14) > 9) {
        v5 = (v4 ? 102 : 6) + v1 & 255 | v1 & -256;
    } else {
        v5 = (v4 ? v1 + 96 : v1) & 255 | v1 & -256;
    }
    int32_t v7 = v5;
    uint32_t result = v7 - *(int32_t *)v7; // 0x10091ae
    char * v8 = (char *)(2 * result - 0x6617af04); // 0x10091b1
    *v8 = *v8 + (char)(result / 256);
    return result;
}

// Address range: 0x10091c1 - 0x10091cf
int32_t function_10091c1(int32_t a1) {
    // 0x10091c1
    function_100bbd4();
    int32_t v1; // 0x10091c1
    return *(int32_t *)(v1 - 4);
}

// Address range: 0x10091cf - 0x10091ec
int32_t function_10091cf(void) {
    // 0x10091cf
    int32_t v1; // 0x10091cf
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x10091cf
    *(int32_t *)0x4b014f5c = *(int32_t *)0x4b014f5c - v2;
    int32_t v3; // 0x10091cf
    int32_t v4; // 0x10091cf
    return unknown_207bd1(*(int32_t *)(v3 - 4), v4) & -0xff01;
}

// Address range: 0x10091ec - 0x10091ed
int32_t function_10091ec(int32_t a1) {
    // 0x10091ec
    int32_t result; // 0x10091ec
    return result;
}

// Address range: 0x1009209 - 0x100920a
int32_t function_1009209(void) {
    // 0x1009209
    int32_t result; // 0x1009209
    return result;
}

// Address range: 0x100920a - 0x1009216
int32_t function_100920a(void) {
    // 0x100920a
    return function_468c9169();
}

// Address range: 0x1009216 - 0x1009248
int32_t function_1009216(void) {
    // 0x1009216
    int32_t v1; // 0x1009216
    int32_t v2 = unknown_127bfb(*(int32_t *)(v1 + 4)); // 0x1009223
    int32_t v3; // 0x1009216
    int32_t * v4 = (int32_t *)(v3 - 8); // 0x1009228
    int32_t v5 = *v4; // 0x1009228
    *(int32_t *)v5 = v2;
    int32_t v6 = *v4; // 0x1009234
    int32_t v7 = v6 & 114 | 141; // 0x100923a
    char * v8 = (char *)(v7 | v6 & -256); // 0x100923e
    *v8 = *v8 + (char)v7;
    return function_8ca6854a(v5);
}

// Address range: 0x1009256 - 0x100925b
int32_t function_1009256(void) {
    // 0x1009256
    return function_468c925a();
}

// Address range: 0x100926a - 0x100926f
int32_t function_100926a(void) {
    // 0x100926a
    return function_4e0a926e();
}

// Address range: 0x1009280 - 0x1009291
int32_t function_1009280(void) {
    // 0x1009280
    int32_t v1; // 0x1009280
    float80_t v2; // 0x1009280
    *(int32_t *)(v1 + 12) = (int32_t)v2;
    int32_t v3; // 0x1009280
    return v3 + 141 & 255 | v3 & -256;
}

// Address range: 0x10092c6 - 0x10092cb
int32_t function_10092c6(void) {
    // 0x10092c6
    return function_768a91dc();
}

// Address range: 0x10092ec - 0x10092f1
int32_t function_10092ec(void) {
    // 0x10092ec
    return function_4e8c92f0();
}

// Address range: 0x10092f5 - 0x10092fb
int32_t function_10092f5(int32_t a1) {
    // 0x10092f5
    int32_t result; // 0x10092f5
    return result;
}

// Address range: 0x100931e - 0x100931f
int32_t function_100931e(void) {
    // 0x100931e
    int32_t result; // 0x100931e
    return result;
}

// Address range: 0x100932e - 0x1009336
int32_t function_100932e(void) {
    // 0x100932e
    return function_100931e();
}

// Address range: 0x100935b - 0x1009360
int32_t function_100935b(void) {
    // 0x100935b
    return function_8ca68727();
}

// Address range: 0x1009363 - 0x1009375
int32_t function_1009363(void) {
    // 0x1009363
    int32_t v1; // 0x1009363
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x1009363
    return v2 ^ (int32_t)&g113;
}

// Address range: 0x1009389 - 0x10093b1
int32_t function_1009389(int32_t a1) {
    // 0x1009389
    int32_t v1; // 0x1009389
    *(char *)v1 = 0;
    int32_t v2; // 0x1009389
    char * v3 = (char *)(v2 + 127); // 0x100938c
    uint32_t v4; // 0x1009389
    *v3 = *v3 + (char)(v4 / 256);
    int32_t v5; // 0x1009389
    int32_t v6; // 0x1009389
    *(int32_t *)(v6 + 1) = v5;
    int32_t v7 = v5;
    *(char *)v7 = *(char *)&v5 + (char)v7;
    int16_t v8; // 0x1009389
    int32_t v9 = *(int32_t *)unknown_ffffe887(v8); // 0x10093a2
    function_1007c36(0x10000 * v9 / 0x10000);
    int32_t v10; // 0x1009389
    return *(int32_t *)(v10 - 4);
}

// Address range: 0x10093b1 - 0x10093b7
int32_t function_10093b1(void) {
    // 0x10093b1
    int32_t v1; // 0x10093b1
    int32_t result; // 0x10093b1
    *(int32_t *)v1 = result + v1;
    return result;
}

// Address range: 0x10093c3 - 0x10093df
int32_t function_10093c3(int32_t a1) {
    // 0x10093c3
    int32_t v1; // 0x10093c3
    int32_t v2; // 0x10093c3
    int32_t v3; // 0x10093c3
    *(int32_t *)v2 = (v3 & -256 | v1 & 255) + v2;
    return function_1ee9c1c1();
}

// Address range: 0x1009409 - 0x1009414
int32_t function_1009409(int32_t a1) {
    // 0x1009409
    int32_t v1; // 0x1009409
    bool v2; // 0x1009409
    return v1 - (v2 ? 173 : 172) & 255 | v1 & -256;
}

// Address range: 0x1009414 - 0x100959b
int32_t function_1009414(int32_t a1) {
    // 0x1009414
    int32_t v1; // 0x1009414
    int32_t v2 = v1 + 22; // 0x1009419
    int32_t result = v2 & 255 | v1 & -256; // 0x1009419
    int32_t v3; // 0x1009414
    int32_t v4; // 0x1009414
    uint32_t v5 = v4 - v3; // 0x100941b
    *(int32_t *)v4 = v5;
    if (v5 >= 0) {
        // 0x1009420
        return result;
    }
    // 0x1009424
    int32_t v6; // 0x1009414
    uint32_t v7 = v6 - 1; // 0x1009418
    char * v8 = (char *)result; // 0x1009424
    char v9 = v2; // 0x1009424
    *v8 = *v8 + v9;
    int32_t v10; // 0x1009414
    char * v11 = (char *)(v10 + 0x2c7c1d6); // 0x1009426
    int32_t v12; // 0x1009414
    *v11 = *v11 + (char)v12;
    bool v13; // 0x1009414
    int32_t v14 = v13 ? -4 : 4; // 0x100942c
    int32_t v15 = v14 + v6; // 0x100942c
    *(int32_t *)v15 = *(int32_t *)v7;
    int32_t v16 = v15 + v14; // 0x100942d
    int32_t * v17 = (int32_t *)(v16 + 3); // 0x1009430
    *v17 = *v17 + (result < v7 ? -12 : -13);
    int32_t v18 = v10 & -0xff01; // 0x1009434
    function_101636f(v3 - 8);
    int32_t v19 = v3 + 1; // 0x1009441
    __asm_sti();
    function_1008b1c();
    if ((v19 & (v3 ^ -0x80000000)) < 0) {
        // 0x100944c
        function_100bbd4();
        int32_t v20 = *(int32_t *)(v3 - 7); // 0x1009456
        int32_t * v21 = (int32_t *)v20; // 0x100945b
        *v21 = -*v21;
        unsigned char v22 = __asm_in_3((int16_t)v4); // 0x1009464
        int32_t v23 = v20 & -256 | (int32_t)v22; // 0x1009464
        int32_t v24; // 0x1009414
        if ((v2 & 15) == 15 || (v22 & 14) > 9) {
            v24 = v23 & -256 | (int32_t)((v22 > 153 ? 102 : 6) + v22);
        } else {
            v24 = v23 & -256 | (int32_t)(v22 > 153 ? v22 + 96 : v22);
        }
        char * v25 = (char *)v24; // 0x1009466
        *v25 = *v25 + (char)v24;
        g77 -= (char)v10;
        int32_t v26 = unknown_ffd5d1(*(int32_t *)(v3 + 126)); // 0x1009471
        return v26 & -256 | (int32_t)*(char *)((v26 & 255) + v18);
    }
    char * v27 = (char *)(v18 + 0x4d1ff06); // 0x10094c1
    unsigned char v28 = *v27; // 0x10094c1
    unsigned char v29 = v28 + v9; // 0x10094c1
    *v27 = v29;
    int32_t result2 = unknown_787bfb(); // 0x10094ce
    if (v29 < v28 || v29 == 0) {
        // 0x1009420
        return result2;
    }
    int32_t * v30 = (int32_t *)v18; // 0x10094d5
    int32_t v31 = *v30; // 0x10094d5
    int32_t v32; // 0x1009414
    if ((v28 & 15) + (v9 & 15) > 15 || (v31 & 14) > 9) {
        v32 = v31 + 102 & 255 | v31 & -256;
    } else {
        v32 = v31 + 96 & 255 | v31 & -256;
    }
    int32_t v33 = v14 + v7; // 0x100942d
    int32_t v34 = v32 & 103 | 152; // 0x10094dc
    char * v35 = (char *)(v34 | v32 & -256); // 0x10094de
    *v35 = *v35 + (char)v34;
    int32_t v36 = v4 + 256 * v10 & 0xff00 | v4 & -0xff01; // 0x10094e4
    *(int32_t *)v16 = *(int32_t *)v33;
    int32_t v37 = v16 + v14; // 0x10094e6
    int32_t v38 = v32 & 3; // 0x10094e9
    __asm_rep_movsb_memcpy((char *)v37, (char *)(v33 + v14), v38);
    int32_t v39 = v38 * (v13 ? -1 : 1) + v37; // 0x10094ec
    int32_t * v40 = (int32_t *)v19; // 0x10094f4
    int32_t v41 = *v40; // 0x10094f4
    __asm_out_6(181, (char)*v30 - 24);
    *v40 = v39;
    *(int32_t *)(v3 - 3) = __asm_int3();
    *(int32_t *)(v3 - 7) = 0;
    *(int32_t *)(v3 - 11) = v36;
    *(int32_t *)(v3 - 15) = v18;
    *(int32_t *)(v3 - 19) = v19;
    *(int32_t *)(v3 - 23) = v41;
    *(int32_t *)(v3 - 27) = v39;
    *(int32_t *)(v3 - 31) = v39;
    int32_t v42 = *(int32_t *)(v41 + 12); // 0x10094fe
    int32_t * v43 = (int32_t *)(v42 + 4); // 0x1009501
    int32_t v44 = *v43; // 0x1009501
    *(int32_t *)(v3 - 35) = v36;
    int32_t v45 = v3 - 33; // 0x1009505
    char v46 = (char)v44 - 24; // 0x1009506
    int32_t v47 = v44 & -256 | (int32_t)v46; // 0x1009506
    int16_t v48 = v36; // 0x1009508
    __asm_out_2(v48, v47);
    __asm_out_6(85, v46);
    __asm_out_2(v48, v47);
    int32_t v49 = v47; // 0x100950c
    int32_t v50 = v36; // 0x100950c
    int32_t v51 = v45; // 0x100950c
    int32_t v52 = v42; // 0x100950c
    if (v46 == 0) {
        // 0x100950e
        *(int32_t *)-33 = v47;
        v52 = *v43;
        v49 = *v30;
        v50 = *(int32_t *)v45;
        v51 = v3 - 29;
    }
    // 0x100951a
    if (v46 < 0) {
        int32_t v53 = v49 & 48 | 207; // 0x1009581
        int32_t v54 = v49 & -256; // 0x1009581
        int32_t v55 = v53 | v54; // 0x1009581
        char * v56 = (char *)v55; // 0x1009583
        *v56 = *v56 + (char)v53;
        __asm_int(243);
        *(int32_t *)v39 = *(int32_t *)v52;
        int32_t * v57 = (int32_t *)(v50 - 0x745b0c5f); // 0x100958e
        *v57 = *v57 ^ -31;
        char * v58 = (char *)(v55 + 4); // 0x1009595
        *v58 = *v58 ^ -24;
        return v53 & 230 | v54;
    }
    char * v59 = (char *)v49; // 0x1009521
    *v59 = *v59 + (char)v49;
    int32_t v60 = v49 / 0x4000000 & 31; // 0x1009525
    __asm_rep_movsd_memcpy((char *)v39, (char *)v50, v60);
    int32_t v61 = v60 * v14 + v39; // 0x1009528
    int32_t * v62 = (int32_t *)v49; // 0x1009538
    *v62 = -*v62;
    *(int32_t *)(v51 - 6) = v61;
    int32_t * v63 = (int32_t *)v50; // 0x100953b
    *(int32_t *)(v51 - 10) = *v63;
    if (function_1008f17() == 0) {
        function_1015fef();
    }
    // 0x100954a
    *(int32_t *)(v51 - 14) = *v63;
    int32_t v64 = function_1002ad1(); // 0x100954c
    *v63 = 0;
    __asm_outsb((int16_t)v50, *(char *)v61);
    int32_t * v65 = (int32_t *)v64; // 0x1009558
    *v65 = *v65 + 1;
    int32_t v66 = v64 & 255 ^ 230; // 0x100955c
    __asm_out_6(55, (char)v66);
    return v66 | v64 & -256;
}

// Address range: 0x100959c - 0x10095e4
int32_t function_100959c(void) {
    // 0x100959c
    int32_t v1; // 0x100959c
    int32_t * v2 = (int32_t *)(v1 + 0x4608303); // 0x100959c
    *v2 = *v2 - 1;
    int32_t v3; // 0x100959c
    uint32_t v4 = v3 + v1; // 0x10095b1
    *(int32_t *)(v4 + 4) = -0x74f30275;
    uint32_t v5; // 0x100959c
    int32_t v6 = *(int32_t *)(v5 + 4); // 0x10095b9
    int32_t result = *(int32_t *)v6; // 0x10095bc
    int32_t v7 = *(int32_t *)(result + 4); // 0x10095be
    char * v8 = (char *)v4; // 0x10095c1
    char v9 = v5 / 256; // 0x10095c1
    *v8 = *v8 - v9;
    char * v10 = (char *)(v7 - 117); // 0x10095c6
    unsigned char v11 = (char)v6; // 0x10095c6
    *v10 = *v10 + v11;
    int32_t v12 = v4 / 0x400000 | 1024 * v4; // 0x10095c9
    int32_t * v13 = (int32_t *)(v6 + 0x3e183c8); // 0x10095ce
    *v13 = v12 + (int32_t)(-1 - v9 < v11) + *v13;
    int32_t v14; // 0x100959c
    __asm_rep_movsb_memcpy((char *)v7, (char *)*(int32_t *)(v14 + 4), v12);
    bool v15; // 0x100959c
    *(int32_t *)(v7 + (v15 ? -1 : 1) * v12) = result;
    int32_t v16; // 0x100959c
    *(char *)(*(int32_t *)*(int32_t *)(v16 + 12) + 91) = v11;
    return result;
}

// Address range: 0x100961d - 0x1009622
int32_t function_100961d(void) {
    // 0x100961d
    return function_44e13c24();
}

// Address range: 0x1009627 - 0x1009632
int32_t function_1009627(void) {
    // 0x1009627
    int32_t v1; // 0x1009627
    int32_t v2; // 0x1009627
    *(char *)v1 = (char)v2;
    int32_t result; // 0x1009627
    return result;
}

// Address range: 0x1009634 - 0x100963b
int32_t function_1009634(void) {
    // 0x1009634
    int32_t v1; // 0x1009634
    int32_t v2; // 0x1009634
    return v2 + v1;
}

// Address range: 0x1009643 - 0x10096eb
int32_t function_1009643(void) {
    // 0x1009643
    int32_t v1; // 0x1009643
    int32_t v2; // 0x1009643
    *(int32_t *)v1 = v2 + v1;
    int32_t v3; // 0x1009643
    int32_t v4; // 0x1009643
    uint32_t v5 = v4 + v3; // 0x10096aa
    int32_t v6; // 0x1009643
    int32_t v7 = (__asm_hlt() | -0x4bfebc0c) & v6; // 0x10096af
    int32_t v8 = g81; // bp-4, 0x10096b3
    function_1007bc1(g81);
    int32_t v9 = (int32_t)&v8 | 1; // 0x10096c1
    char v10 = llvm_ctpop_i8((char)v9); // 0x10096c1
    int32_t * v11 = (int32_t *)(v7 + 0x17a701d); // 0x10096c3
    *v11 = *v11 + v7;
    int32_t * v12 = (int32_t *)(v5 + 0x144140d); // 0x10096ce
    *v12 = *v12 - 1;
    int32_t * v13 = (int32_t *)(v6 + 0xc8d0c); // 0x10096d4
    *v13 = *v13 + v7;
    int32_t v14; // 0x1009643
    char * v15 = (char *)(v14 + 41); // 0x10096da
    *v15 = *v15 + (char)(v5 / 256);
    int32_t * v16 = (int32_t *)(v5 - 0x3e3e7408); // 0x10096e0
    *v16 = v14 - 4 + *v16;
    bool v17; // 0x1009643
    bool v18; // 0x1009643
    return function_451186ed(0x4000 * (int32_t)v17 | 256 * (int32_t)v18 | 128 * (int32_t)(v9 < 0) | 4 * (int32_t)((v10 & 1) == 0) | 1026);
}

// Address range: 0x10096f7 - 0x1009790
int32_t function_10096f7(void) {
    // 0x10096f7
    int32_t v1; // 0x10096f7
    int32_t v2; // 0x10096f7
    bool v3; // 0x10096f7
    if (v3) {
        int32_t result = *(int32_t *)-0x52feb0ff; // 0x1009748
        bool v4; // 0x10096f7
        bool v5; // 0x10096f7
        if (v5 == v4) {
            // 0x100974f
            return result;
        }
        int32_t * v6 = (int32_t *)(v2 + (int32_t)&g93); // 0x1009767
        int32_t v7; // 0x10096f7
        *v6 = *v6 + v7;
        int32_t v8 = result & 114 | 141; // 0x1009770
        char * v9 = (char *)(v8 | result & -256); // 0x1009774
        *v9 = *v9 + (char)v8;
        *(int32_t *)(v1 & 0xffff) = (int32_t)g11;
        bool v10; // 0x10096f7
        int16_t v11 = v10 ? -4 : 4; // 0x1009780
        int32_t v12; // 0x10096f7
        __asm_rep_movsb_memcpy((char *)(v1 & -0x10000 | (int32_t)(v11 + (int16_t)v1)), (char *)((int32_t)(v11 + (int16_t)&g11) | (int32_t)&g11 & -0x10000), v12);
        return *(int32_t *)-0x13feb060;
    }
    // 0x10096f9
    int32_t v13; // 0x10096f7
    int32_t v14 = v13 + v2; // 0x10096f9
    int32_t * v15 = (int32_t *)v2; // 0x10096f9
    *v15 = v14;
    int32_t result2 = function_1007bc1((int32_t)&g125); // 0x10096fb
    if (v14 != 0) {
        // 0x100970a
        *v15 = result2 + v2;
        return function_8b9a6ce4(0x50000000);
    }
    int32_t * v16 = (int32_t *)(v1 - 0x14b05ff3); // 0x1009759
    *v16 = *v16 - 1;
    *v15 = result2 + v2;
    *(int32_t *)v1 = 2 * v1;
    return result2;
}

// Address range: 0x1009790 - 0x10097d4
int32_t function_1009790(void) {
    // 0x1009790
    unknown_a90076c1();
    *(int32_t *)(*(int32_t *)0x1fa14a0 + 4) = *(int32_t *)-0x14feb060;
    int32_t v1 = *(int32_t *)0x5e014487; // 0x10097b1
    __asm_wait();
    int32_t v2; // 0x1009790
    __asm_rep_movsd_memcpy((char *)v2, (char *)&g10, v1);
    return __asm_hlt();
}

// Address range: 0x10097d9 - 0x10097e2
int32_t function_10097d9(void) {
    // 0x10097d9
    int32_t v1; // 0x10097d9
    return v1 & -256 | (int32_t)__asm_in_1(-1);
}

// Address range: 0x1009818 - 0x100981f
int32_t function_1009818(void) {
    // 0x1009818
    return function_b502e9c1();
}

// Address range: 0x1009846 - 0x100984b
int32_t function_1009846(void) {
    // 0x1009846
    int32_t result; // 0x1009846
    return result;
}

// Address range: 0x100986f - 0x1009874
int32_t function_100986f(void) {
    // 0x100986f
    return function_8ca68bb0();
}

// Address range: 0x100987b - 0x1009883
int32_t function_100987b(void) {
    // 0x100987b
    int32_t result; // 0x100987b
    return result;
}

// Address range: 0x1009885 - 0x10098dc
int32_t function_1009885(void) {
    // 0x1009885
    unknown_ffe3c1();
    int32_t v1; // 0x1009885
    *(int32_t *)v1 = (int32_t)&g73;
    uint32_t v2 = *(int32_t *)0x200144cc; // 0x10098a4
    int32_t v3 = *(int32_t *)0x1cf90; // 0x10098aa
    int32_t v4; // 0x1009885
    __asm_out_2((int16_t)v4, v3);
    char * v5 = (char *)v3; // 0x10098b6
    *v5 = *v5 + (char)v3;
    int32_t v6; // 0x1009885
    int32_t v7; // 0x1009885
    __asm_rep_movsb_memcpy((char *)v6, (char *)0x470144c8, v2 / 4 & v7);
    float80_t v8; // 0x1009885
    *(int32_t *)(v2 - 0x5afeb1) = (int32_t)v8;
    return v2 + 22 & 255 | v2 & -256;
}

// Address range: 0x10098dc - 0x10098df
int32_t function_10098dc(void) {
    // 0x10098dc
    int32_t result; // 0x10098dc
    return result;
}

// Address range: 0x100990b - 0x1009910
int32_t function_100990b(void) {
    // 0x100990b
    return function_455b7812();
}

// Address range: 0x100991d - 0x100991f
int32_t function_100991d(void) {
    // 0x100991d
    int32_t result; // 0x100991d
    return result;
}

// Address range: 0x1009921 - 0x1009929
int32_t function_1009921(void) {
    // 0x1009921
    return function_e830b293();
}

// Address range: 0x1009929 - 0x1009930
int32_t function_1009929(void) {
    // 0x1009929
    int32_t v1; // 0x1009929
    int32_t v2; // 0x1009929
    *(int32_t *)v1 = __asm_insd((int16_t)v2);
    int32_t result; // 0x1009929
    return result;
}

// Address range: 0x100994f - 0x1009976
int32_t function_100994f(void) {
    // 0x100994f
    int32_t v1; // 0x100994f
    bool v2; // 0x100994f
    if (v2) {
        v1 = function_10098dc();
    }
    int32_t v3 = v1;
    *(char *)v3 = 2 * (char)v3;
    int32_t v4; // 0x100994f
    uint32_t v5; // 0x100994f
    __asm_rep_movsd_memcpy((char *)v4, (char *)&g13, v5 / 2048);
    return *(int32_t *)-0x714cb07c;
}

// Address range: 0x1009977 - 0x100997d
int32_t function_1009977(void) {
    // 0x1009977
    int32_t result; // 0x1009977
    return result;
}

// Address range: 0x10099b1 - 0x10099b6
int32_t function_10099b1(void) {
    // 0x10099b1
    return function_93a68d06();
}

// Address range: 0x10099bc - 0x10099c5
int32_t function_10099bc(void) {
    // 0x10099bc
    int32_t result; // 0x10099bc
    int32_t v1; // 0x10099bc
    if (v1 != 1) {
        result = function_ffff99be();
    }
    // 0x10099bf
    return result;
}

// Address range: 0x10099c6 - 0x10099d1
int32_t function_10099c6(void) {
    // 0x10099c6
    int32_t result; // 0x10099c6
    return result;
}

// Address range: 0x10099fd - 0x1009a02
int32_t function_10099fd(void) {
    // 0x10099fd
    return function_46095804();
}

// Address range: 0x1009a44 - 0x1009a47
int32_t function_1009a44(void) {
    // 0x1009a44
    int32_t v1; // 0x1009a44
    return v1 | 141;
}

// Address range: 0x1009a4d - 0x1009a52
int32_t function_1009a4d(void) {
    // 0x1009a4d
    return function_11198154();
}

// Address range: 0x1009a5e - 0x1009a66
int32_t function_1009a5e(void) {
    // 0x1009a5e
    int32_t result; // 0x1009a5e
    return result;
}

// Address range: 0x1009ab4 - 0x1009abf
int32_t function_1009ab4(int16_t a1) {
    // 0x1009ab4
    int32_t v1; // 0x1009ab4
    return v1 + 232 & 255 | v1 & -256;
}

// Address range: 0x1009ad1 - 0x1009bf4
int32_t function_1009ad1(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1009ad1
    int32_t v1; // 0x1009ad1
    int32_t v2; // 0x1009ad1
    *(int32_t *)v1 = v2 + v1;
    bool v3; // 0x1009ad1
    int32_t v4 = v3 ? -4 : 4; // 0x1009af6
    int32_t v5; // 0x1009ad1
    int32_t v6 = v4 + v5;
    int32_t v7; // 0x1009ad1
    int32_t v8 = g89 & v7; // 0x1009af9
    int32_t v9 = g89; // 0x1009afb
    int32_t v10 = v6; // 0x1009afb
    if (v8 != 0) {
        int32_t v11 = v3 ? -1 : 1; // 0x1009afb
        int32_t v12 = v8; // 0x1009afb
        int32_t v13 = v6; // 0x1009ad1
        v9 = g89 & -256 | (int32_t)*(char *)v13;
        v12--;
        v13 += v11;
        int32_t v14 = v9; // 0x1009afb
        while (v12 != 0) {
            v9 = v14 & -256 | (int32_t)*(char *)v13;
            v12--;
            v13 += v11;
            v14 = v9;
        }
        // ._crit_edge
        v10 = v8 * v11 + v6;
    }
    g91 = v9;
    function_1007bc1(*(int32_t *)v9);
    int32_t v15; // 0x1009ad1
    int32_t * v16 = (int32_t *)(v4 + v15 + v5 + *(int32_t *)(4 * v1 + 0x7ea827cd) & 0xffff); // 0x1009b2b
    uint32_t v17 = *v16; // 0x1009b2b
    uint32_t v18 = v17 + (g91 ^ (int32_t)&g14); // 0x1009b2b
    *v16 = v18;
    int32_t v19 = *(int32_t *)*(int32_t *)0x1fe4f98; // 0x1009b33
    int16_t v20; // 0x1009ad1
    unknown_c8d54(v20);
    int32_t v21 = *(int32_t *)-0x63b74168; // 0x1009b3e
    *(int32_t *)-0x63b74168 = 2 * v21 | (int32_t)(v18 < v17);
    *(int32_t *)v19 = *(int32_t *)v10;
    __asm_rep_movsb_memcpy((char *)(v19 + v4), (char *)(v10 + v4), 0);
    abort();
    // UNREACHABLE
}

// Address range: 0x1009ad4 - 0x1009ad5
int32_t function_1009ad4(int32_t a1) {
    // 0x1009ad4
    int32_t result; // 0x1009ad4
    return result;
}

// Address range: 0x1009bfb - 0x1009c01
int32_t function_1009bfb(void) {
    // 0x1009bfb
    int32_t result; // 0x1009bfb
    return result;
}

// Address range: 0x1009c30 - 0x1009c35
int32_t function_1009c30(void) {
    // 0x1009c30
    return function_46795a37();
}

// Address range: 0x1009c41 - 0x1009c49
int32_t function_1009c41(void) {
    // 0x1009c41
    int32_t result; // 0x1009c41
    return result;
}

// Address range: 0x1009c4d - 0x1009c52
int32_t function_1009c4d(void) {
    // 0x1009c4d
    return function_a5dc9c51();
}

// Address range: 0x1009c52 - 0x1009c84
int32_t function_1009c52(void) {
    // 0x1009c52
    int32_t v1; // 0x1009c52
    int32_t v2; // 0x1009c52
    *(int32_t *)v1 = v2 + v1;
    int32_t v3 = g15; // bp-4, 0x1009c57
    int32_t v4; // 0x1009c52
    int32_t v5; // 0x1009c52
    *(char *)(v5 - 1) = *(char *)&v4;
    int32_t v6; // 0x1009c52
    int32_t * v7 = (int32_t *)(v6 - 0x73f274ff); // 0x1009c67
    *v7 = *v7 + v6;
    int16_t * v8 = (int16_t *)(v6 + 0x78014fa4); // 0x1009c6e
    *v8 = *v8 + (int16_t)(int32_t)&v3;
    return function_ffffce86(v3);
}

// Address range: 0x1009c9c - 0x1009ca2
int32_t function_1009c9c(void) {
    // 0x1009c9c
    int32_t result; // 0x1009c9c
    return result;
}

// Address range: 0x1009cd1 - 0x1009cd6
int32_t function_1009cd1(void) {
    // 0x1009cd1
    return function_46ad5ad8();
}

// Address range: 0x1009ce4 - 0x1009cea
int32_t function_1009ce4(void) {
    // 0x1009ce4
    int32_t result; // 0x1009ce4
    return result;
}

// Address range: 0x1009cee - 0x1009cf6
float80_t function_1009cee(void) {
    // 0x1009cee
    return 1.0;
}

// Address range: 0x1009d22 - 0x1009d27
int32_t function_1009d22(void) {
    // 0x1009d22
    return function_46d15b49();
}

// Address range: 0x1009d70 - 0x1009d77
int32_t function_1009d70(void) {
    // 0x1009d70
    return function_a3f55b79();
}

// Address range: 0x1009d83 - 0x1009d8b
float80_t function_1009d83(void) {
    // 0x1009d83
    return 1.0;
}

// Address range: 0x1009db4 - 0x1009dc8
int32_t function_1009db4(int32_t a1) {
    // 0x1009db4
    int32_t v1; // 0x1009db4
    *(int32_t *)v1 = a1;
    int32_t v2; // 0x1009db4
    int32_t * v3 = (int32_t *)(v2 - 0x724a72c8); // 0x1009db6
    bool v4; // 0x1009db4
    *v3 = v1 + (int32_t)v4 + *v3;
    int32_t v5; // 0x1009db4
    char * v6 = (char *)v5; // 0x1009dbe
    *v6 = *v6 + (char)v5;
    return function_47195bca();
}

// Address range: 0x1009dd9 - 0x1009dea
int32_t function_1009dd9(void) {
    // 0x1009dd9
    int32_t v1; // 0x1009dd9
    int32_t result = v1 + 223 & 255 | v1 & -256; // 0x1009dd9
    int32_t v2; // 0x1009dd9
    *(int32_t *)v2 = result + v2;
    return result;
}

// Address range: 0x1009e0a - 0x1009e18
int32_t function_1009e0a(void) {
    // 0x1009e0a
    int32_t v1; // 0x1009e0a
    int32_t v2; // 0x1009e0a
    *(char *)((2 * v2 | 282) - 0x3e3e7500) = (char)v1;
    return function_473d5c1a();
}

// Address range: 0x1009e32 - 0x1009e38
int32_t function_1009e32(void) {
    // 0x1009e32
    int32_t result; // 0x1009e32
    return result;
}

// Address range: 0x1009e38 - 0x1009e7b
int32_t function_1009e38(void) {
    // 0x1009e38
    int32_t v1; // 0x1009e38
    int32_t v2; // 0x1009e38
    *(int32_t *)v1 = v2 ^ (int32_t)&g16;
    int32_t result = *(int32_t *)g99; // 0x1009e58
    uint32_t v3 = 4 * g17 - 0x6ffff0f; // 0x1009e5a
    int32_t v4 = v3 / 0x800000 | 512 * v3; // 0x1009e62
    int32_t * v5 = (int32_t *)v4; // 0x1009e69
    int32_t v6; // 0x1009e38
    *v5 = *v5 + v6;
    int32_t v7; // 0x1009e38
    __asm_rep_movsd_memcpy(g99, (char *)(v7 + 1), v4);
    int32_t v8; // 0x1009e38
    int32_t * v9 = (int32_t *)((result & v8 + 1) + 1); // 0x1009e76
    *v9 = *v9 + result;
    return result;
}

// Address range: 0x1009e7f - 0x1009e85
int32_t function_1009e7f(void) {
    // 0x1009e7f
    int32_t result; // 0x1009e7f
    return result;
}

// Address range: 0x1009ec7 - 0x1009ecd
int32_t function_1009ec7(void) {
    // 0x1009ec7
    int32_t result; // 0x1009ec7
    return result;
}

// Address range: 0x1009f1e - 0x1009f26
int32_t function_1009f1e(void) {
    // 0x1009f1e
    int32_t result; // 0x1009f1e
    return result;
}

// Address range: 0x1009f27 - 0x1009f7a
float80_t function_1009f27(void) {
    int32_t v1 = unknown_e56f7bfb(); // 0x1009f2f
    int32_t v2 = v1 & -0x10000 | v1 + 13 & 255 | 0x4f00; // 0x1009f36
    uint32_t v3; // 0x1009f27
    *(int32_t *)(v3 + 4) = v2;
    *(int32_t *)v3 = v2 + v3;
    int32_t v4 = *(int32_t *)(g100 + 4); // 0x1009f48
    uint32_t v5 = v3 / 4; // 0x1009f54
    bool v6; // 0x1009f27
    int32_t v7 = v6 ? -4 : 4; // 0x1009f58
    int32_t * v8 = (int32_t *)v5; // 0x1009f5a
    *v8 = *v8 + g100;
    __asm_rep_movsd_memcpy((char *)(v4 + v7), (char *)(v7 - 0x3e74ffff + 2 * g100), v5);
    return 1.0;
}

// Address range: 0x1009f7e - 0x1009f86
int32_t function_1009f7e(void) {
    int32_t result = __asm_hlt(); // 0x1009f7e
    int32_t v1; // 0x1009f7e
    int32_t * v2 = (int32_t *)(v1 - 24); // 0x1009f80
    int32_t v3; // 0x1009f7e
    *v2 = v3 + 1 + *v2;
    return result;
}

// Address range: 0x1009fa6 - 0x1009fab
int32_t function_1009fa6(void) {
    // 0x1009fa6
    return function_47f15dad();
}

// Address range: 0x1009fc1 - 0x1009fc3
int32_t function_1009fc1(void) {
    // 0x1009fc1
    int32_t result; // 0x1009fc1
    return result;
}

// Address range: 0x1009fc3 - 0x1009fca
int32_t function_1009fc3(void) {
    // 0x1009fc3
    return function_1009fce((int32_t)&g125, (int32_t)&g125);
}

// Address range: 0x1009fcd - 0x1009fce
int32_t function_1009fcd(void) {
    // 0x1009fcd
    int32_t result; // 0x1009fcd
    return result;
}

// Address range: 0x1009fce - 0x100a060
int32_t function_1009fce(int32_t a1, int32_t a2) {
    // 0x1009fce
    *(int32_t *)(g101 + 4) = unknown_41247bfb();
    int32_t v1 = *(int32_t *)(g101 + 4); // 0x1009fe9
    int32_t v2 = 4 * g18 + 187; // 0x1009fec
    int32_t * v3 = (int32_t *)v1; // 0x1009ff5
    uint32_t v4 = *v3 / 4; // 0x1009ff5
    char v5 = llvm_ctpop_i8((char)v4); // 0x1009ff5
    *v3 = v4;
    int32_t v6; // 0x1009fce
    int32_t v7; // 0x1009fce
    int32_t v8; // 0x1009fce
    int32_t v9; // 0x1009fce
    bool v10; // 0x1009fce
    if ((v5 & 1) != 0) {
        // 0x1009fce
        v6 = v10 ? -1 : 1;
        v8 = v2;
        v7 = g101;
    } else {
        int32_t * v11 = (int32_t *)v2; // 0x1009ffb
        *v11 = *v11 + g101;
        *(char *)v1 = *(char *)&v9;
        int32_t v12 = v10 ? -1 : 1;
        v9 += v12;
        int32_t v13 = function_1007c26(); // 0x100a005
        g102 = v13;
        unknown_ffa178(*(int32_t *)v13);
        v6 = v12;
        v8 = *(int32_t *)-0x24feb0bb;
        v7 = g79;
    }
    // 0x100a02e
    *(int32_t *)v8 = v7;
    int32_t v14 = *(int32_t *)0x501e47c; // 0x100a036
    int32_t v15 = *(int32_t *)v14; // 0x100a03b
    *(char *)v15 = (char)v14;
    int32_t v16 = v15 + v6; // 0x100a044
    int32_t * v17 = (int32_t *)(4 * v8 + 0xb50c); // 0x100a04c
    *v17 = *v17 + v14;
    float80_t v18; // 0x1009fce
    *(int64_t *)(v7 - 0xc32dc38) = (int64_t)v18;
    *(char *)v16 = *(char *)v9;
    int32_t v19 = *(int32_t *)0x4f424f7c; // 0x100a056
    int32_t * v20 = (int32_t *)v19; // 0x100a05b
    *v20 = *v20 | v16 + v6;
    return v19 + 232 & 255 | v19 & -256;
}

// Address range: 0x100a08b - 0x100a09c
int32_t function_100a08b(void) {
    // 0x100a08b
    int32_t v1; // 0x100a08b
    __asm_out_4(4, v1);
    int32_t v2; // 0x100a08b
    return function_48675eb8(v2);
}

// Address range: 0x100a0aa - 0x100a0b0
int32_t function_100a0aa(void) {
    // 0x100a0aa
    int32_t result; // 0x100a0aa
    return result;
}

// Address range: 0x100a0b2 - 0x100a0ed
int32_t function_100a0b2(void) {
    // 0x100a0b2
    function_1007bc1((int32_t)&g125);
    int32_t v1; // 0x100a0b2
    *(int32_t *)v1 = *(int32_t *)-0x3ffe8b1b + v1;
    int32_t v2 = unknown_d1007bfb(); // 0x100a0c4
    int32_t * v3 = (int32_t *)g67; // 0x100a0d5
    *v3 = (v2 & -256 | (int32_t)*(char *)-0x7bf27480) + *v3;
    int32_t v4; // 0x100a0b2
    char * v5 = (char *)(v4 + 2); // 0x100a0d8
    *v5 = *v5 | -30;
    return function_be2b5ef9();
}

// Address range: 0x100a0ed - 0x100a0f3
int32_t function_100a0ed(void) {
    // 0x100a0ed
    int32_t v1; // 0x100a0ed
    return v1 - 1;
}

// Address range: 0x100a0f3 - 0x100a123
int32_t function_100a0f3(void) {
    // 0x100a0f3
    int32_t v1; // 0x100a0f3
    int32_t v2; // 0x100a0f3
    int32_t v3; // 0x100a0f3
    int32_t v4; // 0x100a0f3
    __asm_rep_movsb_memcpy((char *)v1, (char *)v2, v4 & v3);
    int32_t v5 = __asm_fnstenv(); // 0x100a0fc
    *(int224_t *)(v5 + 4) = (int224_t)v5;
    function_1007bc1((int32_t)&g125);
    int32_t result = unknown_e7d70bfb(g20); // 0x100a112
    *(int32_t *)(*(int32_t *)0x1104f80 + 4) = result;
    return result;
}

// Address range: 0x100a14f - 0x100a1aa
int32_t function_100a14f(void) {
    // 0x100a14f
    int32_t v1; // 0x100a14f
    int32_t v2; // 0x100a14f
    int32_t v3 = v2 + v1; // 0x100a14f
    *(int32_t *)v1 = v3;
    int32_t v4 = v1 - 1; // 0x100a15d
    if (v4 != 0 != (v3 == 0)) {
        int32_t result = unknown_65007bfb(0, v2); // 0x100a165
        *(int32_t *)*(int32_t *)-0xefeb044 = result;
        return result;
    }
    int32_t * v5 = (int32_t *)(v1 + (int32_t)&g103 - 1); // 0x100a177
    int32_t v6; // bp-4, 0x100a14f
    *v5 = *v5 + (int32_t)&v6;
    int32_t v7; // 0x100a14f
    char * v8 = (char *)(v7 - 63 + 4 * v4); // 0x100a184
    uint32_t v9; // 0x100a14f
    *v8 = *v8 + (char)(v9 / 256);
    int32_t * v10 = (int32_t *)v4; // 0x100a188
    *v10 = 4 * *v10;
    int32_t v11; // 0x100a14f
    __asm_rep_movsd_memcpy((char *)v11, (char *)&g21, v4);
    return g82;
}

// Address range: 0x100a1aa - 0x100a1af
int32_t function_100a1aa(void) {
    // 0x100a1aa
    int32_t result; // 0x100a1aa
    return result;
}

// Address range: 0x100a1ce - 0x100a1d5
int32_t function_100a1ce(void) {
    // 0x100a1ce
    return function_388d0c8d();
}

// Address range: 0x100a1d9 - 0x100a1de
int32_t function_100a1d9(void) {
    // 0x100a1d9
    return function_b3ed6094();
}

// Address range: 0x100a1e3 - 0x100a1fe
int32_t function_100a1e3(void) {
    // 0x100a1e3
    int32_t v1; // 0x100a1e3
    int32_t v2; // 0x100a1e3
    *(char *)v1 = (char)v2;
    int32_t result = function_1007c26(); // 0x100a1e8
    *(int32_t *)0x17c4f03 = result;
    int32_t v3; // 0x100a1e3
    int32_t v4; // 0x100a1e3
    int32_t * v5 = (int32_t *)(v4 - 56 + 4 * v3); // 0x100a1f2
    *v5 = *v5 + 1;
    return result;
}

// Address range: 0x100a228 - 0x100a22f
int32_t function_100a228(void) {
    // 0x100a228
    return function_3116931();
}

// Address range: 0x100a243 - 0x100a24b
int32_t function_100a243(void) {
    // 0x100a243
    int32_t result; // 0x100a243
    return result;
}

// Address range: 0x100a24c - 0x100a250
int32_t function_100a24c(int32_t a1, int32_t a2) {
    // 0x100a24c
    return a1 + 255 & 255 | a1 & -256;
}

// Address range: 0x100a257 - 0x100a25d
int32_t function_100a257(void) {
    // 0x100a257
    int32_t result; // 0x100a257
    return result;
}

// Address range: 0x100a28a - 0x100a293
int32_t function_100a28a(void) {
    // 0x100a28a
    int32_t v1; // 0x100a28a
    return 0x10000 * v1 / 0x10000;
}

// Address range: 0x100a2cb - 0x100a2d0
int32_t function_100a2cb(void) {
    // 0x100a2cb
    return function_492a60d2();
}

// Address range: 0x100a310 - 0x100a3c7
int32_t function_100a310(void) {
    uint32_t v1 = __asm_sti(); // 0x100a312
    char * v2 = (char *)v1; // 0x100a316
    char v3 = *v2; // 0x100a316
    char v4 = v1; // 0x100a316
    char v5 = v3 + v4; // 0x100a316
    *v2 = v5;
    int32_t v6; // 0x100a310
    int32_t v7; // 0x100a310
    int32_t v8; // 0x100a310
    uint32_t v9; // 0x100a310
    if (((v5 ^ v3) & (v5 ^ v4)) >= 0) {
        int32_t v10 = 2 * v1; // 0x100a313
        int32_t * v11 = (int32_t *)v10; // 0x100a320
        *v11 = *v11 + v1;
        __asm_rep_movsd_memcpy((char *)v7, (char *)v6, v10);
        int32_t v12 = unknown_e5007c26(v8); // 0x100a32a
        *(int32_t *)-0x1e6b038 = v12;
        return v12 & -256 | v9 & 255;
    }
    // 0x100a368
    *(char *)v6 = *(char *)&v6 + v4;
    int32_t v13 = v1 / 0x400000 & 511 | 1024 * v1; // 0x100a36a
    char v14 = *(char *)(v6 + (int32_t)&g22); // 0x100a36d
    __asm_rep_movsd_memcpy((char *)v7, (char *)v6, v13);
    bool v15; // 0x100a310
    int32_t v16 = v13 * (v15 ? -4 : 4) + v7; // 0x100a373
    int32_t v17 = v1 & v8; // 0x100a377
    char * v18 = (char *)v16; // 0x100a379
    __asm_rep_movsb_memcpy(v18, v18, v17);
    int32_t v19 = v16 + v17 * (v15 ? -1 : 1); // 0x100a379
    int32_t * v20 = (int32_t *)(v19 - 0xfba711); // 0x100a38b
    *v20 = (256 * (int32_t)(v14 + (char)(v9 / 256)) | v9 & -0xff01) + *v20;
    int32_t v21 = g24; // 0x100a3a4
    int32_t v22 = *(int32_t *)((int32_t)g105 + 4); // 0x100a3af
    char * v23 = (char *)(4 * v21 + 59); // 0x100a3b2
    *v23 = g24;
    int32_t * v24 = (int32_t *)(*(int32_t *)(v8 - 0x41fde43f) - 0x16b41fe); // 0x100a3bb
    *v24 = *v24 / 2;
    *(int32_t *)v22 = *(int32_t *)v19;
    return v21 & -256 | (int32_t)*v23;
}

// Address range: 0x100a3c8 - 0x100a3d8
int32_t function_100a3c8(void) {
    // 0x100a3c8
    __asm_int(243);
    int32_t v1; // 0x100a3c8
    int32_t v2; // 0x100a3c8
    *(char *)v1 = (char)v2;
    int32_t result = unknown_1cf17cbc(); // 0x100a3cb
    int32_t v3; // 0x100a3c8
    *(int32_t *)v3 = result + v3;
    return result;
}

// Address range: 0x100a3d8 - 0x100a404
int32_t function_100a3d8(int32_t a1) {
    // 0x100a3d8
    __asm_in(122);
    __asm_sti();
    unknown_9c007bfb();
    int32_t v1; // 0x100a3d8
    int32_t * v2 = (int32_t *)(v1 + 0x2548cc0d); // 0x100a3f5
    uint32_t v3 = *v2; // 0x100a3f5
    uint32_t v4 = v3 + *(int32_t *)0x1314fcc; // 0x100a3f5
    *v2 = v4;
    int32_t result = __asm_iretd(); // 0x100a3fb
    int32_t * v5 = (int32_t *)(v1 + 0x388b0101); // 0x100a3fc
    int32_t v6; // 0x100a3d8
    *v5 = *v5 - ((int32_t)(v4 < v3) | (int32_t)&v6);
    return result;
}

// Address range: 0x100a404 - 0x100a412
int32_t function_100a404(void) {
    // 0x100a404
    uint32_t v1; // 0x100a404
    char * v2 = (char *)(v1 - 117); // 0x100a408
    *v2 = *v2 + (char)(v1 / 256);
    return function_49c962ab();
}

// Address range: 0x100a412 - 0x100a486
int32_t function_100a412(int16_t a1, int32_t a2) {
    // 0x100a412
    int32_t v1; // 0x100a412
    int32_t v2; // 0x100a412
    int32_t v3; // 0x100a412
    int32_t v4; // 0x100a412
    __asm_rep_movsd_memcpy((char *)v1, (char *)(v3 + v2), v4);
    bool v5; // 0x100a412
    int32_t v6 = (v5 ? -4 : 4) * v4 + v1; // 0x100a414
    int32_t * v7 = (int32_t *)(g106 + 4); // 0x100a421
    *v7 = (v5 ? 1 : -1) - v6 + *v7;
    function_1007bc1((int32_t)&g125);
    int32_t v8; // 0x100a412
    int32_t * v9 = (int32_t *)(a2 + 1 + 2 * v8); // 0x100a432
    uint32_t v10 = *v9; // 0x100a432
    *v9 = v10 / 0x80000000 | 2 * v10;
    int32_t v11 = function_10037fb(); // 0x100a437
    *(int32_t *)v8 = 2 * v11;
    *(int32_t *)(v8 + 38) = v11;
    unsigned char v12 = (char)v11; // 0x100a44b
    int32_t v13; // 0x100a412
    if ((v12 & 14) > 9) {
        v13 = (v12 > 153 ? 154 : 250) + v11 & 255 | v11 & -256;
    } else {
        v13 = (v12 > 153 ? v11 + 160 : v11) & 255 | v11 & -256;
    }
    int32_t v14; // 0x100a412
    int32_t v15 = *(int32_t *)(v6 - 46) & v14; // 0x100a418
    int32_t v16 = g26 ^ v8; // 0x100a445
    int32_t * v17 = (int32_t *)v16; // 0x100a44e
    *v17 = *v17 + v13;
    int32_t v18 = *(int32_t *)(v13 + 4); // 0x100a450
    int32_t v19; // 0x100a412
    uint32_t v20 = v16 + 4 * v19; // 0x100a453
    char * v21 = (char *)v13; // 0x100a458
    *v21 = *v21 + (char)v13;
    uint32_t v22 = v20 / 4; // 0x100a45c
    __asm_rep_movsd_memcpy((char *)v18, (char *)&g28, v22);
    *(char *)(v18 + -4 * v22) = (char)v20;
    char * v23 = (char *)v15; // 0x100a467
    *v23 = (char)((v20 & 2) != 0) + (char)(v20 / 256) + *v23;
    __asm_int(243);
    int32_t v24 = unknown_545c26(); // 0x100a46c
    *(int32_t *)0x1774fd0 = v24;
    unknown_8f4022c1(0x10000 * *(int32_t *)v24 / 0x10000);
    int32_t result = *(int32_t *)0x1c014dd0; // 0x100a47d
    char * v25 = (char *)result; // 0x100a482
    *v25 = *v25 & (char)v15;
    return result;
}

// Address range: 0x100a4fe - 0x100a503
int32_t function_100a4fe(void) {
    // 0x100a4fe
    return function_49d56305();
}

// Address range: 0x100a511 - 0x100a517
int32_t function_100a511(void) {
    // 0x100a511
    int32_t result; // 0x100a511
    return result;
}

// Address range: 0x100a51d - 0x100a523
int32_t function_100a51d(void) {
    // 0x100a51d
    int32_t result; // 0x100a51d
    return result;
}

// Address range: 0x100a52a - 0x100a52d
int32_t function_100a52a(int32_t a1) {
    // 0x100a52a
    int32_t v1; // 0x100a52a
    int32_t v2; // 0x100a52a
    return v2 + v1;
}

// Address range: 0x100a52f - 0x100a531
int32_t function_100a52f(void) {
    // 0x100a52f
    int32_t result; // 0x100a52f
    return result;
}

// Address range: 0x100a54f - 0x100a554
int32_t function_100a54f(void) {
    // 0x100a54f
    return function_4a977b0a();
}

// Address range: 0x100a565 - 0x100a570
int32_t function_100a565(void) {
    // 0x100a565
    int32_t v1; // 0x100a565
    bool v2; // 0x100a565
    return v1 - 0x29eb10 + (int32_t)v2;
}

// Address range: 0x100a585 - 0x100a58c
int32_t function_100a585(void) {
    // 0x100a585
    return function_3c0d8b04();
}

// Address range: 0x100a59f - 0x100a5a4
int32_t function_100a59f(void) {
    // 0x100a59f
    return function_4a4463a6();
}

// Address range: 0x100a5b2 - 0x100a5b8
int32_t function_100a5b2(void) {
    // 0x100a5b2
    int32_t result; // 0x100a5b2
    return result;
}

// Address range: 0x100a5be - 0x100a5c4
int32_t function_100a5be(void) {
    // 0x100a5be
    int32_t result; // 0x100a5be
    return result;
}

// Address range: 0x100a5f0 - 0x100a5f5
int32_t function_100a5f0(void) {
    // 0x100a5f0
    return function_4ab063f7();
}

// Address range: 0x100a609 - 0x100a611
int32_t function_100a609(void) {
    // 0x100a609
    uint32_t v1; // 0x100a609
    return 255 * v1 / 256 + v1 & 255 | v1 & -0x10000;
}

// Address range: 0x100a651 - 0x100a659
int32_t function_100a651(void) {
    // 0x100a651
    uint32_t v1; // 0x100a651
    return 255 * v1 / 256 + v1 & 255 | v1 & -0x10000;
}

// Address range: 0x100a65a - 0x100a665
int32_t function_100a65a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, uint32_t a7) {
    // 0x100a65a
    return 255 * a7 / 256 + a7 & 255 | a7 & -0x10000;
}

// Address range: 0x100a68f - 0x100a696
int32_t function_100a68f(void) {
    // 0x100a68f
    return function_fe436498();
}

// Address range: 0x100a6aa - 0x100a6b2
int32_t function_100a6aa(void) {
    // 0x100a6aa
    uint32_t v1; // 0x100a6aa
    return 255 * v1 / 256 + v1 & 255 | v1 & -0x10000;
}

// Address range: 0x100a6e1 - 0x100a6e6
int32_t function_100a6e1(void) {
    // 0x100a6e1
    return function_4a7964e8();
}

// Address range: 0x100a6f2 - 0x100a706
int32_t function_100a6f2(void) {
    // 0x100a6f2
    int32_t v1; // 0x100a6f2
    int32_t * v2 = (int32_t *)(v1 - 0x43feb020); // 0x100a6f4
    *v2 = *v2 + 1;
    uint32_t v3; // 0x100a6f2
    uint32_t v4; // 0x100a6f2
    return v4 & -0x10000 | (255 * v4 / 256 + v4 ^ v3 / 256) & 255 | 0xff00;
}

// Address range: 0x100a706 - 0x100a70a
int32_t function_100a706(void) {
    // 0x100a706
    int32_t result; // 0x100a706
    return result;
}

// Address range: 0x100a70a - 0x100a7ed
int32_t function_100a70a(void) {
    // 0x100a70a
    int32_t v1; // 0x100a70a
    int32_t v2 = v1 - 1; // 0x100a70b
    int32_t * v3 = (int32_t *)v2; // 0x100a70c
    int32_t v4; // 0x100a70a
    int32_t v5 = *v3 + v4; // 0x100a70c
    *v3 = v5;
    int32_t v6 = v1 - 2; // 0x100a715
    if (v6 == 0 || v5 == 0) {
        uint32_t v7 = *(int32_t *)-0x363cb6b4; // 0x100a71b
        char * v8 = (char *)(v7 + 79); // 0x100a721
        *v8 = *v8 ^ (char)(v7 / 256);
        int32_t v9; // 0x100a70a
        int32_t * v10 = (int32_t *)(v9 - 0x72f3bb7b); // 0x100a725
        *v10 = *v10 + v7;
        int32_t v11; // 0x100a70a
        char * v12 = (char *)v11; // 0x100a72d
        *v12 = *v12 + (char)v11;
        return function_4a916539();
    }
    int32_t * v13 = (int32_t *)(v1 + 0x538b04b2); // 0x100a766
    *v13 = *v13 + v6;
    unsigned char v14 = *(char *)v2 + (char)v6; // 0x100a76c
    int32_t v15 = v14; // 0x100a76c
    uint32_t v16 = v6 & -256 | v15; // 0x100a76c
    int32_t * v17 = (int32_t *)(v16 + 0x1b34f1f); // 0x100a76f
    int32_t v18; // bp-1, 0x100a70a
    *v17 = *v17 + (int32_t)&v18;
    int32_t v19 = *(int32_t *)(v4 - 64); // 0x100a775
    int32_t v20 = v4 & 104 | 151; // 0x100a77b
    char * v21 = (char *)(v20 | v4 & -256); // 0x100a77d
    *v21 = *v21 + (char)v20;
    uint32_t v22 = v16 / 4; // 0x100a781
    int32_t v23; // 0x100a70a
    if ((v15 & 2) != 0 || v16 < 4) {
        int32_t * v24 = (int32_t *)v22; // 0x100a787
        *v24 = *v24 + v16;
        __asm_rep_movsd_memcpy((char *)v19, (char *)v23, v22);
        int32_t v25 = unknown_89767c3a(); // 0x100a791
        g109 = (char *)v25;
        function_1007bc1(*(int32_t *)v25);
        int32_t v26; // 0x100a70a
        int32_t * v27 = (int32_t *)(v26 - 34); // 0x100a7a9
        *v27 = *v27 - 1;
        abort();
        // UNREACHABLE
    }
    // 0x100a7de
    __asm_rep_movsb_memcpy((char *)v19, (char *)v23, v22 & v5);
    return v6 & -0x10000 | (int32_t)(v14 - 24) | 0xe800;
}

// Address range: 0x100a7ee - 0x100a7f4
int32_t function_100a7ee(void) {
    // 0x100a7ee
    int32_t result; // 0x100a7ee
    return result;
}

// Address range: 0x100a823 - 0x100a828
int32_t function_100a823(void) {
    // 0x100a823
    return function_45417c2a();
}

// Address range: 0x100a835 - 0x100a837
int32_t function_100a835(void) {
    // 0x100a835
    int32_t result; // 0x100a835
    return result;
}

// Address range: 0x100a874 - 0x100a879
int32_t function_100a874(void) {
    // 0x100a874
    return function_455d667b();
}

// Address range: 0x100a88f - 0x100a895
int32_t function_100a88f(void) {
    // 0x100a88f
    int32_t result; // 0x100a88f
    return result;
}

// Address range: 0x100a8d7 - 0x100a8dd
int32_t function_100a8d7(void) {
    // 0x100a8d7
    int32_t result; // 0x100a8d7
    return result;
}

// Address range: 0x100a8e1 - 0x100a8e9
int32_t function_100a8e1(void) {
    // 0x100a8e1
    int32_t result; // 0x100a8e1
    return result;
}

// Address range: 0x100a915 - 0x100a91a
int32_t function_100a915(void) {
    // 0x100a915
    return function_4a89671c();
}

// Address range: 0x100a952 - 0x100aa65
int32_t function_100a952(void) {
    // 0x100a952
    int32_t v1; // 0x100a952
    int32_t * v2 = (int32_t *)(v1 - 16); // 0x100a952
    int32_t v3; // 0x100a952
    *v2 = *v2 + v3;
    int32_t v4; // 0x100a952
    *(int32_t *)v4 = v3 + v4;
    int32_t v5 = *(int32_t *)(v3 + 4); // 0x100a958
    uint32_t v6 = (4 * v4 + 12) / 4; // 0x100a964
    __asm_rep_movsd_memcpy((char *)v5, (char *)&g29, v6);
    bool v7; // 0x100a952
    int32_t v8 = v7 ? -1 : 1; // 0x100a973
    int32_t v9 = (v7 ? -4 : 4) * v6 + v8 + v5; // 0x100a973
    int32_t v10 = unknown_d0001e26(); // 0x100a974
    g112 = v10;
    unknown_ffb7c1(*(int32_t *)v10);
    int32_t v11 = unknown_6d007bfb(*(int32_t *)-0x40feb654); // 0x100a992
    int32_t v12 = *(int32_t *)0x6014ff4; // 0x100a997
    int32_t v13; // 0x100a952
    *(int32_t *)(v13 + 0x149ac0d + 4 * v12) = v11;
    int32_t v14 = v11 & 114 | 141; // 0x100a9ad
    char * v15 = (char *)(v14 | v11 & -256); // 0x100a9b1
    *v15 = *v15 + (char)v14;
    int32_t v16 = v12 - 0x57416805; // 0x100a9b5
    int32_t v17 = v12 - 1; // 0x100a9ba
    int32_t * v18 = (int32_t *)v17; // 0x100a9bb
    *v18 = *v18 + v16;
    __asm_rep_movsd_memcpy((char *)(v8 - 1 + 2 * v9), (char *)v9, v17);
    int32_t * v19 = (int32_t *)v16; // 0x100a9c8
    int32_t v20 = *v19; // 0x100a9c8
    int32_t v21 = v20 + v16; // 0x100a9c8
    *v19 = v21;
    function_1002646(*(int32_t *)(v12 - 0x57416801));
    if (((v21 ^ v20) & (v21 ^ v16)) < 0) {
        // 0x100a9ed
        return function_10149bc(*(int32_t *)-0x73fe9015);
    }
    int32_t v22 = g112 ^ (int32_t)&g25; // 0x100aa2e
    *(int32_t *)(g114 + v16) = v22;
    int32_t v23; // 0x100a952
    int32_t v24 = *(int32_t *)((v23 + v1 | -0xb5e5b0d) - 88); // 0x100aa40
    __asm_bound(*(int64_t *)v22);
    int32_t result = v22 & -95; // 0x100aa45
    char * v25 = (char *)result; // 0x100aa51
    *v25 = *v25 + (char)result;
    __asm_rep_movsd_memcpy((char *)(v24 - 1), (char *)&g23, v13 + 0x28dc1c1);
    __asm_int(243);
    return result;
}

// Address range: 0x100aa6b - 0x100aa71
int32_t function_100aa6b(void) {
    // 0x100aa6b
    int32_t v1; // 0x100aa6b
    return v1 - 0x4ee80470;
}

// Address range: 0x100aa72 - 0x100aa78
int32_t function_100aa72(void) {
    // 0x100aa72
    int32_t result; // 0x100aa72
    return result;
}

// Address range: 0x100aa78 - 0x100ab09
int32_t function_100aa78(int32_t a1) {
    // 0x100aa78
    uint32_t v1; // 0x100aa78
    int32_t * v2 = (int32_t *)(v1 + 0x5b8b0441); // 0x100aa8b
    *v2 = *v2 + v1;
    int32_t v3; // 0x100aa78
    int32_t v4; // 0x100aa78
    int32_t v5 = v3 - 1 + v4; // 0x100aa92
    int32_t v6; // bp-6, 0x100aa78
    int32_t v7 = &v6; // 0x100aa93
    int32_t * v8 = (int32_t *)(v1 + (int32_t)&g65); // 0x100aa94
    *v8 = *v8 + v7;
    int32_t v9 = v5 & 114 | 141; // 0x100aa9e
    char * v10 = (char *)(v9 | v5 & -256); // 0x100aaa2
    char v11 = v9; // 0x100aaa2
    *v10 = *v10 + v11;
    __asm_out_6(119, v11);
    uint32_t v12 = v1 / 4; // 0x100aaa6
    __asm_out((int16_t)*(int32_t *)(v5 - 115 + v7), v11);
    int32_t v13; // 0x100aa78
    char * v14 = (char *)(v13 + 0x4ecd23c8); // 0x100aaaf
    *v14 = *v14 | (char)v12;
    int32_t v15 = unknown_6a007bff(g76); // 0x100aabc
    int32_t v16; // 0x100aa78
    *(int32_t *)v16 = v15;
    int32_t * v17 = (int32_t *)v12; // 0x100aac4
    *v17 = *v17 + v15;
    bool v18; // 0x100aa78
    int32_t * v19 = v18 ? (int32_t *)((int32_t)&g27 - 0x74001a31) : (int32_t *)((int32_t)&g27 - 0x74001a2f); // 0x100aacf
    *v19 = *v19 & v3;
    int32_t v20 = v15 ^ -0x3bfeb0fc; // 0x100aad5
    *(int32_t *)-0xffeb0b4 = v20;
    *(char *)v13 = (char)v20 + (char)v13;
    int32_t result = v20 & -256 | 79; // 0x100ab00
    int32_t * v21 = (int32_t *)(257 * v20 & 0xff00 | v20 & -0xff01); // 0x100ab02
    *v21 = *v21 + result;
    return result;
}

// Address range: 0x100ab09 - 0x100ab0a
int32_t function_100ab09(int32_t a1) {
    // 0x100ab09
    int32_t result; // 0x100ab09
    return result;
}

// Address range: 0x100ab25 - 0x100ab26
int32_t function_100ab25(void) {
    // 0x100ab25
    int32_t result; // 0x100ab25
    return result;
}

// Address range: 0x100ab26 - 0x100ab28
int32_t function_100ab26(void) {
    // 0x100ab26
    return function_100ab60();
}

// Address range: 0x100ab31 - 0x100ab35
int32_t function_100ab31(int32_t a1) {
    // 0x100ab31
    int32_t v1; // 0x100ab31
    return v1 + 3 & 255 | v1 & -256;
}

// Address range: 0x100ab60 - 0x100ab65
int32_t function_100ab60(void) {
    // 0x100ab60
    __asm_int(139);
    int32_t result; // 0x100ab60
    return result;
}

// Address range: 0x100ab65 - 0x100ac98
int32_t function_100ab65(int32_t a1) {
    // 0x100ab65
    uint32_t v1; // 0x100ab65
    bool v2; // 0x100ab65
    *(int32_t *)v1 = v1 / 0x80000000 | 4 * v1 | 2 * (int32_t)v2;
    int32_t v3; // 0x100ab65
    int32_t v4; // 0x100ab65
    int32_t v5; // 0x100ab65
    uint32_t v6 = *(int32_t *)(v3 - 0x2f6aaff4 + 4 * v5) + v4; // 0x100ab69
    int64_t v7 = (int64_t)*(int32_t *)(v5 - 1); // 0x100ab70
    char * v8 = (char *)v6; // 0x100ab74
    char v9 = *v8; // 0x100ab74
    char v10 = (2 * v9 | (char)(21 * v7 != 0x1500000000 * v7 / 0x100000000)) + (char)v5; // 0x100ab76
    *v8 = v10;
    if (v10 >= 0) {
        function_100ab25();
    }
    // 0x100ab7a
    int32_t v11; // 0x100ab65
    *(char *)v11 = *(char *)&v11 | (char)(v6 / 256);
    int32_t v12 = *(int32_t *)v6; // 0x100ab7c
    int32_t v13 = v3 + 1; // 0x100ab7e
    int32_t v14 = v12 + 98; // 0x100ab7f
    int32_t v15; // 0x100ab65
    __asm_into(v15);
    char * v16 = (char *)(v14 & 255 | v12 & -256); // 0x100ab85
    *v16 = *v16 | (char)v14;
    int32_t v17 = *(int32_t *)(v1 + 8); // 0x100ab87
    int32_t v18; // 0x100ab65
    int32_t v19 = v17 < v18 ? v17 : v13;
    unsigned char v20 = (char)v19 - 63; // 0x100ab9b
    if (v19 != 1 != (v20 == 0)) {
        // 0x100ab9f
        return v19 & -256 | (int32_t)v20;
    }
    int32_t v21 = (v17 < v18 ? v1 : v18) + -1 - *(int32_t *)(v18 + 3); // 0x100ab9a
    unknown_458e73d1();
    *(int32_t *)(v21 + 9) = 0;
    int32_t v22 = *(int32_t *)v21; // 0x100abc5
    char v23 = *(char *)-0x2fb1842c; // 0x100abcb
    int32_t * v24 = (int32_t *)(v21 + 10); // 0x100abd3
    *v24 = *v24 - (v22 & -256 | (int32_t)(v23 + (char)v22));
    return *(int32_t *)((v17 < v18 ? v13 : v17 - v18) + 8);
}

// Address range: 0x100acce - 0x100acd4
int32_t function_100acce(void) {
    // 0x100acce
    int32_t result; // 0x100acce
    return result;
}

// Address range: 0x100ad14 - 0x100ad19
int32_t function_100ad14(void) {
    // 0x100ad14
    return function_b8a6a01b();
}

// Address range: 0x100ad51 - 0x100aea9
int32_t function_100ad51(void) {
    // 0x100ad51
    int32_t v1; // 0x100ad51
    __asm_out_6(4, (char)v1);
    int32_t result = *(int32_t *)-0x7ffeb018; // 0x100ad58
    int32_t v2; // 0x100ad51
    int32_t v3 = *(int32_t *)(v2 + 4) + 2 * v2; // 0x100ad60
    uint32_t v4; // 0x100ad51
    char * v5 = (char *)(4 * v3 + v4); // 0x100ad65
    char v6 = v4 / 256; // 0x100ad65
    *v5 = *v5 + v6;
    int32_t v7; // 0x100ad51
    int32_t * v8 = (int32_t *)(v7 - 0x5a0cfd17); // 0x100ad68
    int32_t v9 = *v8; // 0x100ad68
    *v8 = 2048 * v9;
    uint32_t v10; // 0x100ad51
    unsigned char v11 = v6 - (char)(v10 / 256) + (char)((v9 & 0x200000) != 0); // 0x100ad73
    int32_t v12 = v3 - 1; // 0x100ad78
    if (v12 != 0 != (v11 == 0)) {
        // 0x100ad7a
        return result;
    }
    int32_t * v13 = (int32_t *)v12; // 0x100ad7d
    *v13 = *v13 + result;
    __asm_rep_movsb_memcpy((char *)*(int32_t *)(result + 4), (char *)v2, v12);
    int32_t * v14 = (int32_t *)(v10 - 39); // 0x100ad81
    *v14 = *v14 + 0x35ffff65;
    int32_t v15 = result & -256 | (int32_t)__asm_in_3((int16_t)v10); // 0x100ad88
    int32_t v16; // bp-4, 0x100ad51
    __asm_out_6(232, (char)(int32_t)&v16);
    int32_t v17 = function_1007c93(); // 0x100ad97
    *(int32_t *)0x1ea4fec = v17;
    function_1007bc1(*(int32_t *)v17);
    *(int32_t *)g110 = 256 * (int32_t)v11 | v4 & -0xff01;
    *(int32_t *)g84 = *(int32_t *)0x33944fe8;
    char * v18 = g109; // 0x100adc6
    int32_t result2 = (int32_t)v18; // 0x100adc6
    int32_t v19 = *(int32_t *)v18; // 0x100adcb
    int32_t v20 = *(int32_t *)(v19 + 4); // 0x100adcd
    int32_t * v21 = (int32_t *)v20; // 0x100add3
    *v21 = *v21 + result2;
    if (v20 == 1) {
        // 0x100add9
        *v18 = *v18 + (char)result2;
        return 2 * (int16_t)result2;
    }
    int32_t v22 = *(int32_t *)v18 - 1; // 0x100ade7
    int32_t v23 = result2 - 1; // 0x100ade8
    if (v23 != 0 != (v22 == 0)) {
        // 0x100adea
        __asm_rep_movsb_memcpy((char *)v22, (char *)v19, v23);
        return result2;
    }
    char v24 = __asm_in_3((int16_t)*(int32_t *)(v15 - 63)); // 0x100aded
    int32_t * v25 = (int32_t *)v23; // 0x100adef
    *v25 = (result2 & -256 | (int32_t)v24) + *v25;
    return unknown_7e007bc1();
}

// Address range: 0x100aeaa - 0x100aead
int32_t function_100aeaa(void) {
    // 0x100aeaa
    int32_t result; // 0x100aeaa
    return result;
}

// Address range: 0x100aec7 - 0x100aecd
int32_t function_100aec7(void) {
    // 0x100aec7
    int32_t result; // 0x100aec7
    return result;
}

// Address range: 0x100aed9 - 0x100aeda
int32_t function_100aed9(void) {
    // 0x100aed9
    int32_t result; // 0x100aed9
    return result;
}

// Address range: 0x100aedd - 0x100aede
int32_t function_100aedd(int32_t a1) {
    // 0x100aedd
    int32_t result; // 0x100aedd
    return result;
}

// Address range: 0x100aefe - 0x100af03
int32_t function_100aefe(void) {
    // 0x100aefe
    return function_8ca6a263();
}

// Address range: 0x100af44 - 0x100af68
int32_t function_100af44(void) {
    // 0x100af44
    int32_t v1; // 0x100af44
    char * v2 = (char *)(v1 + 210); // 0x100af46
    uint32_t v3; // 0x100af44
    int32_t v4; // 0x100af44
    *v2 = *v2 + (char)v3 + (char)((char)v4 > 114);
    int32_t result = function_100aed9(); // 0x100af54
    if (v3 < 4) {
        // 0x100af5b
        int32_t v5; // 0x100af44
        int32_t v6; // 0x100af44
        *(char *)v6 = *(char *)&v5;
        return result;
    }
    // 0x100af58
    *(int32_t *)(v1 - 2) = 10;
    return result;
}

// Address range: 0x100af7b - 0x100af87
int32_t function_100af7b(void) {
    // 0x100af7b
    int32_t v1; // 0x100af7b
    int32_t * v2 = (int32_t *)(v1 + 0x14fa41d); // 0x100af7b
    *v2 = *v2 - 1;
    return __asm_int3();
}

// Address range: 0x100afcc - 0x100afd1
int32_t function_100afcc(void) {
    // 0x100afcc
    return function_29f2a2d3();
}

// Address range: 0x100afde - 0x100afe5
int32_t function_100afde(void) {
    // 0x100afde
    int32_t v1; // 0x100afde
    return v1 + 232 & 255 | v1 & -256;
}

// Address range: 0x100afe9 - 0x100b058
int32_t function_100afe9(int32_t a1) {
    // 0x100afe9
    int32_t v1; // 0x100afe9
    char v2 = v1; // 0x100afeb
    if (v2 < -37) {
        // 0x100b03e
        int32_t v3; // 0x100afe9
        unknown_7900bbd4(v3);
        function_100361a(g98);
        // 0x100b057
        return __asm_int3();
    }
    unsigned char v4 = v2 - 22; // 0x100aff3
    int32_t v5; // 0x100afe9
    int32_t v6 = ((v4 ^ v2 - 21) & 21 - v2) < 0 ? v1 & -256 | (int32_t)v4 : v5;
    int32_t v7; // 0x100afe9
    int32_t * v8 = (int32_t *)(v7 + 0x14f6007 + (int32_t)(((v4 ^ v2 - 21) & 21 - v2) >= 0)); // 0x100affb
    *v8 = *v8 - 1;
    char v9 = v6; // 0x100b004
    char v10 = v9 - 95; // 0x100b004
    int32_t v11 = v6 & -256; // 0x100b004
    if (v10 < 0 != ((v10 ^ v9) & v9 + 33) < 0) {
        // 0x100b057
        return v11 | (int32_t)v10;
    }
    // 0x100b008
    int32_t v12; // 0x100afe9
    int32_t v13; // 0x100afe9
    int32_t v14 = v13 + v12; // 0x100afef
    int32_t * v15 = (int32_t *)(a1 + 0x4e8b0470); // 0x100b009
    *v15 = *v15 + v14;
    int32_t v16; // 0x100afe9
    *(char *)v13 = *(char *)&v16;
    bool v17; // 0x100afe9
    int32_t v18 = v17 ? -1 : 1; // 0x100b011
    v16 += v18;
    *(char *)v14 = -117;
    if (v13 - 1 + v18 >= 0) {
        // 0x100b018
        return v6 + 66 & 255 | v11;
    }
    char * v19 = (char *)(v16 + 0x47c1cad9); // 0x100b01c
    *v19 = *v19 + (char)((((v4 ^ v2 - 21) & 21 - v2) < 0 ? v5 : v1) / 256);
    return function_8ca6a329();
}

// Address range: 0x100b05b - 0x100b064
int32_t function_100b05b(int32_t a1) {
    int32_t result = __asm_hlt(); // 0x100b061
    int32_t v1; // 0x100b05b
    if ((v1 & -v1) < 0) {
        result = function_100afe9((int32_t)&g125);
    }
    // 0x100b063
    return result;
}

// Address range: 0x100b064 - 0x100b0a4
int32_t function_100b064(void) {
    int32_t v1 = unknown_ed7bfb(*(int32_t *)(*(int32_t *)*(int32_t *)-0x3decb05c + 4)); // 0x100b077
    *(int32_t *)g98 = v1;
    return function_8c9ca3a6();
}

// Address range: 0x100b0a4 - 0x100b0b5
float80_t function_100b0a4(int32_t a1) {
    // 0x100b0a4
    int32_t v1; // 0x100b0a4
    float80_t v2; // 0x100b0a4
    return v2 + (float80_t)*(float64_t *)(v1 + 0x79f303e1);
}

// Address range: 0x100b0b6 - 0x100b0bc
int32_t function_100b0b6(void) {
    // 0x100b0b6
    int32_t result; // 0x100b0b6
    return result;
}

// Address range: 0x100b0bc - 0x100b0cb
int32_t function_100b0bc(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t result) {
    // 0x100b0bc
    return result;
}

// Address range: 0x100b0cc - 0x100b0cd
int32_t function_100b0cc(int32_t a1) {
    // 0x100b0cc
    int32_t result; // 0x100b0cc
    return result;
}

// Address range: 0x100b0e7 - 0x100b199
int32_t function_100b0e7(int32_t a1, int32_t a2, int32_t a3) {
    // 0x100b0e7
    int32_t v1; // 0x100b0e7
    int32_t * v2 = (int32_t *)(v1 + 0xc8d0478); // 0x100b0e7
    int32_t v3; // 0x100b0e7
    *v2 = *v2 + v3;
    int32_t v4; // 0x100b0e7
    int32_t v5 = 2 * v4; // 0x100b0ed
    int32_t v6 = (int32_t)*(char *)((v4 & 255) + v1); // 0x100b0f0
    char * v7 = (char *)(v1 + 0x2e9c1c1); // 0x100b0f1
    *v7 = *v7 + (char)v5;
    int32_t v8; // 0x100b0e7
    int32_t v9; // 0x100b0e7
    __asm_rep_movsd_memcpy((char *)v8, (char *)v9, v5);
    bool v10; // 0x100b0e7
    int32_t v11 = v10 ? -4 : 4; // 0x100b0f7
    int32_t v12 = v11 * v5 + v8; // 0x100b0f7
    int32_t v13 = v6 & 3; // 0x100b0fb
    int32_t * v14 = (int32_t *)v13; // 0x100b104
    *v14 = *v14 + (v4 & -256 | v6);
    unknown_6007bd1();
    int32_t v15 = function_1007c26(); // 0x100b111
    g96 = v15;
    *v14 = *v14 + unknown_3884c1(*(int32_t *)v15);
    int32_t v16 = unknown_ffffffec(); // 0x100b130
    *(int32_t *)-0x7400003a = v13;
    *(char *)(v12 + v11) = *(char *)v12;
    int32_t v17 = v12 + (v10 ? -1 : 1); // 0x100b141
    int32_t v18 = *(int32_t *)-0x5efe76ff; // 0x100b143
    *(int32_t *)-0x5efe76ff = v18 + (v16 + 232 & 255 | v16 & -256);
    int32_t v19 = 4 * *(int32_t *)(v17 + 4); // 0x100b151
    uint32_t v20 = v19 + 12; // 0x100b151
    uint32_t v21 = v20 / 4; // 0x100b15a
    __asm_rep_movsd_memcpy((char *)0x6c0063, (char *)v17, v21);
    int32_t v22 = v21 * v11 + 0x6c0063; // 0x100b15d
    *(char *)v22 = *(char *)(v22 + v1);
    *(int32_t *)-0x7400003e = *(int32_t *)(g115 + 99);
    unknown_a77bc1();
    char v23 = g96; // 0x100b173
    unsigned char v24 = v23 - 1; // 0x100b182
    int32_t v25 = (int32_t)v23 & -256; // 0x100b182
    if (((v24 ^ v23) & -v23) >= 0) {
        // 0x100b186
        int32_t v26; // 0x100b0e7
        return v25 | (int32_t)__asm_in_3((int16_t)v26);
    }
    int32_t * v27 = (int32_t *)(v1 + 0x374fa80d); // 0x100b18a
    *v27 = *v27 - 1;
    int32_t * v28 = (int32_t *)(v19 - 0x5b5efbb3); // 0x100b190
    *v28 = *v28 + v20;
    return v25 | (int32_t)v24;
}

// Address range: 0x100b199 - 0x100b1b6
int32_t function_100b199(void) {
    // 0x100b199
    int16_t v1; // 0x100b199
    unknown_c8d0c(v1);
    return function_8ca5ffb8();
}

// Address range: 0x100b1c1 - 0x100b1d7
int32_t function_100b1c1(void) {
    // 0x100b1c1
    int32_t v1; // 0x100b1c1
    int32_t * v2 = (int32_t *)(v1 - 0x35f6); // 0x100b1c1
    int32_t v3; // 0x100b1c1
    *v2 = *v2 + v3;
    g99 = (char *)v1;
    int32_t v4; // 0x100b1c1
    float80_t v5; // 0x100b1c1
    *(int32_t *)(v4 - 1 + 2 * v4) = (int32_t)v5;
    int32_t result; // 0x100b1c1
    return result;
}

// Address range: 0x100b1dd - 0x100b1e3
int32_t function_100b1dd(void) {
    // 0x100b1dd
    int32_t result; // 0x100b1dd
    return result;
}

// Address range: 0x100b1f2 - 0x100b1f4
int32_t function_100b1f2(void) {
    // 0x100b1f2
    int32_t result; // 0x100b1f2
    return result;
}

// Address range: 0x100b229 - 0x100b22a
int32_t function_100b229(int32_t a1) {
    // 0x100b229
    int32_t result; // 0x100b229
    return result;
}

// Address range: 0x100b233 - 0x100b234
int32_t function_100b233(void) {
    // 0x100b233
    int32_t result; // 0x100b233
    return result;
}

// Address range: 0x100b26d - 0x100b272
int32_t function_100b26d(void) {
    // 0x100b26d
    return function_8ca64974();
}

// Address range: 0x100b2c5 - 0x100b2c6
int32_t function_100b2c5(void) {
    // 0x100b2c5
    int32_t result; // 0x100b2c5
    return result;
}

// Address range: 0x100b2c9 - 0x100b2cf
int32_t function_100b2c9(void) {
    // 0x100b2c9
    int32_t result; // 0x100b2c9
    return result;
}

// Address range: 0x100b2df - 0x100b308
int32_t function_100b2df(void) {
    // 0x100b2df
    uint32_t v1; // 0x100b2df
    int32_t * v2 = (int32_t *)(v1 + 0x1fcb40d); // 0x100b2df
    *v2 = *v2 - 1;
    int32_t v3; // 0x100b2df
    int32_t * v4 = (int32_t *)(v3 + 0x4f98a101); // 0x100b2e5
    *v4 = *v4 + v3;
    int32_t v5; // 0x100b2df
    *(int32_t *)v3 = v5 + v3;
    int32_t * v6 = (int32_t *)(v3 & -0xff01 | 0x4e00); // 0x100b2f5
    *v6 = *v6 + (v5 & -0x10000 | v5 + 161 & 255 | 0x4f00);
    char * v7 = (char *)(v1 + 0xcc90c8d); // 0x100b2f7
    *v7 = *v7 | (char)(v1 / 256);
    int32_t v8; // 0x100b2df
    char * v9 = (char *)(v8 - 0x3e3e7500); // 0x100b2fd
    *v9 = *v9 + (char)v3;
    return function_f9a6a60a();
}

// Address range: 0x100b323 - 0x100b325
int32_t function_100b323(void) {
    // 0x100b323
    return function_100b2c5();
}

// Address range: 0x100b383 - 0x100b389
int32_t function_100b383(void) {
    // 0x100b383
    int32_t result; // 0x100b383
    return result;
}

// Address range: 0x100b38d - 0x100b3f4
int32_t function_100b38d(char a1) {
    // 0x100b38d
    int32_t v1; // 0x100b38d
    char * v2 = (char *)(v1 + (int32_t)&g97); // 0x100b396
    bool v3; // 0x100b38d
    *v2 = *v2 - (v3 ? 2 : 1);
    int32_t v4 = *(int32_t *)-0x14fefeb1; // 0x100b39c
    char * v5 = (char *)(v4 + 4); // 0x100b39e
    uint32_t v6; // 0x100b38d
    *v5 = *v5 + (char)(v6 / 256);
    *(int32_t *)g101 = v4;
    int32_t v7 = *(int32_t *)g88; // 0x100b3b3
    *(char *)-0x3bfebbb1 = *(char *)-0x3bfebbb1 + 79;
    uint32_t v8; // 0x100b38d
    uint32_t v9 = v8 / 4; // 0x100b3c8
    int32_t v10; // 0x100b38d
    __asm_rep_movsd_memcpy((char *)v10, (char *)v7, v9);
    bool v11; // 0x100b38d
    char * v12 = (char *)(v9 * (v11 ? -4 : 4) + v10); // 0x100b3d2
    __asm_rep_movsb_memcpy(v12, v12, v8 & 3);
    function_1007bc1(*(int32_t *)(g101 + 4));
    return *(int32_t *)((int32_t)g88 + 4);
}

// Address range: 0x100b41f - 0x100b424
int32_t function_100b41f(void) {
    // 0x100b41f
    return function_8ca6a808();
}

// Address range: 0x100b440 - 0x100b442
int32_t function_100b440(void) {
    // 0x100b440
    return function_100b4be((int32_t)&g125);
}

// Address range: 0x100b446 - 0x100b44f
float80_t function_100b446(void) {
    // 0x100b446
    float80_t v1; // 0x100b446
    return 2 * v1;
}

// Address range: 0x100b455 - 0x100b45b
int32_t function_100b455(void) {
    // 0x100b455
    int32_t result; // 0x100b455
    return result;
}

// Address range: 0x100b48f - 0x100b494
int32_t function_100b48f(void) {
    // 0x100b48f
    return function_f8a6a796();
}

// Address range: 0x100b4a6 - 0x100b4ac
int32_t function_100b4a6(void) {
    // 0x100b4a6
    int32_t result; // 0x100b4a6
    return result;
}

// Address range: 0x100b4be - 0x100b4d5
int32_t function_100b4be(int32_t a1) {
    // 0x100b4be
    int32_t v1; // 0x100b4be
    int32_t * v2 = (int32_t *)(v1 + 0x14f1a0d); // 0x100b4be
    *v2 = *v2 - 1;
    int32_t v3; // 0x100b4be
    int32_t * v4 = (int32_t *)(v3 + 0x11a16d41); // 0x100b4c4
    uint32_t v5 = *v4; // 0x100b4c4
    uint32_t v6 = v5 + v3; // 0x100b4c4
    *v4 = v6;
    unsigned char v7 = (char)v3 & 31; // 0x100b4ca
    if (v7 != 0) {
        int32_t v8; // 0x100b4be
        unsigned char v9 = *(char *)&v8; // 0x100b4ca
        *(char *)v8 = (char)(v6 < v5) << 8 - v7 | v9 >> v7 | (char)((int16_t)v9 << (int16_t)(9 - v7));
    }
    int32_t * v10 = (int32_t *)(v1 + 0x4e8bac70); // 0x100b4cc
    *v10 = *v10 + v3;
    int32_t result; // 0x100b4be
    return result;
}

// Address range: 0x100b4e5 - 0x100b4ea
int32_t function_100b4e5(void) {
    // 0x100b4e5
    return function_8ca6a893();
}

// Address range: 0x100b50f - 0x100b515
int32_t function_100b50f(void) {
    // 0x100b50f
    int32_t result; // 0x100b50f
    return result;
}

// Address range: 0x100b51d - 0x100b57f
int32_t function_100b51d(void) {
    // 0x100b51d
    int32_t v1; // 0x100b51d
    int32_t * v2 = (int32_t *)(v1 + 0x4f90a118); // 0x100b520
    *v2 = *v2 + v1;
    int32_t v3; // 0x100b51d
    int32_t v4; // 0x100b51d
    *(char *)v3 = (char)v4;
    bool v5; // 0x100b51d
    int32_t v6 = (v5 ? -1 : 1) + v3; // 0x100b526
    int32_t v7; // 0x100b51d
    int32_t * v8 = (int32_t *)(v7 + 0x470ff4c); // 0x100b527
    *v8 = *v8 + v1;
    int32_t v9 = unknown_95007bfb(); // 0x100b52d
    unsigned char v10 = g86; // 0x100b532
    unsigned char v11 = (char)v1; // 0x100b532
    g86 = v10 - v11;
    int32_t * v12 = (int32_t *)v1; // 0x100b538
    *v12 = v9;
    int32_t * v13 = (int32_t *)(v6 - 0x74fefeba); // 0x100b53a
    *v13 = (int32_t)(v10 < v11) - v9 + *v13;
    char * v14 = (char *)(v7 - 0x7f5efbb2); // 0x100b540
    *v14 = *v14 ^ v11;
    int32_t v15 = v6 - 1; // 0x100b546
    *v12 = v9 + v1;
    int32_t v16; // 0x100b51d
    uint32_t v17 = (v15 + (4 * v16 | 1024)) / 4; // 0x100b554
    int32_t v18; // 0x100b51d
    __asm_rep_movsd_memcpy((char *)v15, (char *)v18, v17);
    char * v19 = (char *)(v17 * (v5 ? -4 : 4) + v15); // 0x100b55e
    __asm_rep_movsb_memcpy(v19, v19, *(int32_t *)(v9 ^ 56) & 3);
    abort();
    // UNREACHABLE
}

// Address range: 0x100b5a0 - 0x100b5a7
int32_t function_100b5a0(void) {
    // 0x100b5a0
    return function_131c1d3();
}

// Address range: 0x100b5ca - 0x100b5cd
int32_t function_100b5ca(void) {
    // 0x100b5ca
    int32_t result; // 0x100b5ca
    return result;
}

// Address range: 0x100b5cd - 0x100b5d9
int32_t function_100b5cd(int32_t a1) {
    // 0x100b5cd
    int32_t v1; // 0x100b5cd
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x100b5cd
    char * v3 = (char *)(v2 - 0x3eb05de3); // 0x100b5cf
    *v3 = *v3 + (char)v2;
    return __asm_int1();
}

// Address range: 0x100b5e0 - 0x100b60e
int32_t function_100b5e0(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x100b5e0
    int32_t v1; // 0x100b5e0
    int32_t v2; // 0x100b5e0
    int32_t v3 = v2 + v1; // 0x100b5e0
    int32_t v4; // 0x100b5e0
    int32_t v5; // 0x100b5e0
    int32_t result; // 0x100b5e0
    if (v3 < 0 == ((v3 ^ v1) & (v3 ^ v2)) < 0 != v3 != 0) {
        // 0x100b5ee
        *(char *)result = 2 * (char)result;
        __asm_outsb((int16_t)v5, *(char *)&v4);
        return result;
    }
    int32_t * v6 = (int32_t *)(8 * v5 + v2); // 0x100b5f5
    uint32_t v7; // 0x100b5e0
    *v6 = *v6 + v7;
    int32_t v8; // 0x100b5e0
    *(int32_t *)-0xfefeb5 = *(int32_t *)(v8 - 56);
    *(char *)(v4 + 0x4f691d89) = (char)(v7 / 256);
    int32_t v9; // 0x100b5e0
    *(int32_t *)v9 = (result + 1 & 255 | result & -256) + v9;
    return function_10081cc();
}

// Address range: 0x100b640 - 0x100b646
int32_t function_100b640(void) {
    // 0x100b640
    int32_t result; // 0x100b640
    return result;
}

// Address range: 0x100b67d - 0x100b68b
int32_t function_100b67d(void) {
    // 0x100b67d
    int32_t v1; // 0x100b67d
    int32_t * v2 = (int32_t *)(v1 + 0xab000c); // 0x100b67d
    uint32_t v3 = *v2; // 0x100b67d
    *v2 = v3 / 2 | 0x80000000 * v3;
    return function_e4a6a98d();
}

// Address range: 0x100b69d - 0x100b6a3
int32_t function_100b69d(void) {
    // 0x100b69d
    int32_t result; // 0x100b69d
    return result;
}

// Address range: 0x100b6dc - 0x100b6e1
int32_t function_100b6dc(void) {
    // 0x100b6dc
    return function_e245a9e3();
}

// Address range: 0x100b70a - 0x100b70b
int32_t function_100b70a(void) {
    // 0x100b70a
    int32_t result; // 0x100b70a
    return result;
}

// Address range: 0x100b71a - 0x100b720
int32_t function_100b71a(void) {
    // 0x100b71a
    int32_t result; // 0x100b71a
    return result;
}

// Address range: 0x100b726 - 0x100b72c
int32_t function_100b726(void) {
    // 0x100b726
    int32_t result; // 0x100b726
    return result;
}

// Address range: 0x100b760 - 0x100b765
int32_t function_100b760(void) {
    // 0x100b760
    return function_8ca6aa67();
}

// Address range: 0x100b777 - 0x100b77d
int32_t function_100b777(void) {
    // 0x100b777
    int32_t result; // 0x100b777
    return result;
}

// Address range: 0x100b7b6 - 0x100b7bb
int32_t function_100b7b6(void) {
    // 0x100b7b6
    return function_34a5bebd();
}

// Address range: 0x100b7e7 - 0x100b7e8
int32_t function_100b7e7(void) {
    // 0x100b7e7
    int32_t result; // 0x100b7e7
    return result;
}

// Address range: 0x100b7f4 - 0x100b7fa
int32_t function_100b7f4(void) {
    // 0x100b7f4
    int32_t result; // 0x100b7f4
    return result;
}

// Address range: 0x100b7fb - 0x100b806
int32_t function_100b7fb(void) {
    // 0x100b7fb
    uint32_t v1; // 0x100b7fb
    int32_t v2; // 0x100b7fb
    return v1 / 256 & 255 ^ v2;
}

// Address range: 0x100b819 - 0x100b81c
int32_t function_100b819(void) {
    // 0x100b819
    int32_t result; // 0x100b819
    return result;
}

// Address range: 0x100b83a - 0x100b83f
int32_t function_100b83a(void) {
    // 0x100b83a
    return function_6ba6ab41();
}

// Address range: 0x100b84b - 0x100b8cf
int32_t function_100b84b(uint32_t a1) {
    // 0x100b84b
    function_1007b8d();
    int32_t v1 = *(int32_t *)(g111 + 4); // 0x100b861
    int32_t v2; // 0x100b84b
    *(int32_t *)(v2 - 4) = *(int32_t *)(v1 + 4);
    int32_t v3 = *(int32_t *)-0x56feb008; // 0x100b86c
    *(int32_t *)(v3 + 4) = v1;
    int32_t v4 = v1 - *(int32_t *)v3; // 0x100b877
    uint32_t v5 = v4 + a1; // 0x100b879
    if (((v5 ^ a1) & (v5 ^ v4)) < 0) {
        int32_t v6 = v4 - (v5 < a1 ? -0x7c000036 : -0x7c000037); // 0x100b8ab
        int32_t * v7 = (int32_t *)v6; // 0x100b8b0
        *v7 = *v7 + 1;
        char * v8 = (char *)v6; // 0x100b8b2
        unsigned char v9 = *v8; // 0x100b8b2
        unsigned char v10 = v9 + (char)v6; // 0x100b8b2
        *v8 = v10;
        *(int32_t *)0x1484fff = v6;
        int32_t result = unknown_6e81cc(v5); // 0x100b8b9
        *(int32_t *)(v2 - 8) = 400;
        *(int32_t *)0x1144f3e = result;
        char * v11 = (char *)(result + 63); // 0x100b8c8
        *v11 = *v11 + (char)(v10 >= v9);
        return result;
    }
    // 0x100b87d
    int32_t v12; // 0x100b84b
    int32_t v13 = 2 * v12; // 0x100b84b
    int32_t v14; // 0x100b84b
    int32_t v15 = *(int32_t *)(v14 + 4); // 0x100b87d
    int32_t v16; // 0x100b84b
    char * v17 = (char *)(v16 + 0x282ccc1); // 0x100b88d
    *v17 = *v17 + (char)v15;
    __asm_rep_movsd_memcpy((char *)v13, (char *)v14, v15);
    bool v18; // 0x100b84b
    int32_t v19 = v15 * (v18 ? -4 : 4) + v13; // 0x100b894
    char * v20 = (char *)v19; // 0x100b896
    *v20 = (char)*(int32_t *)(v14 - 0x72f372fc);
    __asm_fbld(*(float80_t *)&v16);
    __asm_int(243);
    *(char *)(v19 + (v18 ? -1 : 1)) = *v20;
    int32_t * v21 = (int32_t *)g114; // 0x100b8a3
    *v21 = -*v21;
    *(int32_t *)(v2 - 8) = 0xffff;
    return g114;
}

// Address range: 0x100b8cf - 0x100b946
int32_t function_100b8cf(void) {
    // 0x100b8cf
    int32_t v1; // 0x100b8cf
    int32_t * v2 = (int32_t *)(2 * v1 - 93); // 0x100b8cf
    uint32_t v3; // 0x100b8cf
    *v2 = *v2 + v3;
    int32_t v4; // 0x100b8cf
    int32_t v5 = v4 - 1; // bp-4, 0x100b8d9
    int32_t v6 = &v5; // bp+52, 0x100b8dd
    *(int32_t *)0x3a2224d4 = v1 + v4;
    function_10081cc();
    int32_t v7; // 0x100b8cf
    unsigned char v8 = (char)v7; // 0x100b8ee
    unsigned char v9 = v8 + (char)(v3 / 256); // 0x100b8ee
    int32_t v10 = v7 & -256 | (int32_t)v9; // 0x100b8ee
    int32_t v11; // 0x100b8cf
    char * v12 = (char *)(v11 + 1 + 4 * (int32_t)&v6); // 0x100b8f0
    *v12 = *v12 - (v9 < v8 ? 2 : 1);
    g124 = function_1001bcc();
    int32_t v13 = function_10081cc(); // 0x100b904
    char v14 = __asm_in_3((int16_t)v10); // 0x100b909
    *(int32_t *)-0x52feff10 = (v13 & -256 | (int32_t)v14) ^ (int32_t)&g112;
    unknown_d17bd1();
    int32_t v15 = function_1007c26(); // 0x100b91f
    g112 = v15;
    int32_t v16 = *(int32_t *)v15; // 0x100b929
    int32_t v17 = v16; // bp+46, 0x100b929
    unknown_977bc1(v16);
    int32_t * v18 = (int32_t *)(v10 + 0x20470ff); // 0x100b93c
    *v18 = *v18 + (int32_t)&v17;
    return *(int32_t *)-0x4cfeb010;
}

// Address range: 0x100b953 - 0x100b954
int32_t function_100b953(void) {
    // 0x100b953
    int32_t result; // 0x100b953
    return result;
}

// Address range: 0x100b961 - 0x100b980
int32_t function_100b961(void) {
    // 0x100b961
    int32_t v1; // 0x100b961
    bool v2; // 0x100b961
    if (!v2) {
        v1 = function_100b953();
    }
    int32_t v3 = v1;
    int32_t v4; // 0x100b961
    char v5 = *(char *)(*(int32_t *)(v4 - 0xb5efd78) & v3); // 0x100b975
    int32_t v6; // 0x100b961
    int32_t * v7 = (int32_t *)(v6 + 112); // 0x100b977
    int32_t v8; // 0x100b961
    *v7 = 2 * v8 - 0x3e9e0000 + *v7;
    int32_t v9; // 0x100b961
    char v10 = __asm_insb((int16_t)(v9 + 256 * v6 & 0xff00 | v9 & 255)); // 0x100b97c
    bool v11; // 0x100b961
    *(char *)((v11 ? -4 : 4) + v8) = v10;
    return v3 & -256 | (int32_t)((char)v3 - 24 - v5);
}

// Address range: 0x100b980 - 0x100bbd4
int32_t function_100b980(void) {
    // 0x100b980
    int32_t v1; // 0x100b980
    int64_t v2; // 0x100b980
    __asm_pmuludq(v2, *(int64_t *)(v1 + 1));
    int32_t v3; // 0x100b980
    int32_t * v4 = (int32_t *)(v3 - 0xf29bda8); // 0x100b984
    *v4 = *v4 + v3;
    int32_t v5; // 0x100b980
    int32_t v6; // 0x100b980
    int32_t v7 = v5 + v6; // 0x100b98b
    *(int32_t *)v5 = v7;
    if (((v7 ^ v5) & (v7 ^ v6)) >= 0) {
        int32_t result = (v6 & -256 | (int32_t)*(char *)(9 * v1 - 9)) - 1; // 0x100b993
        __asm_arpl_8((int16_t)result);
        return result;
    }
    // 0x100b997
    uint32_t v8; // 0x100b980
    char * v9 = (char *)(v8 + 0x1118844); // 0x100b997
    unsigned char v10 = *v9; // 0x100b997
    unsigned char v11 = (char)v5 & 31; // 0x100b997
    if (v11 != 0) {
        *v9 = v10 << 8 - v11 | v10 >> v11;
    }
    int32_t * v12 = (int32_t *)(v5 + 0x3ca10441); // 0x100b99d
    *v12 = *v12 + v5;
    int32_t v13 = v1 - 2; // 0x100b9a3
    int32_t v14; // 0x100b980
    int32_t * v15 = (int32_t *)(v14 - 117); // 0x100b9a4
    int32_t v16 = *v15; // 0x100b9a4
    int32_t v17 = v16 + v8; // 0x100b9a4
    *v15 = v17;
    int32_t v18; // 0x100b980
    int32_t v19 = ((v17 ^ v16) & (v17 ^ v8)) < 0 ? v18 : v14 + 4;
    int32_t v20 = __asm_hlt(); // 0x100b9ad
    *(char *)v5 = *(char *)&v5 + 1;
    int32_t * v21 = (int32_t *)(v8 + 0xc8d040b); // 0x100b9b0
    *v21 = v5 + *v21;
    int32_t v22 = v5; // 0x100b9b6
    char * v23 = (char *)v20; // 0x100b9b9
    *v23 = *v23 + (char)v20;
    uint32_t v24 = v5;
    uint32_t v25 = v24 / 4; // 0x100b9bd
    int32_t v26; // 0x100b980
    __asm_rep_movsd_memcpy((char *)v13, (char *)v26, v25);
    bool v27; // 0x100b980
    int32_t v28 = v25 * (v27 ? -4 : 4) + v13; // 0x100b9c0
    uint32_t v29; // 0x100b980
    __asm_outsd((int16_t)v29, *(int32_t *)v28);
    __asm_int(243);
    int32_t v30 = v28 + (v27 ? -1 : 1); // 0x100b9c7
    int32_t v31 = v24 & -0xff01; // 0x100b9c8
    *(int32_t *)v24 = v31 + v24;
    unsigned char v32 = (char)(v8 / 256); // 0x100b9ce
    unsigned char v33 = (char)(v29 / 256) + v32; // 0x100b9ce
    char * v34 = (char *)(v24 + (int32_t)&g75); // 0x100b9d0
    char v35 = *v34 - (char)(v33 < v32); // 0x100b9d0
    *v34 = v35;
    int64_t v36; // 0x100b980
    __asm_psllq(v36, *(int64_t *)(v19 + 20));
    int32_t v37 = *(int32_t *)(v19 + 24) * v31; // 0x100b9db
    g121 = v37;
    int32_t * v38; // 0x100b980
    int32_t v39; // 0x100b980
    if (v35 == 0) {
        // 0x100b9ad
        v38 = (int32_t *)v30;
        v39 = v37;
    } else {
        int32_t * v40 = (int32_t *)((256 * (int32_t)v33 | v8 & -0xff01) + 0x6806); // 0x100bb8c
        *v40 = v5 & *v40;
        char * v41 = (char *)(v37 + 0x500470ff); // 0x100bb92
        *v41 = *v41 + (char)v37;
        unknown_5a011b2d();
        int32_t * v42 = (int32_t *)v30;
        int32_t result2 = *v42; // 0x100bb9d
        int32_t v43 = *(int32_t *)(*(int32_t *)result2 - 27); // 0x100bba1
        v5 = v43;
        if (v43 >= 0) {
            // 0x100bb83
            return result2;
        }
        // 0x100bba8
        v5 = *(int32_t *)(*(int32_t *)(result2 + 4) + 8) + v43;
        v38 = v42;
        v39 = *v42;
    }
    // 0x100bbb0
    *(int32_t *)(*(int32_t *)v39 + 8) = 0;
    uint32_t v44 = v5 - 1; // 0x100bbbc
    char * v45 = (char *)(v22 - 0x74f19937); // 0x100bbbd
    *v45 = *v45 | (char)*v38 + 67;
    char * v46 = (char *)v44; // 0x100bbc3
    *v46 = *v46 + (char)(v44 / 256);
    int32_t v47 = *v38; // 0x100bbc7
    char * v48 = (char *)(v30 - 62); // 0x100bbcf
    *v48 = *v48 + (char)*(int32_t *)(v30 - 0x529f7cfc);
    return v47 + 246 & 255 | v47 & -256;
}

// Address range: 0x100bbd4 - 0x100bc53
int32_t function_100bbd4(void) {
    int32_t result = __asm_int1(); // 0x100bbd6
    bool v1; // 0x100bbd4
    bool v2; // 0x100bbd4
    if (v2 != v1) {
        // 0x100bc4d
        return result;
    }
    int32_t v3 = function_100c518(*(int32_t *)(result | 139)); // 0x100bbde
    int32_t v4; // 0x100bbd4
    int32_t v5 = v4 - 36; // 0x100bbe3
    __readfsbyte(v5);
    __writefsbyte(v5, 0);
    int32_t v6; // 0x100bbd4
    char * v7 = (char *)((v6 & -0xff01 | 0x2400) + 0x78b1200); // 0x100bbf0
    *v7 = *v7 & (char)v6;
    int32_t * v8 = (int32_t *)(v3 - 96); // 0x100bbf9
    *v8 = *v8 + 110;
    int32_t v9; // 0x100bbd4
    function_101276c(*(int32_t *)(v9 + 4));
    int32_t v10; // 0x100bbd4
    unknown_4600ab09(v10);
    int32_t * v11 = (int32_t *)(v4 + 0x64a10004); // 0x100bc16
    uint32_t v12 = *v11; // 0x100bc16
    *v11 = v12 + 79;
    if (v12 > 0xffffffb0) {
        // 0x100bc46
        int32_t v13; // 0x100bbd4
        bool v14; // 0x100bbd4
        __asm_rep_movsd_memcpy((char *)0x78bc3ff, (char *)((v14 ? -4 : 4) + v9), v13);
        // 0x100bc4d
        return result;
    }
    int32_t v15 = v9 + 232; // 0x100bc21
    unsigned char v16 = (char)v15; // 0x100bc23
    int32_t v17 = v16 < 191 ? v15 : v9 + 41; // 0x100bc23
    return v17 & 255 | v9 & -0x10000 | 256 * (int32_t)(v16 > 190);
}

// Address range: 0x100bc53 - 0x100bc54
int32_t function_100bc53(int32_t a1) {
    // 0x100bc53
    int32_t result; // 0x100bc53
    return result;
}

// Address range: 0x100bc54 - 0x100bcb5
int32_t function_100bc54(void) {
    // 0x100bc54
    int32_t v1; // 0x100bc54
    *(char *)0x85d8b53 = (char)v1 ^ -125;
    int32_t v2; // 0x100bc54
    int32_t v3 = *(int32_t *)(v2 + 12); // 0x100bc63
    float80_t v4; // 0x100bc54
    float80_t v5 = __asm_fbstp(v4); // 0x100bc66
    int32_t v6 = v3 + 4; // 0x100bc66
    *(float80_t *)v6 = v5;
    int32_t v7; // 0x100bc54
    char v8 = *(char *)(v7 + 0x5ca2e804); // 0x100bc69
    char * v9 = (char *)v3; // 0x100bc6f
    int32_t v10; // 0x100bc54
    *v9 = *v9 + (char)v10;
    if (v7 == 0) {
        int32_t v11; // 0x100bc54
        int32_t v12 = v11 - 1; // 0x100bcb2
        v11 = v12;
        while (v12 != 0) {
            // 0x100bcb1
            v12 = v11 - 1;
            v11 = v12;
        }
        // 0x100bcb5
        return 0;
    }
    int32_t v13 = *(int32_t *)(v7 + 4); // 0x100bc85
    uint32_t v14; // 0x100bc54
    int32_t v15 = (256 * (int32_t)((char)(v14 / 256) - v8) | v14 & -0xff01) + 1; // 0x100bc8a
    *(int32_t *)v13 = v15;
    *(int32_t *)(v2 + 4) = v3;
    int32_t * v16 = (int32_t *)(v13 + 139 & 255 | v13 & -256); // 0x100bc94
    *v16 = *v16 * v10;
    *(int32_t *)(v2 - 2) = -0x7fffffdd;
    *(int32_t *)*(int32_t *)v6 = v15;
    *(int32_t *)(v2 - 6) = *(int32_t *)v3;
    unknown_30161a3c();
    return function_100bd5b((int32_t)&g125, (int32_t)&g125);
}

// Address range: 0x100bcb6 - 0x100bd5b
int32_t function_100bcb6(int16_t a1) {
    // 0x100bcb6
    int32_t v1; // 0x100bcb6
    char * v2 = (char *)(v1 + 0x4403203); // 0x100bcbd
    char v3 = *v2; // 0x100bcbd
    int32_t v4; // 0x100bcb6
    char v5 = v4; // 0x100bcbd
    char v6 = v3 + v5; // 0x100bcbd
    *v2 = v6;
    int32_t result; // 0x100bcb6
    if (((v6 ^ v3) & (v6 ^ v5)) < 0) {
        // 0x100bcd3
        return result;
    }
    int32_t v7 = *(int32_t *)-0x6aa3bacb; // 0x100bccb
    int32_t * v8 = (int32_t *)(result + 0x1300000c); // 0x100bcd7
    *v8 = *v8 & v1;
    int32_t v9 = result & 3; // 0x100bce8
    __asm_rep_movsb_memcpy((char *)result, (char *)-0x5a0cfd17, v9);
    int32_t v10 = *(int32_t *)(v7 + 12); // 0x100bced
    int32_t * v11 = (int32_t *)(v10 + 4); // 0x100bcf0
    int32_t v12 = function_1011e14(v7 - 4, *v11); // 0x100bcf7
    int32_t v13 = *v11; // bp-14, 0x100bcfc
    *(int32_t *)(v9 + result) = v12;
    int16_t v14; // 0x100bcb6
    int32_t v15 = unknown_dff0e8(v14, v13); // 0x100bd00
    int32_t * v16 = (int32_t *)v10; // 0x100bd0f
    *v16 = *v16 + (int32_t)&v13;
    int32_t v17 = v15 ^ 128; // 0x100bd18
    function_101763c(v17, 0x10000 * *(int32_t *)(v17 + 4) / 0x10000);
    int32_t * v18 = (int32_t *)v1; // 0x100bd23
    unknown_1000ac1(*(int32_t *)(*v18 + 4));
    *(int32_t *)(*v18 + 4) = 0;
    int32_t result2 = *(int32_t *)(*v18 + 4); // 0x100bd51
    *(int32_t *)result2 = 0xec01;
    return result2;
}

// Address range: 0x100bd5b - 0x100bd61
int32_t function_100bd5b(int32_t a1, int32_t a2) {
    // 0x100bd5b
    int32_t result; // 0x100bd5b
    return result;
}

// Address range: 0x100bd61 - 0x100bd6f
int32_t function_100bd61(int32_t a1) {
    // 0x100bd61
    return function_1011a18();
}

// Address range: 0x100bd6f - 0x100bd70
int32_t function_100bd6f(int32_t a1) {
    // 0x100bd6f
    int32_t result; // 0x100bd6f
    return result;
}

// Address range: 0x100bd7e - 0x100bd7f
int32_t function_100bd7e(int32_t a1, int16_t a2) {
    // 0x100bd7e
    int32_t result; // 0x100bd7e
    return result;
}

// Address range: 0x100bdb3 - 0x100bdb5
int32_t function_100bdb3(void) {
    // 0x100bdb3
    return function_100bdd0();
}

// Address range: 0x100bdba - 0x100bdbd
int32_t function_100bdba(void) {
    // 0x100bdba
    int32_t result; // 0x100bdba
    return result;
}

// Address range: 0x100bdd0 - 0x100be29
int32_t function_100bdd0(void) {
    // 0x100bdd0
    int32_t v1; // 0x100bdd0
    int32_t v2; // 0x100bdd0
    *(int32_t *)v1 = (v2 ^ 42) + v1;
    int32_t v3; // 0x100bdd0
    function_100d5eb(v3 + 13);
    int32_t v4; // 0x100bdd0
    int32_t * v5 = (int32_t *)(v4 + 4); // 0x100bde0
    *(int32_t *)(function_1007bc1(*v5) + 4) = 0;
    int32_t v6 = g80; // 0x100bdee
    *v5 = v6;
    int32_t v7 = *(int32_t *)0x15b4f64; // 0x100be00
    unsigned char v8 = g80 - 117; // 0x100be08
    int32_t v9; // 0x100bdd0
    int32_t * v10 = (int32_t *)(v9 + 0xc8d0478); // 0x100be0a
    uint32_t v11 = *v10; // 0x100be0a
    *v10 = v11 / 2 | 0x80000000 * v11;
    bool v12; // 0x100bdd0
    int32_t v13 = v12 ? -4 : 4; // 0x100be10
    char * v14 = (char *)(v6 & -256 | (int32_t)v8); // 0x100be13
    *v14 = *v14 + v8;
    *(int32_t *)(v4 - 4) = v3 + 1;
    __asm_rep_movsb_memcpy((char *)(v13 + v4), (char *)(v13 - 1 + v7), v4);
    int32_t v15; // bp-10, 0x100bdd0
    return &v15;
}

// Address range: 0x100be29 - 0x100be30
int32_t function_100be29(int32_t a1) {
    // 0x100be29
    return *(int32_t *)a1;
}

// Address range: 0x100be30 - 0x100be3a
int32_t function_100be30(void) {
    // 0x100be30
    int32_t v1; // 0x100be30
    return v1 | 232;
}

// Address range: 0x100be3b - 0x100be44
int32_t function_100be3b(void) {
    // 0x100be3b
    int32_t v1; // 0x100be3b
    int32_t * v2 = (int32_t *)(v1 + 0x5e184d06); // 0x100be3b
    *v2 = *v2 - 1;
    int32_t result; // 0x100be3b
    return result;
}

// Address range: 0x100be5f - 0x100be60
int32_t function_100be5f(void) {
    // 0x100be5f
    int32_t result; // 0x100be5f
    return result;
}

// Address range: 0x100be63 - 0x100be64
int32_t function_100be63(void) {
    // 0x100be63
    int32_t result; // 0x100be63
    return result;
}

// Address range: 0x100be9c - 0x100befe
int32_t function_100be9c(void) {
    // 0x100be9c
    int32_t v1; // 0x100be9c
    int32_t v2; // 0x100be9c
    int32_t v3; // 0x100be9c
    __asm_rep_movsd_memcpy((char *)v1, (char *)v2, v3);
    bool v4; // 0x100be9c
    int32_t v5 = (v4 ? -4 : 4) * v3 + v1; // 0x100be9c
    int32_t v6; // 0x100be9c
    function_1007bc1(*(int32_t *)(*(int32_t *)(v6 - 4) - 43));
    int32_t v7 = *(int32_t *)((int32_t)g88 - 33); // 0x100bebb
    uint16_t v8; // 0x100be9c
    *(int32_t *)((int32_t)v8 + 4) = (v7 + 232 & 255 | v7 & -256) ^ 0x68ffff52;
    int32_t v9 = v5 + 4; // 0x100bed4
    int32_t v10 = *(int32_t *)(v6 - 66); // 0x100bed7
    int32_t v11 = *(int32_t *)(*(int32_t *)v9 + 4); // 0x100beda
    int32_t v12 = *(int32_t *)(v10 + 0x36c5b4c1); // 0x100bee7
    *(int32_t *)v5 = *(int32_t *)v11;
    *(int32_t *)(v12 - 4) = v6 - 1;
    *(int32_t *)(v12 + 0x636b) = v10;
    __asm_rep_movsb_memcpy((char *)v9, (char *)(v11 + 4), 0);
    return unknown_99bdb7();
}

// Address range: 0x100beff - 0x100bf18
int32_t function_100beff(int32_t a1) {
    // 0x100beff
    int32_t v1; // 0x100beff
    return unknown_7200dff5(*(int32_t *)(v1 - 74));
}

// Address range: 0x100bf18 - 0x100bf43
int32_t function_100bf18(void) {
    // 0x100bf18
    int32_t v1; // 0x100bf18
    __asm_in_3((int16_t)v1);
    int32_t v2; // 0x100bf18
    int32_t v3 = *(int32_t *)(v2 + 8); // 0x100bf21
    int32_t v4 = *(int32_t *)*(int32_t *)v3; // 0x100bf2c
    int32_t v5; // 0x100bf18
    return unknown_79085f18(v4, v3, v5) - 0x23ffc18b ^ (int32_t)&g111;
}

// Address range: 0x100bf43 - 0x100bf9c
int32_t function_100bf43(void) {
    // 0x100bf43
    function_1008c96();
    *(int32_t *)-0x12d5cb98 = *(int32_t *)-0x12d5cb98 + 1;
    int32_t v1; // 0x100bf43
    int32_t v2 = v1 + 12; // 0x100bf52
    int32_t * v3 = (int32_t *)v2; // 0x100bf56
    *v3 = -0x7fcbffa3;
    function_101a670(v2);
    int32_t v4; // 0x100bf43
    int32_t v5 = unknown_ab0081f8(*v3, v4); // 0x100bf66
    *(int32_t *)v4 = v5;
    *v3 = v5;
    unknown_4b007bd1();
    int32_t * v6 = (int32_t *)(v1 + 56); // 0x100bf76
    *v6 = *v6 & -57;
    int32_t v7 = function_1007ba3(); // 0x100bf7a
    int32_t * v8 = (int32_t *)(v1 - 4); // 0x100bf7f
    *v8 = v7;
    function_1007bc1(*(int32_t *)v7);
    int32_t v9; // 0x100bf43
    *(int32_t *)v9 = v9 ^ -95;
    bool v10; // 0x100bf43
    int32_t * v11 = (int32_t *)(v4 - 1 + (v10 ? -4 : 4)); // 0x100bf92
    int32_t v12; // 0x100bf43
    *v11 = *v11 + v12;
    return *v8 & -256 | (int32_t)__asm_in_1(0);
}

// Address range: 0x100bf9c - 0x100bfa2
int32_t function_100bf9c(void) {
    // 0x100bf9c
    int32_t result; // 0x100bf9c
    return result;
}

// Address range: 0x100bfba - 0x100bfc1
int32_t function_100bfba(void) {
    // 0x100bfba
    return function_8ca6b2c3();
}

// Address range: 0x100bfce - 0x100bfcf
int32_t function_100bfce(void) {
    // 0x100bfce
    int32_t result; // 0x100bfce
    return result;
}

// Address range: 0x100c00d - 0x100c012
int32_t function_100c00d(void) {
    // 0x100c00d
    return function_8ca61814();
}

// Address range: 0x100c014 - 0x100c017
int32_t function_100c014(void) {
    // 0x100c014
    return function_100c071();
}

// Address range: 0x100c027 - 0x100c03a
int32_t function_100c027(void) {
    // 0x100c027
    int32_t v1; // 0x100c027
    int32_t * v2 = (int32_t *)(v1 - 5); // 0x100c027
    int32_t v3; // 0x100c027
    int32_t v4 = *v2 ^ v3; // 0x100c027
    *v2 = v4;
    int32_t result; // 0x100c027
    if (v4 >= 0 == (v4 != 0)) {
        result = function_100bfce();
    }
    // 0x100c031
    return result;
}

// Address range: 0x100c04b - 0x100c052
int32_t function_100c04b(void) {
    // 0x100c04b
    int32_t v1; // 0x100c04b
    int32_t * v2 = (int32_t *)(v1 - 0x17c500fa); // 0x100c04b
    *v2 = *v2 - 1;
    int32_t result; // 0x100c04b
    return result;
}

// Address range: 0x100c05c - 0x100c05d
int32_t function_100c05c(void) {
    // 0x100c05c
    int32_t result; // 0x100c05c
    return result;
}

// Address range: 0x100c065 - 0x100c06b
int32_t function_100c065(void) {
    // 0x100c065
    int32_t v1; // 0x100c065
    __asm_into(v1);
    int32_t v2; // 0x100c065
    int32_t v3; // 0x100c065
    return v3 & -256 | v2 & 255;
}

// Address range: 0x100c071 - 0x100c085
int32_t function_100c071(void) {
    // 0x100c071
    int32_t v1; // 0x100c071
    *(int32_t *)(v1 + 12) = -0x7fcbffff;
    return function_1012670(0x45840101);
}

// Address range: 0x100c088 - 0x100c0f2
int32_t function_100c088(void) {
    int32_t v1 = function_10081f8(); // 0x100c088
    int32_t v2; // 0x100c088
    int32_t * v3 = (int32_t *)(v2 + 0x4f90a100); // 0x100c0ae
    *v3 = *v3 & -21;
    int32_t * v4 = (int32_t *)(v2 + 0x7e70ff00); // 0x100c0b5
    uint32_t v5; // 0x100c088
    *v4 = *v4 + v5;
    int32_t v6 = function_1007c0e(*(int32_t *)((v1 | 232) + v5 / 256 & 255 | v1 & -256)); // 0x100c0bb
    *(int32_t *)*(int32_t *)(v5 - 4) = v6;
    int32_t v7 = *(int32_t *)-0x77fe4170; // 0x100c0c5
    int32_t v8 = *(int32_t *)v7; // 0x100c0ca
    int32_t v9; // 0x100c088
    unsigned char v10 = *(char *)(v9 - 4) ^ (char)v7; // 0x100c0cf
    int32_t v11 = v7 & -256 | (int32_t)v10; // 0x100c0cf
    char * v12 = (char *)v11; // 0x100c0d9
    *v12 = *v12 + v10;
    uint32_t v13 = 5 * v8 / 0x800000; // 0x100c0dc
    *(int32_t *)*(int32_t *)v11 = *(int32_t *)v8;
    __asm_rep_movsb_memcpy((char *)(v13 | 2560 * v8), (char *)(v8 + 4), v13 & 94);
    return *(int32_t *)(v9 + 21);
}

// Address range: 0x100c108 - 0x100c15c
int32_t function_100c108(void) {
    // 0x100c108
    *(char *)(*(int32_t *)0x1974f90 + 4) = -1;
    uint32_t v1; // 0x100c108
    *(int32_t *)v1 = v1 / 0x800000 | 512 * v1;
    int32_t v2; // 0x100c108
    char v3 = *(char *)&v2; // 0x100c13d
    *(char *)*(int32_t *)((v1 + 139 & 255 | v1 & -256) + 4) = v3;
    int32_t v4; // 0x100c108
    function_1008648(*(int32_t *)(v4 + 73));
    function_100bd6f(*(int32_t *)(v4 + 9));
    return unknown_9b00a9d1(*(int32_t *)(v4 - 3));
}

// Address range: 0x100c172 - 0x100c223
int32_t function_100c172(void) {
    // 0x100c172
    int32_t v1; // 0x100c172
    int32_t v2 = *(int32_t *)(v1 + 0x4478b70); // 0x100c173
    int32_t v3; // 0x100c172
    int32_t v4; // 0x100c172
    int32_t v5 = v4 + v3; // 0x100c17b
    uint32_t v6; // 0x100c172
    char * v7 = (char *)(v6 + 12); // 0x100c1c3
    bool v8 = ((v5 ^ v3) & (v5 ^ v4)) < 0; // 0x100c17b
    int32_t v9 = v5;
    int32_t v10; // 0x100c172
    int32_t v11 = v10;
    int32_t v12 = v2;
    int32_t * v13 = (int32_t *)(v12 - 0x5e3974fe + 4 * v12); // 0x100c17d
    *v13 = *v13 / 1024;
    int32_t v14; // 0x100c172
    int32_t v15 = v2 + v14 - v12; // 0x100c189
    int32_t v16; // bp-4, 0x100c172
    *(int32_t *)((int32_t)&v16 - 4) = v15;
    *(int32_t *)(v11 + 12) = v15;
    int32_t v17; // 0x100c172
    int32_t * v18 = (int32_t *)(v15 - 118 + (v8 ? v17 : v12)); // 0x100c19d
    *v18 = *v18 / 2;
    *(int32_t *)(v9 + 8) = v15;
    *(int32_t *)(v11 - 8) = v15;
    int32_t v19 = *(int32_t *)(v9 + 12); // 0x100c1ae
    int32_t v20 = v15 & -256 | v15 + 13 & 73 | 182; // 0x100c1be
    *v7 = *v7 | (char)(v6 / 256);
    int32_t v21 = v11 + 1; // 0x100c1c5
    v8 = (v21 & (v11 ^ -0x80000000)) < 0;
    int32_t v22 = v9 - 1; // 0x100c1c7
    while (v21 < 0 != (v21 & (v11 ^ -0x80000000)) < 0) {
        // 0x100c17d
        v9 = v22;
        v11 = v21;
        v12 = v2;
        v13 = (int32_t *)(v12 - 0x5e3974fe + 4 * v12);
        *v13 = *v13 / 1024;
        v15 = v20 - v12;
        *(int32_t *)(*(int32_t *)(v6 + 53) - 0xbdc766e) = v15;
        *(int32_t *)(v11 + 12) = v15;
        v18 = (int32_t *)(v15 - 118 + (v8 ? 0x46c8f04d : v12));
        *v18 = *v18 / 2;
        *(int32_t *)(v9 + 8) = v15;
        *(int32_t *)(v11 - 8) = v15;
        v19 = *(int32_t *)(v9 + 12);
        v20 = v15 & -256 | v15 + 13 & 73 | 182;
        *v7 = *v7 | (char)(v6 / 256);
        v21 = v11 + 1;
        v8 = (v21 & (v11 ^ -0x80000000)) < 0;
        v22 = v9 - 1;
    }
    int32_t v23 = *(int32_t *)(v11 - 19) + v20 - *(int32_t *)(v9 + 7); // 0x100c1cf
    unsigned char v24 = (char)v23; // 0x100c1d5
    __asm_out_6(194, v24);
    if (*(int32_t *)(v9 + 57) > *(int32_t *)(v19 + 89)) {
        // 0x100c1d9
        return v23 + 137 & 255 | v23 & -256;
    }
    int32_t v25 = v11 + 2; // 0x100c1ef
    if (v25 < 0 == (v25 & v11 - 0x7fffffff) < 0) {
        char * v26 = (char *)(v6 + 0x45030456); // 0x100c1f5
        *v26 = *v26 | (char)v2;
        return 256 * (int32_t)(v24 / 70) | v23 & -0x10000 | (int32_t)((v24 % 70 | 43) + 59);
    }
    // 0x100c20e
    *(int32_t *)0x4a8c745a = *(int32_t *)0x4a8c745a - 116;
    char * v27 = (char *)(*(int32_t *)(v11 + 18) + 34); // 0x100c21a
    *v27 = *v27 | (char)v2;
    return function_100c22b();
}

// Address range: 0x100c223 - 0x100c228
int32_t function_100c223(void) {
    // 0x100c223
    return function_100c22b();
}

// Address range: 0x100c22b - 0x100c248
int32_t function_100c22b(void) {
    // 0x100c22b
    int32_t v1; // 0x100c22b
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x100c230
    *v2 = *v2 - 1;
    int32_t * v3 = (int32_t *)(v1 - 8); // 0x100c233
    *v3 = *v3 + 1;
    int32_t v4; // 0x100c22b
    *(int32_t *)v4 = v4 | 21;
    return function_13a4f3e();
}

// Address range: 0x100c248 - 0x100c266
int32_t function_100c248(void) {
    // 0x100c248
    int32_t v1; // 0x100c248
    int32_t v2; // 0x100c248
    int32_t v3; // 0x100c248
    bool v4; // 0x100c248
    if (v4) {
        // 0x100c24a
        int32_t v5; // 0x100c248
        *(char *)v5 = (char)v3;
        int32_t v6; // 0x100c248
        v2 = v6 - 1;
        bool v7; // 0x100c248
        v1 = (v7 ? -1 : 1) + v5;
    }
    // 0x100c24c
    int32_t v8; // 0x100c248
    int16_t v9 = (int16_t)v8 - 1; // 0x100c252
    int32_t v10; // 0x100c248
    __asm_out_2(v9, (int32_t)&v10);
    *(int32_t *)(v3 - 4) = *(int32_t *)v1;
    int32_t v11 = function_1007bc1((int32_t)&g125); // 0x100c258
    __asm_outsb(v9, *(char *)v2);
    unsigned char v12 = (char)v11; // 0x100c261
    int32_t v13 = v12 < 201 ? v11 : v11 + 55; // 0x100c261
    return v13 & 255 | v11 & -0x10000 | 256 * (int32_t)(v12 > 200);
}

// Address range: 0x100c2cf - 0x100c2d4
float80_t function_100c2cf(void) {
    // 0x100c2cf
    int32_t v1; // 0x100c2cf
    int32_t v2; // 0x100c2cf
    return (float80_t)*(int32_t *)(v2 + 8 * v1);
}

// Address range: 0x100c2d5 - 0x100c302
int32_t function_100c2d5(void) {
    // 0x100c2d5
    int32_t v1; // 0x100c2d5
    int32_t * v2 = (int32_t *)(v1 - 0x74fffb9d); // 0x100c2d5
    int32_t v3 = *v2 + 1; // 0x100c2d5
    *v2 = v3;
    if (v3 == 0) {
        // 0x100c2dd
        int32_t v4; // 0x100c2d5
        return *(int32_t *)(v4 + 4);
    }
    // 0x100c2e9
    int32_t v5; // 0x100c2d5
    __asm_out_6(141, (char)v5 - 114);
    return function_8ca6b604();
}

// Address range: 0x100c318 - 0x100c32b
int32_t function_100c318(int32_t a1) {
    // 0x100c318
    int32_t v1; // 0x100c318
    int32_t v2; // 0x100c318
    *(int32_t *)v1 = __asm_insd((int16_t)v2);
    return function_1012314((int32_t)&g125);
}

// Address range: 0x100c357 - 0x100c37c
int32_t function_100c357(void) {
    // 0x100c357
    int32_t v1; // 0x100c357
    int32_t v2 = *(int32_t *)(*(int32_t *)(v1 + 71) + 8); // 0x100c35a
    int32_t v3; // 0x100c357
    char v4 = __asm_in_3((int16_t)v3); // 0x100c366
    unsigned char v5 = v4 - 125; // 0x100c36a
    int32_t v6 = (v1 + 0x8482900 | (int32_t)v4) & -256 | (int32_t)v5; // 0x100c36a
    char * v7 = (char *)v6; // 0x100c36d
    *v7 = *v7 | v5;
    int16_t v8; // bp-4, 0x100c357
    int32_t v9; // 0x100c357
    int32_t v10; // 0x100c357
    int32_t v11; // 0x100c357
    int32_t v12; // 0x100c357
    int32_t result = unknown_6cb27c50(v12, v9, v10, v11, &v8, v12, v3, v2, v6, v8); // 0x100c370
    char * v13 = (char *)result; // 0x100c37a
    *v13 = *v13 | (char)result;
    return result;
}

// Address range: 0x100c37c - 0x100c46f
int32_t function_100c37c(int32_t a1, int32_t a2) {
    // 0x100c37c
    bool v1; // 0x100c37c
    if (!v1) {
        function_100c357();
    }
    // 0x100c386
    abort();
    // UNREACHABLE
}

// Address range: 0x100c46f - 0x100c470
int32_t function_100c46f(int32_t a1, int32_t a2) {
    // 0x100c46f
    int32_t result; // 0x100c46f
    return result;
}

// Address range: 0x100c471 - 0x100c474
int32_t function_100c471(void) {
    // 0x100c471
    int32_t result; // 0x100c471
    return result;
}

// Address range: 0x100c474 - 0x100c486
int32_t function_100c474(int32_t a1) {
    // 0x100c474
    int32_t v1; // 0x100c474
    int32_t v2; // 0x100c474
    return function_100c37c(*(int32_t *)(v1 + 12 + 2 * v2), a1);
}

// Address range: 0x100c4b7 - 0x100c4e2
int32_t function_100c4b7(void) {
    // 0x100c4b7
    __asm_int3();
    int32_t v1 = function_10081cc(); // 0x100c4b8
    int32_t v2; // 0x100c4b7
    bool v3; // 0x100c4b7
    int32_t * v4 = (int32_t *)((v3 ? 0x3ad04588 : 0x3ad0458a) + v2); // 0x100c4c1
    *v4 = *v4 + 1 + (v1 & -256 | v2 & 255);
    int32_t v5; // 0x100c4b7
    int32_t * v6 = (int32_t *)(v5 + 0x4589ffd7); // 0x100c4c7
    int32_t v7; // 0x100c4b7
    *v6 = *v6 + v7;
    __asm_hlt();
    function_100dfef();
    int32_t v8 = __asm_int1(); // 0x100c4df
    int16_t v9 = v8; // 0x100c4e0
    uint32_t v10; // 0x100c4b7
    int16_t v11 = (int16_t)(v10 / 256) & 255; // 0x100c4e0
    return v8 & -0x10000 | (int32_t)(v9 / v11 & 255) | (int32_t)(256 * (v9 % v11));
}

// Address range: 0x100c4e3 - 0x100c4f4
int32_t function_100c4e3(void) {
    // 0x100c4e3
    int32_t v1; // 0x100c4e3
    return v1 - 12;
}

// Address range: 0x100c4f8 - 0x100c4f9
int32_t function_100c4f8(void) {
    // 0x100c4f8
    int32_t result; // 0x100c4f8
    return result;
}

// Address range: 0x100c504 - 0x100c50a
int32_t function_100c504(void) {
    // 0x100c504
    uint32_t v1; // 0x100c504
    int32_t result; // 0x100c504
    *(char *)result = (char)(result ^ v1 / 256);
    return result;
}

// Address range: 0x100c50b - 0x100c518
int32_t function_100c50b(void) {
    // 0x100c50b
    int32_t v1; // 0x100c50b
    int32_t * v2 = (int32_t *)(v1 + 0x7b89af45); // 0x100c50b
    int32_t v3 = *v2; // 0x100c50b
    *v2 = v3 - 1;
    if ((v3 & -v3) >= 0) {
        function_100c558();
    }
    // 0x100c513
    return __asm_hlt();
}

// Address range: 0x100c518 - 0x100c54e
int32_t function_100c518(int32_t a1) {
    int32_t v1 = __asm_fnsave(); // 0x100c51a
    int32_t v2; // 0x100c518
    *(int864_t *)(v2 + 0x4d8bffff) = (int864_t)v1;
    int32_t v3; // 0x100c518
    char * v4 = (char *)(v3 + 0x31458b1c); // 0x100c520
    *v4 = *v4 | -117;
    char * v5 = (char *)(v1 + 78); // 0x100c527
    char v6 = *v5 ^ (char)v3; // 0x100c527
    char v7 = llvm_ctpop_i8(v6); // 0x100c527
    *v5 = v6;
    int32_t v8 = v1; // 0x100c52a
    if ((v7 & 1) != 0) {
        v8 = function_100c4b7();
    }
    // 0x100c52c
    int32_t v9; // 0x100c518
    int32_t v10; // 0x100c518
    *(int32_t *)v9 = v9 - v10;
    char * v11 = (char *)v8; // 0x100c535
    *v11 = *v11 + (char)v8;
    int32_t v12; // 0x100c518
    int32_t * v13 = (int32_t *)(v12 - 0x37745a0d + v3); // 0x100c539
    *v13 = *v13 / 8;
    if (v3 == 1) {
        // 0x100c543
        __asm_rep_movsb_memcpy((char *)v9, (char *)v2, 0);
        return 1;
    }
    char v14 = __asm_in_1(112); // 0x100c548
    unsigned char v15 = v14 - 24; // 0x100c54a
    int32_t result = (v3 | (int32_t)v14) & -256 | (int32_t)v15; // 0x100c54c
    if (((v15 ^ v14) & v14 + 104) >= 0) {
        result = function_100c504();
    }
    // 0x100c54e
    return result;
}

// Address range: 0x100c558 - 0x100c5a6
int32_t function_100c558(void) {
    int32_t v1 = *(int32_t *)(__asm_hlt() + 4); // 0x100c55f
    int32_t v2; // 0x100c558
    if (v2 == 0) {
        v1 = function_100c4f8();
    }
    int32_t v3 = v1;
    uint32_t v4; // 0x100c558
    int32_t * v5 = (int32_t *)(v4 + 0x410bfc84); // 0x100c563
    *v5 = *v5 - 1;
    char * v6 = (char *)(v4 + 0x708bf445); // 0x100c569
    bool v7; // 0x100c558
    *v6 = (char)v7 + (char)v2 + *v6;
    int32_t v8; // 0x100c558
    int32_t v9 = v8 - 1; // 0x100c571
    int32_t v10 = v3 + 22 & 255 | v3 & -256; // 0x100c572
    int32_t v11; // 0x100c558
    int32_t v12 = __asm_insd((int16_t)v11 & 255 | -0x4900); // 0x100c580
    int32_t * v13 = (int32_t *)*(int32_t *)(v10 + 4); // 0x100c580
    *v13 = v12;
    unsigned char v14 = (char)v4; // 0x100c584
    *v13 = *(int32_t *)v9;
    int32_t * v15 = (int32_t *)(v4 - 0xcaffc1f); // 0x100c58b
    *v15 = v10 + (int32_t)(v14 > 72) + *v15;
    bool v16; // 0x100c558
    char v17 = *(char *)((v16 ? -4 : 4) + v9); // 0x100c591
    int32_t v18; // 0x100c558
    *(char *)*(int32_t *)(v18 - 114) = v17;
    __asm_hlt();
    int32_t v19 = 0x1000000 * v11 / 0x1000000; // 0x100c593
    unsigned char v20 = (char)v11 + v14; // 0x100c596
    int32_t result = v19 & -256 | (int32_t)v20; // 0x100c596
    if (v20 == 0) {
        // 0x100c59a
        return result;
    }
    int16_t v21 = result; // 0x100c5a2
    int16_t v22 = (int16_t)(v4 / 256) & 255; // 0x100c5a2
    return v19 & -0x10000 | (int32_t)(v21 / v22 & 255) | (int32_t)(256 * (v21 % v22));
}

// Address range: 0x100c5a9 - 0x100c5fa
int32_t function_100c5a9(void) {
    // 0x100c5a9
    int32_t v1; // 0x100c5a9
    bool v2; // 0x100c5a9
    int32_t v3 = (v2 ? -4 : 4) + v1; // 0x100c5a9
    __asm_hlt();
    function_100bc54();
    int32_t v4 = __asm_int1(); // 0x100c5b7
    float80_t v5; // 0x100c5a9
    *(float32_t *)(v3 + 0x75ffffff + 8 * v3) = (float32_t)v5;
    int32_t v6 = unknown_c8007bd1(v4); // 0x100c5c3
    unsigned char v7 = (char)v6; // 0x100c5c8
    int32_t v8; // 0x100c5a9
    int32_t v9; // 0x100c5a9
    if ((v9 & 15) == 15 || (v7 & 14) > 9) {
        v8 = (v7 > 153 ? 102 : 6) + v6 & 255 | v6 & -256;
    } else {
        v8 = (v7 > 153 ? v6 + 96 : v6) & 255 | v6 & -256;
    }
    char v10 = *(char *)(v8 - 24); // 0x100c5c9
    int32_t v11; // 0x100c5a9
    int32_t * v12 = (int32_t *)(v11 + 0x30ff5c45); // 0x100c5cf
    *v12 = *v12 - 1;
    int32_t v13 = *(int32_t *)(v9 - 3); // 0x100c5da
    *(int32_t *)v13 = v13;
    int32_t result = unknown_71007bfb(v3); // 0x100c5e6
    int32_t v14; // 0x100c5a9
    *(int32_t *)(result + 124) = v14 & -256 | (int32_t)(v10 & (char)v14);
    return result;
}

// Address range: 0x100c5fa - 0x100c62c
int32_t function_100c5fa(int32_t a1) {
    // 0x100c5fa
    int32_t v1; // 0x100c5fa
    int32_t v2 = v1 & 114 | 141; // 0x100c5fd
    int32_t v3 = v2 | v1 & -256; // 0x100c5ff
    char * v4 = (char *)v3; // 0x100c601
    *v4 = *v4 + (char)v2;
    int32_t v5; // 0x100c5fa
    __asm_rep_movsb_memcpy((char *)v5, (char *)a1, v3 / 4);
    int32_t v6; // 0x100c5fa
    function_1007bc1(*(int32_t *)(*(int32_t *)(v6 - 4) + 4));
    return *(int32_t *)(*(int32_t *)(v6 - 49) + 4);
}

// Address range: 0x100c62c - 0x100c675
int32_t function_100c62c(void) {
    // 0x100c62c
    int32_t v1; // 0x100c62c
    int32_t v2 = v1 & -256; // 0x100c62c
    int32_t v3; // 0x100c62c
    int32_t v4 = v3 | 0xff00; // 0x100c62f
    int32_t v5; // 0x100c62c
    int32_t v6; // 0x100c62c
    *(int32_t *)v6 = *(int32_t *)(v5 - 0x547603b3);
    int32_t v7 = v1 + 253; // 0x100c637
    int32_t v8 = *(int32_t *)((v7 & 255 | v2) + 4); // 0x100c63a
    int32_t v9; // 0x100c62c
    char v10 = *(char *)(v9 + 0x218bfc45); // 0x100c63f
    unsigned char v11 = (char)((char)v1 > 2) + (char)v3 - v10; // 0x100c63f
    char * v12 = (char *)(v6 + 12); // 0x100c647
    *v12 = (char)((char)v7 > 114) - v11 + *v12;
    int32_t v13 = v4 & -256 | v2 | (v1 + 138 | (int32_t)v11) + 254 & 255; // 0x100c64f
    __asm_rep_movsd_memcpy((char *)v5, (char *)v8, v13);
    *(int32_t *)(v6 - 6) = v4;
    bool v14; // 0x100c62c
    char * v15 = (char *)(v13 * (v14 ? -4 : 4) + v5); // 0x100c65b
    __asm_rep_movsb_memcpy(v15, v15, 0);
    int32_t v16 = function_10081cc(); // 0x100c65d
    *(int32_t *)(v6 - 10) = g90;
    int32_t result = v6 - 40; // 0x100c668
    *(int32_t *)result = v16;
    return result;
}

// Address range: 0x100c6c8 - 0x100c6cd
int32_t function_100c6c8(void) {
    // 0x100c6c8
    return function_8ca671cf();
}

// Address range: 0x100c6ef - 0x100c6f7
int32_t function_100c6ef(void) {
    // 0x100c6ef
    int32_t result; // 0x100c6ef
    return result;
}

// Address range: 0x100c70e - 0x100c716
int32_t function_100c70e(int32_t a1) {
    // 0x100c70e
    return function_8cc7baba();
}

// Address range: 0x100c716 - 0x100c781
int32_t function_100c716(int32_t a1) {
    // 0x100c716
    int32_t v1; // 0x100c716
    int32_t v2; // 0x100c716
    int32_t v3; // 0x100c716
    __asm_rep_movsb_memcpy((char *)v1, (char *)v2, v3);
    bool v4; // 0x100c716
    int32_t v5 = (v4 ? -1 : 1) * v3 + v1; // 0x100c71a
    int32_t v6; // 0x100c716
    function_100e2f5(v6 & -256 | a1 & 255, a1);
    int32_t v7; // 0x100c716
    int32_t v8 = function_1007c19(v7); // 0x100c72b
    int32_t v9; // bp-4, 0x100c716
    int32_t v10 = &v9; // 0x100c730
    bool v11; // 0x100c716
    int32_t v12 = v11 | (v8 & 14) > 9 ? v8 + 6 : v8; // 0x100c733
    int32_t v13; // 0x100c716
    __asm_out((int16_t)v13, (char)v12 & 15);
    *(int32_t *)0x30fffc8d = *(int32_t *)0x30fffc8d - 1;
    unknown_1800a3c1();
    char * v14 = (char *)*(int32_t *)(v10 - 17); // 0x100c745
    int32_t v15; // 0x100c716
    *v14 = *v14 ^ (char)v15;
    uint32_t v16 = *(int32_t *)(v10 - 99); // 0x100c754
    *(int32_t *)v16 = *(int32_t *)*(int32_t *)(v10 - 12);
    int32_t v17 = *(int32_t *)(v13 - 117); // 0x100c75c
    char * v18 = (char *)(v15 + 0x388bfc45); // 0x100c760
    *v18 = *v18 | -115;
    int32_t v19 = v17 & 114 | 141; // 0x100c767
    char * v20 = (char *)(v19 | v17 & -256); // 0x100c76b
    *v20 = *v20 + (char)v19;
    __asm_rep_movsd_memcpy((char *)v5, (char *)(v5 - 1), v16 / 512);
    return *(int32_t *)(v10 - 4);
}

// Address range: 0x100c781 - 0x100c7e5
int32_t function_100c781(void) {
    // 0x100c781
    function_10081c1();
    int32_t v1 = unknown_15003afb(); // 0x100c795
    int32_t v2; // 0x100c781
    int32_t v3 = *(int32_t *)(v2 - 4); // 0x100c79a
    *(int32_t *)(v3 + 4) = v1;
    int32_t v4 = *(int32_t *)(v2 + 12); // 0x100c7a0
    int32_t v5 = *(int32_t *)((v4 + 24 & 255 | v4 & -256) + 4); // 0x100c7ac
    int32_t v6; // 0x100c781
    char * v7 = (char *)(v6 + 0x2e9c1c1); // 0x100c7b4
    *v7 = *v7 + (char)v3;
    __asm_rep_movsd_memcpy((char *)v5, (char *)*(int32_t *)(v4 + 4), v3);
    function_10131b6(-0x6ff371fe);
    int32_t v8; // bp-12, 0x100c781
    int32_t v9; // 0x100c781
    unknown_7500bbd4(&v8, v9);
    return function_100dfef();
}

// Address range: 0x100c7e5 - 0x100caac
int32_t function_100c7e5(int32_t a1) {
    // 0x100c7e5
    int32_t v1; // 0x100c7e5
    int32_t v2; // 0x100c7e5
    *(char *)v1 = (char)(v2 ^ v1);
    int32_t v3; // 0x100c7e5
    float80_t v4; // 0x100c7e5
    *(float80_t *)(v3 + 0x75e9ffff) = __asm_fbstp(v4);
    int32_t v5; // 0x100c7e5
    *(int32_t *)(v5 - 44) = v2 + v5;
    while (true) {
        // continue -> 0x100c7f9
    }
}

// Address range: 0x100cad7 - 0x100cae6
int32_t function_100cad7(void) {
    // 0x100cad7
    int32_t v1; // 0x100cad7
    int32_t * v2 = (int32_t *)(v1 + 0x17cf0ec); // 0x100cad9
    *v2 = *v2 - 1;
    return function_2e016128();
}

// Address range: 0x100caf8 - 0x100cafd
int32_t function_100caf8(void) {
    // 0x100caf8
    return function_14a6bdff();
}

// Address range: 0x100cb54 - 0x100cb55
int32_t function_100cb54(int32_t a1, int32_t a2) {
    // 0x100cb54
    int32_t result; // 0x100cb54
    return result;
}

// Address range: 0x100cb64 - 0x100cb69
int32_t function_100cb64(void) {
    // 0x100cb64
    return function_fd455568();
}

// Address range: 0x100cba4 - 0x100cba9
int32_t function_100cba4(void) {
    // 0x100cba4
    return function_8ca6beab();
}

// Address range: 0x100cbee - 0x100cbf3
int32_t function_100cbee(void) {
    // 0x100cbee
    return function_8ca6bf3c();
}

// Address range: 0x100cc4a - 0x100cc55
int32_t function_100cc4a(void) {
    // 0x100cc4a
    int32_t v1; // 0x100cc4a
    char * v2 = (char *)(v1 - 0x173e7500); // 0x100cc4a
    uint32_t v3; // 0x100cc4a
    *v2 = *v2 + (char)(v3 / 256);
    return function_faa68357();
}

// Address range: 0x100cc82 - 0x100cc83
int32_t function_100cc82(void) {
    // 0x100cc82
    int32_t result; // 0x100cc82
    return result;
}

// Address range: 0x100cc99 - 0x100cc9e
int32_t function_100cc99(void) {
    // 0x100cc99
    return function_eda6bffb();
}

// Address range: 0x100ccd0 - 0x100ccd4
int32_t function_100ccd0(void) {
    // 0x100ccd0
    return function_100cc82();
}

// Address range: 0x100ccff - 0x100cd06
int32_t function_100ccff(void) {
    // 0x100ccff
    return function_8ca6c008();
}

// Address range: 0x100cd47 - 0x100cd4c
int32_t function_100cd47(void) {
    // 0x100cd47
    return function_58a6c05b();
}

// Address range: 0x100cdb9 - 0x100cdc0
int32_t function_100cdb9(void) {
    // 0x100cdb9
    return function_8ca6c0c2();
}

// Address range: 0x100cdd0 - 0x100cdd6
int32_t function_100cdd0(void) {
    // 0x100cdd0
    int32_t result; // 0x100cdd0
    return result;
}

// Address range: 0x100cdfb - 0x100d1c1
int32_t function_100cdfb(void) {
    // 0x100cdfb
    int32_t v1; // 0x100cdfb
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x100cdfb
    int32_t v3; // 0x100cdfb
    uint32_t v4 = (4 * v3 + 12) / 4; // 0x100ce07
    int32_t v5; // 0x100cdfb
    __asm_rep_movsd_memcpy((char *)v2, (char *)v5, v4);
    bool v6; // 0x100cdfb
    int32_t v7 = v2 + (v6 ? -4 : 4) * v4; // 0x100ce0a
    int32_t * v8 = (int32_t *)(v7 + 93); // 0x100ce0e
    *v8 = *v8 + 13;
    int32_t v9 = v7 + (v6 ? -1 : 1); // 0x100ce12
    int32_t v10; // 0x100cdfb
    int32_t v11 = *(int32_t *)(v10 - 8); // 0x100d1a1
    int32_t result = function_100bd61(v11); // 0x100d1a4
    *(int32_t *)(v9 - 4) = v11;
    if (result == 0) {
        // 0x100d1b4
        return function_45a9ffff(v10, v10 - 16);
    }
    // 0x100d194
    *(int32_t *)-0x6eb67408 = *(int32_t *)-0x6eb67408 | v9;
    return result;
}

// Address range: 0x100d1c1 - 0x100d1cd
int32_t function_100d1c1(void) {
    // 0x100d1c1
    int32_t v1; // 0x100d1c1
    g77 = v1;
    return function_1008a86();
}

// Address range: 0x100d1ce - 0x100d1f4
int32_t function_100d1ce(int32_t result, int32_t a2) {
    // 0x100d1ce
    __asm_in(93);
    unknown_afaac3c7();
    int32_t v1; // 0x100d1ce
    int32_t v2 = v1 & -0xff01; // 0x100d1df
    int32_t v3; // 0x100d1ce
    *(int32_t *)(v3 - 8) = v2;
    unknown_5d007bd1();
    *(int32_t *)(v3 - 12) = v2;
    return result;
}

// Address range: 0x100d1f4 - 0x100d1f9
int32_t function_100d1f4(void) {
    // 0x100d1f4
    int32_t result; // 0x100d1f4
    return result;
}

// Address range: 0x100d203 - 0x100d204
int32_t function_100d203(void) {
    // 0x100d203
    int32_t result; // 0x100d203
    return result;
}

// Address range: 0x100d208 - 0x100d242
int32_t function_100d208(void) {
    // 0x100d208
    bool v1; // 0x100d208
    if (!v1) {
        // 0x100d245
        int32_t result; // 0x100d208
        return result;
    }
    // 0x100d20f
    unknown_7e7ba9();
    int32_t v2; // 0x100d208
    char * v3 = (char *)(v2 + 0x53ffffa9); // 0x100d22a
    *v3 = *v3 & -119;
    function_1007bd1();
    return function_1007c26();
}

// Address range: 0x100d243 - 0x100d245
int32_t function_100d243(void) {
    // 0x100d243
    int32_t result; // 0x100d243
    return result;
}

// Address range: 0x100d272 - 0x100d277
int32_t function_100d272(void) {
    // 0x100d272
    return function_8ca6c579();
}

// Address range: 0x100d2a2 - 0x100d2bf
int32_t function_100d2a2(void) {
    // 0x100d2a2
    int32_t v1; // 0x100d2a2
    int32_t v2; // 0x100d2a2
    *(int32_t *)v1 = *(int32_t *)(v2 - 16) & v1;
    return function_d6e0c5c1();
}

// Address range: 0x100d2c8 - 0x100d2d4
int32_t function_100d2c8(int32_t a1, int32_t a2, int32_t a3) {
    // 0x100d2c8
    return unknown_1000cd1();
}

// Address range: 0x100d2f5 - 0x100d2f6
int32_t function_100d2f5(int32_t a1, int32_t a2) {
    // 0x100d2f5
    int32_t result; // 0x100d2f5
    return result;
}

// Address range: 0x100d37c - 0x100d381
int32_t function_100d37c(void) {
    // 0x100d37c
    return function_8ca6c683();
}

// Address range: 0x100d3c1 - 0x100d3ce
int32_t function_100d3c1(void) {
    // 0x100d3c1
    int32_t v1; // 0x100d3c1
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x100d3c1
    char * v3 = (char *)(v2 - 0x3e3e104e); // 0x100d3c3
    int32_t v4; // 0x100d3c1
    *v3 = *v3 + (char)v4;
    return function_d1a602d0();
}

// Address range: 0x100d403 - 0x100d410
int32_t function_100d403(void) {
    // 0x100d403
    int32_t v1; // 0x100d403
    char v2 = v1;
    int32_t v3; // 0x100d403
    *(char *)v1 = v2 + (char)v3;
    int32_t v4; // 0x100d403
    char * v5 = (char *)(v4 - 0x3e3e7408); // 0x100d405
    *v5 = *v5 + v2;
    return function_8ca64f12();
}

// Address range: 0x100d4a2 - 0x100d4aa
int32_t function_100d4a2(void) {
    // 0x100d4a2
    return function_100d4b1();
}

// Address range: 0x100d4aa - 0x100d4b1
int32_t function_100d4aa(void) {
    // 0x100d4aa
    int32_t result; // 0x100d4aa
    return result;
}

// Address range: 0x100d4b1 - 0x100d594
int32_t function_100d4b1(void) {
    // 0x100d4b1
    int32_t v1; // 0x100d4b1
    int32_t v2; // 0x100d4b1
    int32_t v3; // 0x100d4b1
    int32_t v4 = *(int32_t *)(8 * v1 - 92 + v3) + v2; // 0x100d4b8
    int32_t v5 = *(int32_t *)(v4 - 8); // 0x100d4c1
    int32_t v6 = v5; // bp-4, 0x100d4c1
    int32_t v7 = function_100bd61(v5); // 0x100d4c4
    int32_t v8 = v7; // 0x100d4cb
    int32_t v9 = &v6; // 0x100d4cb
    int32_t v10; // 0x100d4b1
    int32_t v11; // 0x100d4b1
    int32_t v12; // 0x100d4b1
    bool v13; // 0x100d4b1
    if (v7 == 0) {
        int32_t v14 = *(int32_t *)(v4 - 64); // 0x100d4cd
        uint32_t v15 = *(int32_t *)v14; // 0x100d4d3
        uint32_t v16 = v15 / 256; // 0x100d4d7
        *(char *)v3 = (char)(v16 | v3);
        *(char *)v10 = *(char *)&v10 | (char)v16;
        uint32_t v17 = *(int32_t *)(v14 + 4) & -256 | (int32_t)__asm_in_1(1); // 0x100d4e0
        uint32_t v18; // 0x100d4b1
        v9 = *(int32_t *)(v18 + 0xfd8f704);
        int32_t v19 = (v13 ? -4 : 4) + v18; // 0x100d4e9
        int32_t v20; // 0x100d4b1
        *(char *)v19 = __asm_insb((int16_t)v20);
        v11 = v15;
        v8 = v17 + 0x40014f40 + (int32_t)(v17 < v18);
        v12 = v19;
    }
    int32_t v21 = *(int32_t *)v8 * *(int32_t *)v11; // 0x100d4fc
    int32_t v22 = v9; // 0x100d502
    int32_t result; // 0x100d4b1
    int32_t v23; // 0x100d4b1
    char v24; // 0x100d4b1
    if (v21 != -1) {
        goto lab_0x100d55f;
    } else {
        // 0x100d504
        *(int32_t *)(v9 - 4) = -0xbfed550;
        int32_t v25 = v12 + 0x45c7ff07; // 0x100d509
        char * v26 = (char *)v21; // 0x100d50f
        *v26 = *v26 | (char)v8;
        *(int32_t *)(v9 - 8) = v21;
        unsigned char v27 = *(char *)v25; // 0x100d517
        int32_t v28 = (int32_t)v27 | 0x57e88000; // 0x100d517
        char * v29 = (char *)(v10 + 0x14f353d); // 0x100d518
        *v29 = *v29 + v27;
        int32_t v30 = v9 - 12; // 0x100d51e
        *(int32_t *)v30 = 19;
        int32_t v31 = *(int32_t *)(v28 + 76); // 0x100d52f
        int32_t v32 = *(int32_t *)0x1034f5c; // 0x100d532
        int32_t v33 = *(int32_t *)(*(int32_t *)(v10 - 0xef1b5fc) + 4); // 0x100d537
        int32_t v34 = v25 + (v13 ? -1 : 1) - *(int32_t *)(v28 + 8) - v31 + v33; // 0x100d537
        int32_t * v35 = (int32_t *)v10; // 0x100d541
        *v35 = v32 + v10;
        char v36 = *(char *)v34; // 0x100d543
        char v37 = *(char *)*(int32_t *)(v4 + 0x4f4035af + 2 * v34); // 0x100d543
        result = v32;
        v23 = v30;
        v24 = llvm_ctpop_i8(v36 - v37);
        if (v36 > v37) {
            // 0x100d549
            *(int32_t *)(v9 - 16) = v10;
            int32_t v38 = v4 - 4; // 0x100d54a
            *(int32_t *)(v9 - 20) = v38;
            v22 = v9 - 24;
            *v35 = v10 + v38;
            *(int32_t *)v22 = v10;
            function_100be29((int32_t)&g125);
            goto lab_0x100d55f;
        } else {
            goto lab_0x100d575;
        }
    }
  lab_0x100d55f:
    // 0x100d55f
    *(int32_t *)(v22 - 4) = (int32_t)g87;
    int32_t v39 = v22 - 8; // 0x100d565
    *(int32_t *)v39 = v10;
    char v40 = llvm_ctpop_i8((char)function_1008d44()); // 0x100d56c
    __asm_in_1(-87);
    result = g77;
    v23 = v39;
    v24 = v40;
    goto lab_0x100d575;
  lab_0x100d575:
    // 0x100d575
    *(int32_t *)(v23 - 4) = v10;
    if ((v24 & 1) != 0) {
        // 0x100d582
        *(int32_t *)-0x3ba285d5 = -1 - *(int32_t *)-0x3ba285d5;
    }
    // 0x100d58a
    return result;
}

// Address range: 0x100d5e0 - 0x100d5e5
int32_t function_100d5e0(void) {
    // 0x100d5e0
    return function_8ca6c8e7();
}

// Address range: 0x100d5eb - 0x100d609
int32_t function_100d5eb(int32_t a1) {
    // 0x100d5eb
    bool v1; // 0x100d5eb
    int32_t v2 = v1 ? -4 : 4; // 0x100d5f2
    int32_t v3; // 0x100d5eb
    int32_t v4 = v2 + v3; // 0x100d5f2
    int32_t v5; // 0x100d5eb
    int32_t v6 = *(int32_t *)(v5 + 0x360464ee + v2); // 0x100d5f5
    int32_t v7 = (int32_t)g87; // 0x100d5fb
    *(int32_t *)v4 = *(int32_t *)v6;
    int32_t result = v7 + 1 & -256 | v7 & 255; // 0x100d602
    int32_t v8; // 0x100d5eb
    int32_t * v9 = (int32_t *)(8 * v8 - 8 + result); // 0x100d604
    uint32_t v10 = *v9; // 0x100d604
    *v9 = v10 / 0x10000 | 0x10000 * v10;
    *(int32_t *)(v4 + 4) = *(int32_t *)(v6 + 4);
    return result;
}

// Address range: 0x100d62a - 0x100d62f
int32_t function_100d62a(void) {
    // 0x100d62a
    return function_8cb3c9b1();
}

// Address range: 0x100d642 - 0x100d645
int32_t function_100d642(int32_t a1) {
    // 0x100d642
    int32_t result; // 0x100d642
    return result;
}

// Address range: 0x100d64b - 0x100d653
int32_t function_100d64b(void) {
    // 0x100d64b
    int32_t v1; // 0x100d64b
    int32_t v2; // 0x100d64b
    *(char *)(v1 + 1) = (char)v2;
    int32_t v3; // 0x100d64b
    int32_t * v4 = (int32_t *)(v3 - 24); // 0x100d64e
    int32_t v5; // 0x100d64b
    *v4 = *v4 + v5;
    int32_t result; // 0x100d64b
    return result;
}

// Address range: 0x100d670 - 0x100d674
int32_t function_100d670(void) {
    // 0x100d670
    int32_t result; // 0x100d670
    return result;
}

// Address range: 0x100d682 - 0x100d70a
int32_t function_100d682(void) {
    // 0x100d682
    int32_t v1; // 0x100d682
    if (v1 == 1) {
        // 0x100d684
        int32_t result; // 0x100d682
        return result;
    }
    int32_t result2 = function_100bc54(); // 0x100d686
    int32_t v2; // 0x100d682
    *(char *)v2 = (char)result2;
    bool v3; // 0x100d682
    if (v3) {
        // 0x100d684
        return result2;
    }
    char * v4 = (char *)result2; // 0x100d704
    *v4 = *v4 - (char)(result2 / 256);
    int32_t result3 = result2 + 212 & 255 | result2 & -256; // 0x100d706
    int32_t v5; // 0x100d682
    __asm_out_2((int16_t)v5, result3);
    int32_t v6; // 0x100d682
    bool v7; // 0x100d682
    *(char *)((v7 ? -1 : 1) + v2) = *(char *)&v6;
    return result3;
}

// Address range: 0x100d70b - 0x100d734
int32_t function_100d70b(void) {
    // 0x100d70b
    int32_t v1; // 0x100d70b
    int32_t v2 = v1 + 22; // 0x100d719
    int32_t result = v2 & 255 | v1 & -256; // 0x100d719
    char * v3 = (char *)result; // 0x100d724
    *v3 = *v3 + (char)v2;
    int32_t v4; // 0x100d70b
    int32_t v5; // 0x100d70b
    int32_t v6; // 0x100d70b
    *(char *)v4 = *(char *)(v5 - 1 + v6);
    return result;
}

// Address range: 0x100d734 - 0x100d73e
int32_t function_100d734(void) {
    // 0x100d734
    int32_t result; // 0x100d734
    return result;
}

// Address range: 0x100d799 - 0x100d79e
int32_t function_100d799(void) {
    // 0x100d799
    return function_8c88cada();
}

// Address range: 0x100d7e1 - 0x100d7e6
int32_t function_100d7e1(void) {
    // 0x100d7e1
    return function_30a6cae8();
}

// Address range: 0x100d7ef - 0x100d7f1
int32_t function_100d7ef(void) {
    // 0x100d7ef
    return function_100d856();
}

// Address range: 0x100d80c - 0x100d80f
int32_t function_100d80c(void) {
    // 0x100d80c
    int32_t result; // 0x100d80c
    return result;
}

// Address range: 0x100d830 - 0x100d832
int32_t function_100d830(void) {
    // 0x100d830
    return function_100d885((int32_t)&g125);
}

// Address range: 0x100d856 - 0x100d87f
int32_t function_100d856(void) {
    // 0x100d856
    int32_t v1; // 0x100d856
    int32_t v2 = *(int32_t *)(v1 - 12); // 0x100d860
    int32_t * v3 = (int32_t *)v2; // 0x100d863
    *v3 = *v3 - v2;
    int32_t v4 = __asm_hlt(); // 0x100d874
    return v4 + 139 & 255 | v4 & -256;
}

// Address range: 0x100d885 - 0x100d9b6
int32_t function_100d885(int32_t a1) {
    // 0x100d885
    int32_t v1; // 0x100d885
    char * v2 = (char *)(v1 - 0x27161e3f); // 0x100d885
    int32_t v3; // 0x100d885
    *v2 = *v2 + (char)v3;
    int32_t v4; // 0x100d885
    int32_t v5; // 0x100d885
    __asm_rep_movsd_memcpy((char *)v4, (char *)v5, v3);
    *(int32_t *)-0x745b0cfd = *(int32_t *)-0x745b0cfd - 69;
    int32_t v6; // 0x100d885
    uint32_t v7; // 0x100d885
    *(char *)v6 = *(char *)&v6 ^ (char)(v7 / 256);
    *(int32_t *)0x2283fc45 = *(int32_t *)0x2283fc45 - 1;
    int32_t v8; // 0x100d885
    int32_t * v9 = (int32_t *)(*(int32_t *)(v8 - 12) - 24); // 0x100d914
    int32_t v10 = v6 + *v9; // 0x100d914
    *v9 = v10;
    if (v10 != 0) {
        // 0x100d919
        bool v11; // 0x100d885
        char * v12 = (char *)(v4 + 70 + (v11 ? -4 : 4) * v3); // 0x100d919
        *v12 = *v12 + (char)(v6 / 256);
        int32_t * v13 = (int32_t *)(v8 + 34); // 0x100d91e
        *v13 = 8 * *v13;
        unknown_1802314(*(int32_t *)(v7 + 58));
        int16_t v14; // 0x100d885
        unknown_e850f495(v14, *(int32_t *)(v8 - 2));
        unsigned char v15 = *(char *)-0x74cc8ac8; // 0x100d93f
        *(char *)-0x74cc8ac8 = v15 / 128 | 2 * v15;
        v6 = *(int32_t *)(*(int32_t *)3 + 8);
    }
    // 0x100d95a
    abort();
    // UNREACHABLE
}

// Address range: 0x100d9b6 - 0x100da91
int32_t function_100d9b6(void) {
    // 0x100d9b6
    int32_t v1; // 0x100d9b6
    int32_t * v2 = (int32_t *)(v1 - 4);
    int32_t * v3 = (int32_t *)(v1 + 0x647b0fc0); // 0x100d9d5
    int32_t v4 = 46; // 0x100d9b7
    int32_t v5; // bp-4, 0x100d9b6
    int32_t v6 = &v5; // 0x100d9b7
    int32_t v7; // 0x100d9b6
    char * v8 = (char *)(v7 + 56);
    int32_t v9; // 0x100d9b6
    *(int32_t *)(v6 - 4) = v9;
    *(int32_t *)(v6 - 8) = v9;
    int32_t v10; // 0x100d9b6
    *(int32_t *)(v6 - 12) = v10;
    *v8 = *v8 | (char)v4;
    *(int32_t *)(v6 - 16) = *(int32_t *)-0x2648b010;
    *(int32_t *)(v6 - 20) = *(int32_t *)v10;
    *v2 = 0;
    *(int32_t *)(v1 - 52) = 0;
    int32_t v11; // 0x100d9b6
    int32_t v12; // 0x100d9b6
    *(int32_t *)v12 = v11 & -256;
    int32_t v13 = v10 | 255; // 0x100d9d3
    *v3 = *v3 + 1;
    int32_t v14 = v4 | 0xff00; // 0x100d9dd
    *(int32_t *)(v6 - 24) = *(int32_t *)v13;
    int32_t v15 = v13 + 1; // 0x100d9e6
    __asm_out((int16_t)v14, (char)&g112);
    function_1007bd1();
    *v2 = 0;
    *v2 = unknown_9cb17c26();
    *(int32_t *)*(int32_t *)0x458bffff = 0;
    *(int32_t *)-0x38a0078 = *(int32_t *)(*(int32_t *)g101 + 4);
    int32_t v16 = unknown_84007bca(); // 0x100da1c
    int32_t v17 = *(int32_t *)(v1 + 16); // 0x100da21
    *(int32_t *)v17 = v16;
    int32_t * v18 = (int32_t *)(v13 - 116); // 0x100da29
    int32_t v19 = *v18 + v15; // 0x100da29
    *v18 = v19;
    int32_t v20 = v17 - 1; // 0x100da2c
    v4 = v14 + 1;
    v6 = -0x38a0078;
    bool v21; // 0x100d9b6
    v12 += (v21 ? -5 : 3);
    while (v20 != 0 == v19 == 0) {
        // 0x100d9b9
        v8 = (char *)56;
        *(int32_t *)(v6 - 4) = v20;
        *(int32_t *)(v6 - 8) = v20;
        *(int32_t *)(v6 - 12) = v15;
        *v8 = *v8 | (char)v4;
        *(int32_t *)(v6 - 16) = *(int32_t *)-0x2648b010;
        *(int32_t *)(v6 - 20) = *(int32_t *)v15;
        *v2 = 0;
        *(int32_t *)(v1 - 52) = 0;
        *(int32_t *)v12 = v16 & -256 & -256;
        v13 = v15 | 255;
        *v3 = *v3 + 1;
        v14 = v4 | 0xff00;
        *(int32_t *)(v6 - 24) = *(int32_t *)v13;
        v15 = v13 + 1;
        __asm_out((int16_t)v14, (char)&g112);
        function_1007bd1();
        *v2 = 0;
        *v2 = unknown_9cb17c26();
        *(int32_t *)*(int32_t *)0x458bffff = 0;
        *(int32_t *)-0x38a0078 = *(int32_t *)(*(int32_t *)g101 + 4);
        v16 = unknown_84007bca();
        v17 = *(int32_t *)(v1 + 16);
        *(int32_t *)v17 = v16;
        v18 = (int32_t *)(v13 - 116);
        v19 = *v18 + v15;
        *v18 = v19;
        v20 = v17 - 1;
        v4 = v14 + 1;
        v6 = -0x38a0078;
        v12 += 3;
    }
    int32_t result = __asm_int3(); // 0x100da31
    int32_t v22 = *(int32_t *)result; // 0x100da33
    *(int32_t *)v22 = *(int32_t *)-1;
    int32_t v23 = (*(int32_t *)-0x38a0078 & 1024) == 0 ? 4 : -4; // 0x100da42
    __asm_rep_movsb_memcpy((char *)(v23 + v22), (char *)(v23 - 1), result & 83);
    int32_t v24 = *v2; // 0x100da4a
    if ((v24 + 1 & (v24 ^ -0x80000000)) >= 0) {
        // 0x100da50
        return result;
    }
    // 0x100da54
    *(int32_t *)0x6083fc50 = *(int32_t *)0x6083fc50 - 1;
    char v25 = result;
    unsigned char v26 = v25 + 31; // 0x100da63
    if (((v26 ^ v25 + 32) & -32 - v25) < 0) {
        // 0x100da50
        return 1;
    }
    // 0x100da67
    return result & -256 | (int32_t)v26;
}

// Address range: 0x100daad - 0x100daf3
int32_t function_100daad(void) {
    // 0x100daad
    *(int32_t *)*(int32_t *)-0x7400005f = 0;
    int32_t result; // 0x100daad
    return result;
}

// Address range: 0x100daf3 - 0x100db04
int32_t function_100daf3(void) {
    int32_t v1 = __asm_in(255); // 0x100daf3
    int32_t v2; // 0x100daf3
    int32_t * v3 = (int32_t *)(v2 + 0x6083f845); // 0x100daf5
    *v3 = *v3 - 1;
    int32_t * v4 = (int32_t *)v1; // 0x100dafb
    *v4 = *v4 & v1;
    return *(int32_t *)(v2 + 66);
}

// Address range: 0x100db28 - 0x100db2d
int32_t function_100db28(void) {
    // 0x100db28
    return unknown_a6ce2f();
}

// Address range: 0x100db3b - 0x100db3e
int32_t function_100db3b(void) {
    // 0x100db3b
    int32_t result; // 0x100db3b
    return result;
}

// Address range: 0x100db57 - 0x100db5e
int32_t function_100db57(int32_t a1) {
    // 0x100db57
    *(int32_t *)0x101f3ec = *(int32_t *)0x101f3ec + 1;
    int32_t result; // 0x100db57
    return result;
}

// Address range: 0x100db5f - 0x100dc18
int32_t function_100db5f(void) {
    int32_t v1 = unknown_c68cf0(); // 0x100db5f
    int32_t v2; // 0x100db5f
    int32_t v3; // 0x100db5f
    char v4 = *(char *)(v3 - 0x1000000 + 4 * v2); // 0x100db66
    int32_t v5 = (v1 & -256 | (int32_t)((char)v1 - v4)) ^ 0x1364fe8; // 0x100db6d
    uint32_t v6; // 0x100db5f
    int32_t v7 = v6 | 255; // 0x100db76
    char * v8 = (char *)(v2 - 0x687bf040); // 0x100db78
    *v8 = (char)v5;
    int32_t v9 = v5 & -256; // 0x100db78
    int32_t v10; // 0x100db5f
    int32_t v11 = v10 - 1; // 0x100db84
    char * v12 = (char *)((v9 | (int32_t)*(char *)0x238311ff) - 106); // 0x100db8a
    int32_t v13; // 0x100db5f
    *v12 = *v12 + (char)v13;
    int16_t v14; // bp-8, 0x100db5f
    function_1007bc1((int32_t)v14);
    int32_t * v15 = (int32_t *)*(int32_t *)v7; // 0x100db9b
    *v15 = *v15 & -24;
    uint32_t v16 = __asm_hlt(); // 0x100dba1
    uint32_t v17 = v6 / 256; // 0x100dba2
    if ((char)(2 * v17 ^ v17) >= 0) {
        char * v18 = (char *)(v16 + 0x783dffff); // 0x100dba7
        *v18 = *v18 & (char)(v16 / 256);
        *(int32_t *)v11 = v16;
        int32_t v19 = *(int32_t *)(((v9 | (int32_t)(2 * *v8)) ^ v2) + 1); // 0x100dbaf
        int32_t v20 = v19 + 139; // 0x100dbb6
        char * v21 = (char *)(v20 & 255 | v19 & -256); // 0x100dbc0
        *v21 = *v21 + (char)v20;
        __asm_in_5((int16_t)v13);
        return function_8cedcfc1();
    }
    char * v22 = (char *)v16; // 0x100dc05
    *v22 = *v22 + (char)v16;
    char * v23 = (char *)((512 * v17 & 0xfe00 | v7 & -0xff01) + 0x2d1c1c1); // 0x100dc07
    *v23 = *v23 + (char)v11;
    int32_t v24; // 0x100db5f
    __asm_rep_movsd_memcpy((char *)v24, (char *)&v14, v11);
    bool v25; // 0x100db5f
    int32_t v26 = (v25 ? -4 : 4) * v11 + v24; // 0x100dc0d
    int32_t * v27 = (int32_t *)v26; // 0x100dc11
    *v27 = *v27 & 3;
    char * v28 = (char *)v26; // 0x100dc14
    __asm_rep_movsb_memcpy(v28, v28, v16);
    return function_100dc27();
}

// Address range: 0x100dc20 - 0x100dc27
int32_t function_100dc20(void) {
    // 0x100dc20
    int32_t v1; // 0x100dc20
    return function_1009ad4(v1);
}

// Address range: 0x100dc27 - 0x100dc39
int32_t function_100dc27(void) {
    // 0x100dc27
    bool v1; // 0x100dc27
    while (!v1) {
        // continue -> 0x100dc2a
    }
    // 0x100dc32
    int32_t v2; // 0x100dc27
    unsigned char v3 = (char)v2;
    *(char *)-97 = v3;
    uint32_t v4; // 0x100dc27
    char v5 = v4 / 256; // 0x100dc35
    char v6 = v5 + v3; // 0x100dc35
    int32_t v7; // 0x100dc27
    return v7 & -0xff01 | 256 * (64 * (int32_t)(v6 == 0) | (int32_t)(v6 < v3) | 128 * (int32_t)(v6 < 0) | 16 * (int32_t)((v5 & 15) + (v3 & 15) > 15) | 4 * (int32_t)((llvm_ctpop_i8(v6) & 1) == 0)) | 512;
}

// Address range: 0x100dc3a - 0x100dc42
int32_t function_100dc3a(int32_t a1) {
    // 0x100dc3a
    int32_t result; // 0x100dc3a
    return result;
}

// Address range: 0x100dc53 - 0x100dc59
int32_t function_100dc53(int32_t a1) {
    // 0x100dc53
    int32_t v1; // 0x100dc53
    int32_t v2; // 0x100dc53
    bool v3; // 0x100dc53
    *(int32_t *)v1 = v1 - v2 + (int32_t)v3;
    int32_t result; // 0x100dc53
    return result;
}

// Address range: 0x100dc65 - 0x100dc68
int32_t function_100dc65(void) {
    // 0x100dc65
    int32_t result; // 0x100dc65
    return result;
}

// Address range: 0x100dc8b - 0x100dcbb
int32_t function_100dc8b(int32_t a1) {
    // 0x100dc8b
    int32_t v1; // 0x100dc8b
    char * v2 = (char *)(v1 - 0x746f7403); // 0x100dc8c
    *v2 = *v2 | (char)v1;
    uint32_t v3; // 0x100dc8b
    uint32_t v4 = v3 / 256; // 0x100dc92
    if ((char)(2 * v4 ^ v4) >= 0) {
        // 0x100dc96
        int32_t result; // 0x100dc8b
        return result;
    }
    int32_t * v5 = (int32_t *)((512 * v4 & 0xfe00 | v3 & -0xff01) + 0x189f44d); // 0x100dc9a
    *v5 = *v5 - 1;
    return function_8ca6b7bd(v1);
}

// Address range: 0x100dcfe - 0x100dd03
int32_t function_100dcfe(void) {
    // 0x100dcfe
    return function_8ca6d005();
}

// Address range: 0x100dd8d - 0x100dd97
int32_t function_100dd8d(int32_t a1) {
    // 0x100dd8d
    int32_t v1; // 0x100dd8d
    int32_t * v2 = (int32_t *)(v1 - 0x74cf74fd); // 0x100dd8d
    int32_t v3; // 0x100dd8d
    *v2 = *v2 + v3;
    int32_t result; // 0x100dd8d
    return result;
}

// Address range: 0x100dda4 - 0x100dda9
int32_t function_100dda4(void) {
    // 0x100dda4
    return function_8ca70aab();
}

// Address range: 0x100ddaa - 0x100ddad
int32_t function_100ddaa(void) {
    // 0x100ddaa
    int32_t result; // 0x100ddaa
    return result;
}

// Address range: 0x100dde1 - 0x100ddfb
int32_t function_100dde1(void) {
    // 0x100dde1
    int32_t v1; // 0x100dde1
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x100dde3
    uint32_t v3 = *v2; // 0x100dde3
    *v2 = v3 / 2048 | 0x200000 * v3;
    return function_5affa4f3();
}

// Address range: 0x100de3f - 0x100de44
int32_t function_100de3f(void) {
    // 0x100de3f
    return function_8cded146();
}

// Address range: 0x100de87 - 0x100de8c
int32_t function_100de87(void) {
    // 0x100de87
    return function_8ca6d238();
}

// Address range: 0x100dec7 - 0x100ded0
int32_t function_100dec7(void) {
    // 0x100dec7
    int32_t v1; // 0x100dec7
    bool v2; // 0x100dec7
    bool v3; // 0x100dec7
    bool v4; // 0x100dec7
    if (v3 == v2 == !v4) {
        v1 = function_100dede();
    }
    // 0x100dec9
    int32_t v5; // 0x100dec7
    *(int32_t *)(v5 + 12) = v1 + 1;
    int16_t v6; // 0x100dec7
    return function_100dee4(v6);
}

// Address range: 0x100ded4 - 0x100dedb
int32_t function_100ded4(int32_t * a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t result) {
    // 0x100ded4
    return result;
}

// Address range: 0x100dede - 0x100dee4
int32_t function_100dede(void) {
    // 0x100dede
    int32_t v1; // 0x100dede
    return unknown_88011a3c(v1);
}

// Address range: 0x100dee4 - 0x100df72
int32_t function_100dee4(int16_t a1) {
    // 0x100dee4
    int32_t v1; // 0x100dee4
    int32_t v2 = *(int32_t *)(v1 - 4); // 0x100dee4
    int32_t v3 = *(int32_t *)(v1 - 94); // 0x100dee7
    int32_t * v4 = (int32_t *)v2; // 0x100deea
    bool v5; // 0x100dee4
    *v4 = *v4 - (v5 ? 5 : 4);
    int32_t * v6 = (int32_t *)(2 * v2); // 0x100deef
    *v6 = *v6 & v2;
    int32_t result = unknown_87003a54(v1 - 8, *(int32_t *)(v1 + 100), v2, v3); // 0x100df06
    int32_t v7; // 0x100dee4
    if (g78 != 0) {
        // 0x100df6c
        __asm_into(v7);
        return result;
    }
    int32_t v8 = *(int32_t *)-0x74feb0a4; // 0x100df0c
    int32_t v9 = v8 >> 31; // 0x100df11
    int32_t * v10 = (int32_t *)(v9 - 117); // 0x100df16
    int32_t v11; // 0x100dee4
    *v10 = *v10 + v11;
    int32_t * v12 = (int32_t *)(v8 + 2 + v9); // 0x100df28
    int32_t v13; // 0x100dee4
    *v12 = *v12 + v13;
    *(char *)-0x6d74259c = (char)v11;
    int64_t v14 = (int64_t)*(int32_t *)v11; // 0x100df44
    int64_t v15 = -58 * v14; // 0x100df44
    int32_t v16 = v15; // 0x100df44
    if (v15 == -0x3a00000000 * v14 / 0x100000000) {
        int32_t v17 = (v16 & 14) > 9 ? v16 + 6 : v16; // 0x100df4c
        return v17 & 14 | v16 & -0x10000 | 256 * (int32_t)((v16 & 14) > 9) + v16 & 0xff00;
    }
    int32_t v18 = *(int32_t *)(-103 * *(int32_t *)(v11 - 0x169fd40f) - v13 + v16); // 0x100df47
    int32_t result2 = __asm_hlt(); // 0x100df56
    unsigned char v19 = *(char *)-0x287d993a + (char)v18; // 0x100df5c
    *(char *)0x5201c664 = *(char *)0x5201c664 | v19;
    int32_t * v20 = (int32_t *)(result2 - 49); // 0x100df69
    *v20 = *v20 - (v18 & -256 | (int32_t)v19);
    // 0x100df6c
    __asm_into(v7);
    return result2;
}

// Address range: 0x100df72 - 0x100dfd2
int32_t function_100df72(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x100df72
    int32_t v1; // 0x100df72
    *(char *)-0x7affffc6 = (char)v1;
    int32_t v2; // 0x100df72
    char * v3 = (char *)(v2 + 52); // 0x100df77
    *v3 = 2 * *v3;
    int32_t * v4 = (int32_t *)(a6 + 15); // 0x100dfa5
    *v4 = *v4 + a6;
    unknown_52007d7d(*(int32_t *)a4);
    *(int32_t *)(a3 - 16) = 0;
    int32_t result = function_1007c2f(*(int32_t *)(a3 + 16)); // 0x100dfbe
    *(int32_t *)(result - 0x63fc170c) = a5;
    return result;
}

// Address range: 0x100dfd2 - 0x100dfef
int32_t function_100dfd2(int32_t a1, int32_t a2) {
    // 0x100dfd2
    function_100ab09(function_1007bd1() & -216);
    int32_t v1; // 0x100dfd2
    int32_t result = *(int32_t *)(v1 - 8); // 0x100dfe3
    int32_t v2; // 0x100dfd2
    *(int32_t *)v2 = v2 - result;
    return result;
}

// Address range: 0x100dfef - 0x100e00c
int32_t function_100dfef(void) {
    // 0x100dfef
    int32_t v1; // 0x100dfef
    int32_t v2; // 0x100dfef
    char * v3 = (char *)(*(int32_t *)(v2 + 0x7d8933ff) ^ v1); // 0x100e009
    *v3 = *v3 - (char)v2;
    int32_t result; // 0x100dfef
    return result;
}

// Address range: 0x100e053 - 0x100e056
int32_t function_100e053(int32_t a1) {
    // 0x100e053
    int32_t result; // 0x100e053
    return result;
}

// Address range: 0x100e08a - 0x100e0ff
int32_t function_100e08a(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x100e08a
    int32_t v1; // 0x100e08a
    int32_t v2; // 0x100e08a
    *(char *)v1 = (char)v2 + (char)v1;
    __asm_int1();
    int32_t v3 = a2 - 1; // 0x100e0ae
    int32_t * v4 = (int32_t *)(*(int32_t *)*(int32_t *)a4 + 46); // 0x100e0cd
    *v4 = *v4 - v3;
    char * v5 = (char *)(a4 - 0x748374f5); // 0x100e0d9
    char v6 = (char)((*(int32_t *)(a1 + 4) - v3) / 4); // 0x100e0d9
    *v5 = *v5 | v6;
    char * v7 = (char *)(a4 - 0x3ec4f7b7); // 0x100e0e3
    *v7 = *v7 | v6 - 1;
    *(int32_t *)(8 * a4 + v3) = a3;
    return *(int32_t *)0x4408b03 - 1;
}

// Address range: 0x100e0ff - 0x100e115
int32_t function_100e0ff(void) {
    // 0x100e0ff
    function_1007bd1();
    int32_t result = function_1007c26(); // 0x100e10a
    int32_t v1; // 0x100e0ff
    *(int32_t *)(v1 + 71) = result;
    return result;
}

// Address range: 0x100e127 - 0x100e12c
int32_t function_100e127(int32_t a1) {
    // 0x100e127
    int32_t v1; // 0x100e127
    return v1 + 130 & 255 | v1 & -256;
}

// Address range: 0x100e14b - 0x100e150
int32_t function_100e14b(void) {
    // 0x100e14b
    return function_8cabd452();
}

// Address range: 0x100e199 - 0x100e19e
int32_t function_100e199(void) {
    // 0x100e199
    return function_98a6d4a0();
}

// Address range: 0x100e1e7 - 0x100e1f7
int32_t function_100e1e7(void) {
    // 0x100e1e7
    int32_t v1; // 0x100e1e7
    *(char *)v1 = 2 * (char)v1;
    __asm_int1();
    return function_8ca6d4f9();
}

// Address range: 0x100e240 - 0x100e245
int32_t function_100e240(void) {
    // 0x100e240
    return function_8ca6d547();
}

// Address range: 0x100e24d - 0x100e25b
int32_t function_100e24d(void) {
    // 0x100e24d
    function_1008d44();
    return function_100e28c();
}

// Address range: 0x100e280 - 0x100e28c
int32_t function_100e280(void) {
    // 0x100e280
    int32_t v1; // 0x100e280
    int32_t * v2 = (int32_t *)(v1 + 50); // 0x100e284
    int32_t v3; // 0x100e280
    *v2 = *v2 + v3;
    return unknown_ffe944();
}

// Address range: 0x100e28c - 0x100e2b5
int32_t function_100e28c(void) {
    // 0x100e28c
    __asm_hlt();
    int32_t v1; // 0x100e28c
    unknown_82dc58(v1);
    int32_t v2; // 0x100e28c
    int32_t v3 = v2 - 8; // 0x100e29c
    unknown_4600bd50(v3, g90);
    return function_100cb54(v2 + 7, *(int32_t *)v3);
}

// Address range: 0x100e2b5 - 0x100e2d2
int32_t function_100e2b5(void) {
    // 0x100e2b5
    function_100bc54();
    int32_t result; // 0x100e2b5
    unknown_e100ab09(result);
    return result;
}

// Address range: 0x100e2d4 - 0x100e2da
int32_t function_100e2d4(int32_t a1) {
    // 0x100e2d4
    int32_t v1; // 0x100e2d4
    int32_t v2; // 0x100e2d4
    __asm_out((int16_t)v1, (char)v2);
    int32_t result; // 0x100e2d4
    return result;
}

// Address range: 0x100e2da - 0x100e2f5
int32_t function_100e2da(int32_t a1) {
    // 0x100e2da
    function_100dfef();
    int32_t v1; // 0x100e2da
    __asm_arpl(g83, (int16_t)v1);
    return function_100bd6f(a1);
}

// Address range: 0x100e2f5 - 0x100e40f
int32_t function_100e2f5(int32_t a1, int32_t a2) {
    // 0x100e2f5
    int32_t v1; // 0x100e2f5
    int32_t v2; // 0x100e2f5
    int32_t v3 = v2 & -256 | (int32_t)__asm_in_3((int16_t)v1); // 0x100e2f9
    uint32_t v4; // 0x100e2f5
    char * v5 = (char *)(v4 - 117); // 0x100e2fa
    bool v6; // 0x100e2f5
    *v5 = (char)v6 + (char)v1 + *v5;
    int32_t v7; // 0x100e2f5
    char * v8 = (char *)(*(int32_t *)(v7 - 125) + 0x33572d03); // 0x100e2fe
    *v8 = *v8 | (char)(v4 / 256);
    int32_t v9; // 0x100e2f5
    int32_t * v10 = (int32_t *)(v9 + 0x7d89fcb3); // 0x100e304
    *v10 = *v10 - 1;
    int32_t v11 = *(int32_t *)v3; // 0x100e30b
    int32_t result = *(int32_t *)(v3 + 4); // 0x100e30d
    int64_t v12; // 0x100e2f5
    __asm_pcmpeqb(v12, *(int64_t *)v11);
    *(int32_t *)v11 = result;
    *(int32_t *)*(int32_t *)(v4 + 4) = result;
    int16_t v13; // bp-2, 0x100e2f5
    if (&v13 < NULL) {
        // 0x100e380
        return 0x10000 * result / 0x10000;
    }
    if (result == 0) {
        // 0x100e400
        return (int32_t)*(char *)0x15e8f403;
    }
    // 0x100e333
    return result;
}

// Address range: 0x100e447 - 0x100e44c
int32_t function_100e447(void) {
    // 0x100e447
    return function_8ca6d74e();
}

// Address range: 0x100e461 - 0x100e561
int32_t function_100e461(void) {
    // 0x100e461
    uint32_t v1; // 0x100e461
    int32_t * v2 = (int32_t *)(v1 - 0x74000069); // 0x100e46c
    uint32_t v3 = *v2; // 0x100e46c
    *v2 = v3 / 2 | 0x80000000 * v3;
    int32_t v4; // 0x100e461
    *(int32_t *)(v4 + 4) = __asm_hlt();
    int32_t v5; // 0x100e461
    int32_t v6 = *(int32_t *)(v5 - 0x72f372fc); // 0x100e482
    uint32_t v7; // 0x100e461
    char * v8 = (char *)v7; // 0x100e48a
    char v9 = v7; // 0x100e48a
    *v8 = *v8 + v9;
    *(int32_t *)v5 = *(int32_t *)v6;
    bool v10; // 0x100e461
    int32_t v11 = v10 ? -4 : 4; // 0x100e492
    int32_t v12 = v11 + v5; // 0x100e492
    int32_t v13 = v7 / 512 & 61; // 0x100e495
    __asm_rep_movsb_memcpy((char *)v12, (char *)(v6 + v11), v13);
    int32_t v14 = (v10 ? -1 : 1) * v13 + v12; // 0x100e498
    int32_t v15; // 0x100e461
    __asm_into(v15);
    int32_t v16; // 0x100e461
    int32_t v17 = function_100be29(v16 - 13); // 0x100e4a4
    int32_t v18 = *(int32_t *)(v16 - 0x31000059); // 0x100e4b2
    char * v19 = (char *)v17; // 0x100e4bb
    unsigned char v20 = *v19; // 0x100e4bb
    unsigned char v21 = v20 / 128 | 2 * v20; // 0x100e4bb
    unsigned char v22 = v21 + (char)v17; // 0x100e4bd
    *v19 = v22;
    char * v23 = (char *)v14; // 0x100e4d2
    *v23 = *v23 + (char)v14;
    if (*(int32_t *)(v16 - 17) != 1) {
        function_18993b3();
    }
    int32_t v24 = v1 / 8 & 224 | v1 / 0x1000 & 15 | 16 * (int32_t)(v18 != 0); // 0x100e4b8
    int32_t v25 = unknown_8c007b86(v7); // 0x100e4e1
    int32_t * v26 = (int32_t *)v7; // 0x100e4ee
    *v26 = v25;
    int16_t v27; // 0x100e461
    unknown_96cae8b7(v27);
    *v26 = 0;
    unknown_eca77bfb(0x10000 * *(int32_t *)(*(int32_t *)255 + 4) / 0x10000);
    *(char *)(v17 + 1 + (v22 < v21 ? 0x55d1 : 0x55d2)) = -(char)v18;
    int32_t * v28 = (int32_t *)(v7 - 0x18b1742b); // 0x100e513
    *v28 = *v28 - v18;
    *v8 = (char)v24 + v9;
    int32_t v29 = v7 / 0x80000 & 4095; // 0x100e526
    __asm_rep_movsd_memcpy(v8, v23, v29);
    *v26 = v16 - 1;
    __asm_rep_movsb_memcpy((char *)(v11 * v29 + v7), v8, 0);
    *(int32_t *)(v7 + 0x1e79) = *(int32_t *)(v7 + 4);
    char * v30 = (char *)(v7 - 0x7400006a); // 0x100e537
    *v30 = (char)((v7 & 0x40000) != 0) + v9 + *v30;
    int32_t v31 = *(int32_t *)((int32_t)g88 + 4); // 0x100e547
    int32_t v32 = v7 + 0x1e75; // 0x100e54a
    *(int32_t *)v32 = *(int32_t *)(v31 + 4);
    unknown_1000242();
    __readgsdword(-0x545efbbf);
    int32_t * v33 = (int32_t *)(256 * v24 | v1 & -0xff01); // 0x100e55a
    *v33 = *v33 + v32;
    return function_4fcfe9d1();
}

// Address range: 0x100e561 - 0x100e588
int32_t function_100e561(void) {
    // 0x100e561
    int32_t v1; // 0x100e561
    int32_t v2; // 0x100e561
    int32_t v3; // 0x100e561
    int32_t v4 = v3 + 224 + (*(int32_t *)(v1 + 0x7b8d0478) > -1 - v2 ? -13 : -12); // 0x100e569
    char * v5 = (char *)(v4 & 255 | v3 & -256); // 0x100e56b
    *v5 = *v5 + (char)v4;
    int32_t v6; // 0x100e561
    int32_t v7; // 0x100e561
    *(char *)v6 = *(char *)&v6 + (char)v7;
    int32_t v8; // 0x100e561
    int32_t v9; // 0x100e561
    __asm_rep_movsb_memcpy((char *)v8, (char *)v9, v4 & 3);
    int32_t v10; // 0x100e561
    *(int32_t *)(v10 - 16) = 0x4c000001;
    return function_100e9b0();
}

// Address range: 0x100e588 - 0x100e60c
int32_t function_100e588(void) {
    // 0x100e588
    int32_t v1; // 0x100e588
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x100e588
    unknown_a7967bd1(*v2);
    *v2 = *v2 & 1;
    unknown_3200e1e3();
    unknown_b47bc1();
    *(int32_t *)*v2 = 0;
    int32_t * v3 = (int32_t *)*(int32_t *)(v1 + 12); // 0x100e5ac
    int32_t v4; // 0x100e588
    *(int32_t *)v4 = unknown_8f00fb(*(int32_t *)(*v3 + 4));
    int32_t result = *v2; // 0x100e5c0
    *(int32_t *)*(int32_t *)result = *(int32_t *)*v3;
    return result;
}

// Address range: 0x100e616 - 0x100e61b
int32_t function_100e616(void) {
    // 0x100e616
    return function_8ca6d91d();
}

// Address range: 0x100e64a - 0x100e656
int32_t function_100e64a(void) {
    // 0x100e64a
    int32_t v1; // 0x100e64a
    int32_t * v2 = (int32_t *)(v1 - 0x2e0ff040); // 0x100e64d
    *v2 = *v2 + 1;
    int32_t result; // 0x100e64a
    *(int32_t *)result = 2 * result;
    return result;
}

// Address range: 0x100e69e - 0x100e6a3
int32_t function_100e69e(void) {
    // 0x100e69e
    return function_8ca6d9a5();
}

// Address range: 0x100e6ba - 0x100e6c5
int32_t function_100e6ba(void) {
    // 0x100e6ba
    int32_t v1; // 0x100e6ba
    char * v2 = (char *)(v1 + 0x468b0c75); // 0x100e6ba
    int32_t v3; // 0x100e6ba
    *v2 = *v2 + (char)v3;
    int32_t v4; // 0x100e6ba
    return v4 + 255 & 255 | v4 & -256;
}

// Address range: 0x100e6c6 - 0x100e6c9
int32_t function_100e6c6(void) {
    // 0x100e6c6
    int32_t result; // 0x100e6c6
    return result;
}

// Address range: 0x100e6df - 0x100e6ea
int32_t function_100e6df(void) {
    // 0x100e6df
    int32_t v1; // 0x100e6df
    char * v2 = (char *)(v1 - 0x3e3e743b); // 0x100e6df
    uint32_t v3; // 0x100e6df
    *v2 = *v2 + (char)(v3 / 256);
    return function_8cacd9ec();
}

// Address range: 0x100e6f4 - 0x100e6ff
int32_t function_100e6f4(void) {
    // 0x100e6f4
    int32_t v1; // 0x100e6f4
    char * v2 = (char *)(v1 - 24); // 0x100e6f5
    int32_t v3; // 0x100e6f4
    *v2 = *v2 | (char)v3;
    return function_fff1ffd7();
}

// Address range: 0x100e700 - 0x100e70e
int32_t function_100e700(void) {
    // 0x100e700
    __asm_hlt();
    int16_t v1; // 0x100e700
    return unknown_ecff8aff(v1);
}

// Address range: 0x100e70e - 0x100e714
int32_t function_100e70e(void) {
    // 0x100e70e
    int32_t result; // 0x100e70e
    return result;
}

// Address range: 0x100e729 - 0x100e79c
int32_t function_100e729(void) {
    // 0x100e729
    int32_t v1; // 0x100e729
    int32_t v2 = *(int32_t *)*(int32_t *)(v1 - 8); // 0x100e743
    int32_t v3; // 0x100e729
    int32_t * v4 = (int32_t *)(v3 - 0x745a0ce6); // 0x100e74e
    *v4 = *v4 / 4;
    char * v5 = (char *)v3; // 0x100e758
    __asm_rep_movsb_memcpy((char *)v2, v5, 0);
    int32_t v6 = unknown_e1007bc1(*(int32_t *)(*(int32_t *)(v1 + 2) - 4)); // 0x100e760
    int32_t * v7 = (int32_t *)(v6 + 4); // 0x100e768
    *v7 = *v7 & 56;
    int32_t v8 = *(int32_t *)(v3 + 4); // 0x100e76e
    int32_t v9; // 0x100e729
    char v10 = __asm_in_3((int16_t)v9); // 0x100e77a
    *(int32_t *)(*(int32_t *)(v2 - 8) + 4) = v8 & -256 | (int32_t)v10;
    *v5 = 2 * (char)v3;
    return function_8ca6da9e();
}

// Address range: 0x100e7af - 0x100e7b0
int32_t function_100e7af(void) {
    // 0x100e7af
    int32_t result; // 0x100e7af
    return result;
}

// Address range: 0x100e7ea - 0x100e80a
int32_t function_100e7ea(void) {
    // 0x100e7ea
    int32_t v1; // 0x100e7ea
    int32_t result = unknown_6686c8(v1); // 0x100e7eb
    int32_t v2; // 0x100e7ea
    if (*(char *)(v2 - 50) >= 64) {
        // 0x100e7fd
        unknown_f5007bd1(*(int32_t *)(v2 + 8));
        return function_bd402da4();
    }
    char * v3 = (char *)(v1 + 0xfe01f0); // 0x100e7f6
    *v3 = *v3 + (char)v1;
    return result;
}

// Address range: 0x100e80a - 0x100e827
int32_t function_100e80a(void) {
    // 0x100e80a
    uint32_t v1; // 0x100e80a
    if ((char)unknown_37bd1() == -(char)(v1 / 256)) {
        function_100e7af();
    }
    // 0x100e81c
    int32_t v2; // 0x100e80a
    *(int32_t *)(v2 + 8) = 0;
    return function_154c44d();
}

// Address range: 0x100e828 - 0x100e830
int32_t function_100e828(void) {
    // 0x100e828
    int32_t result; // 0x100e828
    return result;
}

// Address range: 0x100e851 - 0x100e854
int32_t function_100e851(void) {
    // 0x100e851
    int32_t result; // 0x100e851
    return result;
}

// Address range: 0x100e87f - 0x100e884
int32_t function_100e87f(void) {
    // 0x100e87f
    return function_8c01e9d3();
}

// Address range: 0x100e8ab - 0x100e8b0
int32_t function_100e8ab(void) {
    // 0x100e8ab
    return function_8ca6dbb2();
}

// Address range: 0x100e8d7 - 0x100e8e0
int32_t function_100e8d7(int32_t a1) {
    // 0x100e8d7
    int32_t v1; // 0x100e8d7
    int32_t * v2 = (int32_t *)(v1 - 0x767617b3); // 0x100e8d7
    *v2 = *v2 - 1;
    int32_t v3; // 0x100e8d7
    return v3 + 161 & 255 | v3 & -256;
}

// Address range: 0x100e8fc - 0x100e901
int32_t function_100e8fc(void) {
    // 0x100e8fc
    return function_8ca6dc03();
}

// Address range: 0x100e97f - 0x100e993
int32_t function_100e97f(void) {
    // 0x100e97f
    int32_t v1; // 0x100e97f
    *(int32_t *)v1 = 2 * v1;
    int32_t v2; // 0x100e97f
    __asm_out((int16_t)v2, (char)__asm_wait());
    int32_t result = unknown_c2012670(); // 0x100e983
    int32_t v3; // 0x100e97f
    *(int32_t *)(v3 - 16) = 0x3f0067;
    return result;
}

// Address range: 0x100e9b0 - 0x100e9c1
int32_t function_100e9b0(void) {
    // 0x100e9b0
    int32_t v1; // 0x100e9b0
    int32_t result = unknown_c2e8d1(*(int32_t *)(v1 - 12)); // 0x100e9b3
    int32_t v2; // 0x100e9b0
    __asm_into(v2);
    return result;
}

// Address range: 0x100e9c2 - 0x100e9cd
int32_t function_100e9c2(int32_t a1, int32_t a2, int32_t a3) {
    // 0x100e9c2
    int32_t v1; // 0x100e9c2
    __asm_into(v1);
    int32_t result; // 0x100e9c2
    return result;
}

// Address range: 0x100e9e9 - 0x100ea23
int32_t function_100e9e9(void) {
    // 0x100e9e9
    int32_t v1; // 0x100e9e9
    int32_t * v2 = (int32_t *)(v1 + 0x34e82b75); // 0x100e9e9
    *v2 = *v2 - 1;
    int32_t v3; // 0x100e9e9
    int32_t * v4 = (int32_t *)(v3 - 119); // 0x100e9f0
    *v4 = *v4 - 1;
    __asm_hlt();
    __asm_hlt();
    int32_t v5; // 0x100e9e9
    __asm_in_5((int16_t)v5);
    char * v6 = (char *)(v3 - 0x74fc74cf); // 0x100ea01
    *v6 = *v6 | (char)v3 + 1;
    return function_389bf445();
}

// Address range: 0x100ea2b - 0x100ea30
int32_t function_100ea2b(void) {
    // 0x100ea2b
    return function_8ca6dd32();
}

// Address range: 0x100ea3a - 0x100ea41
int32_t function_100ea3a(void) {
    // 0x100ea3a
    return function_91ece804();
}

// Address range: 0x100ea41 - 0x100ea78
int32_t function_100ea41(void) {
    // 0x100ea41
    int32_t v1; // 0x100ea41
    int32_t * v2 = (int32_t *)(v1 - 12); // 0x100ea41
    *(int32_t *)(*v2 + 4) = 0;
    int32_t v3 = *v2 + 1; // 0x100ea59
    unsigned char v4 = *(char *)-0x7447b175; // 0x100ea5f
    int32_t v5; // 0x100ea41
    char * v6 = (char *)(v5 + 0xc8d0478); // 0x100ea65
    *v6 = *v6 + (char)v3;
    int32_t v7; // 0x100ea41
    float80_t v8; // 0x100ea41
    *(int32_t *)(4 * v3 + v7) = (int32_t)v8;
    char * v9 = (char *)((int32_t)v4 | 0x708b0300); // 0x100ea6e
    *v9 = *v9 + v4;
    return function_8ca6117a();
}

// Address range: 0x100ea78 - 0x100ea81
int32_t function_100ea78(void) {
    // 0x100ea78
    int32_t v1; // 0x100ea78
    int32_t v2; // 0x100ea78
    int32_t v3; // 0x100ea78
    __asm_rep_movsb_memcpy((char *)v1, (char *)v2, v3);
    int32_t result; // 0x100ea78
    return result;
}

// Address range: 0x100ea81 - 0x100eada
int32_t function_100ea81(int32_t a1, int32_t a2, uint32_t a3, int32_t a4) {
    // 0x100ea81
    __asm_hlt();
    int32_t v1 = function_100bbd4(); // 0x100ea84
    char * v2 = (char *)v1; // 0x100ea8f
    char v3 = v1; // 0x100ea8f
    *v2 = *v2 + v3;
    char * v4 = (char *)(v1 - 0x4198ccaa); // 0x100ea91
    *v4 = *v4 + v3;
    int32_t v5; // 0x100ea81
    int32_t * v6 = (int32_t *)(v5 - 3); // 0x100ea97
    *v6 = v1;
    int32_t v7 = unknown_d4007c4c(); // 0x100ea9a
    char * v8 = (char *)(v5 + 8); // 0x100ea9f
    int32_t v9; // 0x100ea81
    *v8 = *v8 - (char)v9;
    *(int32_t *)v9 = v7;
    int32_t v10 = v7; // 0x100eaab
    int32_t v11; // 0x100ea81
    unsigned char v12 = (char)v11 - 1; // 0x100eab0
    v10--;
    v11 = v12;
    while (v10 != 0 == v12 == 0) {
        // 0x100eab0
        v12 = (char)v11 - 1;
        v10--;
        v11 = v12;
    }
    // 0x100eab4
    int32_t v13; // 0x100ea81
    bool v14; // 0x100ea81
    *v6 = (v14 ? -1 : 1) + v13;
    *(int32_t *)unknown_5300ac26() = v5 + 1;
    char * v15 = (char *)((a3 / 256 & 255 ^ a4) + 0x458b6dff); // 0x100eac7
    *v15 = -1 - *v15;
    return *(int32_t *)*(int32_t *)a1;
}

// Address range: 0x100eadb - 0x100eb4d
int32_t function_100eadb(void) {
    // 0x100eadb
    uint32_t v1; // 0x100eadb
    int32_t * v2 = (int32_t *)(v1 + 0x1f9fc4d); // 0x100eadb
    *v2 = *v2 - 1;
    int32_t v3; // 0x100eadb
    int32_t v4 = v3 + 139; // 0x100eae7
    int32_t v5; // 0x100eadb
    int32_t v6 = __asm_insd((int16_t)v5); // 0x100eaed
    int32_t * v7 = (int32_t *)*(int32_t *)(v4 & 255 | v3 & -256); // 0x100eaed
    *v7 = v6;
    char * v8 = (char *)(v1 - 0x6b3eda75); // 0x100eaf2
    *v8 = *v8 + (char)(v1 / 256);
    *v7 = *(int32_t *)(v3 - 1);
    int32_t v9 = (4 * v4 & 8 | 4) + v1;
    int32_t * v10 = (int32_t *)(v9 + 0x703f6845); // 0x100eb00
    *v10 = *v10 & 4;
    unknown_aa007bc1();
    int32_t v11; // 0x100eadb
    int32_t v12 = *(int32_t *)(v11 - 3); // 0x100eb0d
    *(int32_t *)(v12 - 14) = 0;
    *(int32_t *)v9 = v11 + 1;
    int32_t v13 = v12 + 1; // 0x100eb17
    char v14 = v13; // 0x100eb18
    unsigned char v15 = v14 - 1; // 0x100eb18
    int32_t result = v13 & -256 | (int32_t)v15; // 0x100eb18
    if (((v15 ^ v14) & -v14) >= 0) {
        // 0x100eb1c
        return result;
    }
    int32_t v16 = *(int32_t *)(result - 4); // 0x100eb21
    int32_t v17 = *(int32_t *)(v3 + 3); // 0x100eb24
    int32_t v18 = v3 + 7; // 0x100eb24
    int32_t v19 = *(int32_t *)(v16 + 1); // 0x100eb28
    int32_t v20 = (((v19 - v18 ^ v19) & (v19 ^ v18)) < 0 ? 139 : 233) + v17;
    int32_t v21 = ((v19 - v18 ^ v19) & (v19 ^ v18)) < 0 ? v18 : v19;
    int32_t v22 = *(int32_t *)(v1 - 0x720372fc); // 0x100eb32
    char * v23 = (char *)(v20 & 255 | v17 & -256); // 0x100eb3a
    unsigned char v24 = *v23; // 0x100eb3a
    unsigned char v25 = v24 + (char)v20; // 0x100eb3a
    *v23 = v25;
    int16_t v26; // 0x100eadb
    __asm_rep_movsb_memcpy((char *)v22, (char *)v21, (int32_t)v26);
    return v16 - 0x745a0cfd + (int32_t)(v25 < v24);
}

// Address range: 0x100eb4e - 0x100eb58
int32_t function_100eb4e(int32_t a1) {
    // 0x100eb4e
    uint32_t v1; // 0x100eb4e
    int32_t v2; // 0x100eb4e
    return v2 + v1 / 256 & 255 | v2 & -256;
}

// Address range: 0x100eb5c - 0x100eb5e
int32_t function_100eb5c(int32_t a1) {
    // 0x100eb5c
    int32_t result; // 0x100eb5c
    return result;
}

// Address range: 0x100eb92 - 0x100eb93
int32_t function_100eb92(int32_t a1) {
    // 0x100eb92
    int32_t result; // 0x100eb92
    return result;
}

// Address range: 0x100ebf0 - 0x100ebf3
int32_t function_100ebf0(void) {
    // 0x100ebf0
    int32_t result; // 0x100ebf0
    return result;
}

// Address range: 0x100ec01 - 0x100ec1f
int32_t function_100ec01(void) {
    // 0x100ec01
    int32_t v1; // 0x100ec01
    int32_t * v2 = (int32_t *)(v1 + 0x14ff235); // 0x100ec01
    *v2 = *v2 - 1;
    int32_t v3; // 0x100ec01
    int32_t * v4 = (int32_t *)(v3 + 0x4e8bf045); // 0x100ec07
    int32_t v5; // 0x100ec01
    *v4 = *v4 + v5;
    int32_t v6; // 0x100ec01
    int32_t v7; // 0x100ec01
    __asm_out((int16_t)v6, (char)v7 + 13 | -51);
    char * v8 = (char *)(v1 - 0x3e3e74e5); // 0x100ec14
    int32_t v9; // 0x100ec01
    *v8 = *v8 + (char)v9;
    return function_e9a6df21();
}

// Address range: 0x100ec2a - 0x100ec2b
int32_t function_100ec2a(void) {
    // 0x100ec2a
    int32_t result; // 0x100ec2a
    return result;
}

// Address range: 0x100ec36 - 0x100ecea
int32_t function_100ec36(void) {
    // 0x100ec36
    int32_t v1; // 0x100ec36
    int32_t v2 = *(int32_t *)(v1 + 109); // 0x100ec36
    uint32_t v3 = *(int32_t *)(v2 + 12); // 0x100ec39
    uint32_t v4; // 0x100ec36
    int32_t v5; // 0x100ec36
    if (v3 < v4) {
        // 0x100ec40
        *(int32_t *)v5 = v2;
        return v3 | 235;
    }
    int32_t v6 = __asm_int1(); // 0x100ec46
    char * v7 = (char *)(v5 + 0x35ff8000); // 0x100ec47
    *v7 = *v7 + (char)v5;
    __asm_out_4(116, v6);
    int32_t * v8 = (int32_t *)(v1 - 0x17cd0fbb); // 0x100ec50
    *v8 = *v8 + v2;
    if (v2 == 1) {
        char * v9 = (char *)v6; // 0x100ec58
        *v9 = *v9 + (char)v6;
        return function_e950f125(*(int32_t *)(v1 - 16));
    }
    while (true) {
        // continue -> 0x100ec85
    }
}

// Address range: 0x100eced - 0x100ecf8
int32_t function_100eced(void) {
    // 0x100eced
    return unknown_287bb1();
}

// Address range: 0x100ecf8 - 0x100ed2b
int32_t function_100ecf8(int32_t a1) {
    // 0x100ecf8
    int32_t v1; // 0x100ecf8
    unknown_97c309(unknown_d57b9b(), *(int32_t *)(v1 - 8));
    return *(int32_t *)-0x71fffff4;
}

// Address range: 0x100ed2b - 0x100ed44
int32_t function_100ed2b(void) {
    // 0x100ed2b
    int32_t v1; // 0x100ed2b
    char * v2 = (char *)(v1 - 53); // 0x100ed32
    int32_t v3; // 0x100ed2b
    *v2 = *v2 | (char)v3;
    int32_t v4; // 0x100ed2b
    int32_t v5 = v4 ^ (int32_t)&g88; // 0x100ed35
    int32_t v6 = (v5 & 14) > 9 ? v5 + 10 : v5; // 0x100ed3c
    int32_t v7; // bp-4, 0x100ed2b
    int32_t v8 = *(int32_t *)(v3 + 0x16e8fc75) ^ v5 & (int32_t)&v7; // 0x100ed3d
    return v5 & -0x10000 | v6 & 15 | 0x4000 * (int32_t)(v8 == 0) | 0x8000 * (int32_t)(v8 < 0) | 1024 * (int32_t)((llvm_ctpop_i8((char)v8) & 1) == 0) | 512;
}

// Address range: 0x100ed74 - 0x100ed9a
int32_t function_100ed74(void) {
    // 0x100ed74
    int32_t v1; // 0x100ed74
    int32_t * v2 = (int32_t *)(v1 + 0x4d2bffff); // 0x100ed76
    *v2 = *v2 | 0x1b889fc;
    int32_t v3; // 0x100ed74
    char * v4 = (char *)(v3 + 0x458b040b); // 0x100ed82
    int32_t v5; // 0x100ed74
    int32_t v6; // 0x100ed74
    *v4 = *v4 ^ (char)(v6 + v5);
    int32_t v7; // 0x100ed74
    int32_t v8 = v7 + 85 & 101 | 154; // 0x100ed8e
    char * v9 = (char *)(v8 | v7 & -256); // 0x100ed90
    *v9 = *v9 + (char)v8;
    return function_8ca68f9c();
}

// Address range: 0x100eddd - 0x100ede2
int32_t function_100eddd(void) {
    // 0x100eddd
    return function_8ca6e0e4();
}

// Address range: 0x100edeb - 0x100edfe
int32_t function_100edeb(void) {
    // 0x100edeb
    int32_t v1; // 0x100edeb
    int32_t * v2 = (int32_t *)(v1 + 0x8bfc45); // 0x100eded
    *v2 = *v2 - 1;
    int32_t v3; // 0x100edeb
    *(int32_t *)v3 = -v3;
    int32_t v4; // 0x100edeb
    return v4 - 4;
}

// Address range: 0x100ee02 - 0x100ee14
int32_t function_100ee02(void) {
    int32_t result = function_100be29((int32_t)&g125); // 0x100ee02
    __asm_out_4(232, result);
    return result;
}

// Address range: 0x100ee14 - 0x100ee2a
int32_t function_100ee14(int32_t a1, int32_t a2, int32_t a3) {
    // 0x100ee14
    return unknown_ab007bd1();
}

// Address range: 0x100ee2c - 0x100ee2d
int32_t function_100ee2c(void) {
    // 0x100ee2c
    int32_t result; // 0x100ee2c
    return result;
}

// Address range: 0x100ee38 - 0x100eee4
int32_t function_100ee38(int16_t a1, int32_t a2) {
    // 0x100ee38
    bool v1; // 0x100ee38
    if (!v1) {
        function_100ee2c();
    }
    // 0x100ee3c
    int32_t v2; // 0x100ee38
    int32_t v3 = v2 & -256 | 115; // 0x100ee38
    int32_t v4; // 0x100ee38
    uint32_t v5 = v4 - 1; // 0x100ee52
    char * v6 = (char *)(v3 - 0x8a7298); // 0x100ee53
    *v6 = *v6 ^ (char)(v5 / 256);
    int32_t v7; // 0x100ee38
    int32_t v8 = *(int32_t *)(v7 - 8); // 0x100ee59
    int32_t v9 = *(int32_t *)((v8 + 22 & 255 | v8 & -256) + 4); // 0x100eec3
    int32_t v10 = 4 * v3 - 0x31fffff8; // 0x100eec6
    int32_t v11; // 0x100ee38
    *(int32_t *)v9 = *(int32_t *)(v11 - 2);
    int32_t v12 = v9 + 5; // 0x100eed4
    __asm_rep_movsb_memcpy((char *)v12, (char *)(v11 + 2), v10);
    int32_t v13; // bp-8, 0x100ee38
    int32_t v14 = &v13; // 0x100eedd
    *(int32_t *)(v12 + v10) = v14;
    __asm_out((int16_t)v5, (char)v14);
    return __asm_int3();
}

// Address range: 0x100ef03 - 0x100efba
int32_t function_100ef03(void) {
    int32_t v1 = unknown_ff007c4c(); // 0x100ef03
    int32_t v2 = v1 & -256; // 0x100ef0d
    int32_t v3 = v1 + 255 & 255 | v2; // 0x100ef0d
    int32_t v4; // 0x100ef03
    int32_t v5 = v4 - 12; // 0x100ef1b
    int32_t * v6 = (int32_t *)v5; // 0x100ef1b
    int32_t v7 = *v6; // 0x100ef1b
    *(int32_t *)v7 = v3 ^ (int32_t)&g4;
    int32_t v8 = v3 ^ (int32_t)&g4 ^ 0x1294110; // 0x100ef21
    int32_t v9 = 1; // bp-10, 0x100ef26
    *v6 = *v6 - v7;
    uint32_t v10 = v7 + 1; // 0x100ef31
    unsigned char v11 = (char)v8 - 111; // 0x100ef32
    int32_t v12; // 0x100ef03
    int32_t v13; // 0x100ef03
    uint32_t v14; // 0x100ef03
    if (v11 != 0) {
        char * v15 = (char *)(v2 ^ ((int32_t)&g4 ^ 0x1294110) & -256 | (int32_t)v11); // 0x100ef76
        *v15 = *v15 + v11;
        uint32_t v16 = v10 / 4; // 0x100ef7a
        __asm_rep_movsd_memcpy((char *)v12, (char *)v1, v16);
        int32_t * v17 = (int32_t *)((v10 & -256 | v7 + 233 & 255) + 4); // 0x100ef94
        *v17 = *v17 & -44;
        int32_t v18; // 0x100ef03
        *(int32_t *)(*(int32_t *)(v13 + 4) - 4) = *(int32_t *)(v18 + 4);
        bool v19; // 0x100ef03
        __asm_outsd((int16_t)v14, *(int32_t *)(v16 * (v19 ? -4 : 4) + v12));
        __asm_int1();
        __asm_hlt();
        return function_558cebcc();
    }
    // 0x100ef36
    int16_t v20; // 0x100ef03
    unknown_3d007c09(v12, v1, v4, &v9, v13, v14, v7, v8, v9, v20, 1);
    int32_t v21 = unknown_a3004b26(); // 0x100ef3e
    *(int32_t *)v4 = v21;
    *(int32_t *)v12 = __asm_insd((int16_t)v14);
    char v22 = *(char *)(v13 + 0x168bf445); // 0x100ef51
    char v23 = v10; // 0x100ef51
    bool v24 = (v21 & 14) > 9 | (v22 & 15) - (v23 & 15) > 15; // 0x100ef57
    int32_t v25 = (v24 ? v21 + 10 : v21) & 15; // 0x100ef57
    int32_t result = v25 | v21 & -0x10000 | 256 * (int32_t)v24 + v21 & 0xff00; // 0x100ef57
    if (((v22 - v23 ^ v22) & (v22 ^ v23)) >= 0) {
        // 0x100ef5a
        return result;
    }
    char * v26 = (char *)(v12 + 77); // 0x100ef5e
    *v26 = *v26 | (char)(v14 / 256);
    *(int32_t *)v10 = result;
    *(char *)v5 = (char)v25;
    return *(int32_t *)(v4 - 4);
}

// Address range: 0x100efc5 - 0x100efca
int32_t function_100efc5(void) {
    // 0x100efc5
    return function_8ca6e30a();
}

// Address range: 0x100efdd - 0x100efdf
int32_t function_100efdd(void) {
    // 0x100efdd
    int32_t result; // 0x100efdd
    return result;
}

// Address range: 0x100efef - 0x100eff0
int32_t function_100efef(int32_t a1) {
    // 0x100efef
    int32_t result; // 0x100efef
    return result;
}

// Address range: 0x100f033 - 0x100f035
int32_t function_100f033(void) {
    // 0x100f033
    return function_100f049();
}

// Address range: 0x100f035 - 0x100f049
int32_t function_100f035(void) {
    // 0x100f035
    int32_t v1; // 0x100f035
    g80 = v1;
    int32_t v2; // 0x100f035
    return function_1011961(v2 - 16, 0x3c00bf56);
}

// Address range: 0x100f049 - 0x100f0d3
int32_t function_100f049(void) {
    // 0x100f049
    int32_t v1; // 0x100f049
    int32_t * v2 = (int32_t *)(v1 - 4); // 0x100f049
    int32_t v3 = *v2 + 4; // 0x100f04f
    unknown_71bc54(unknown_6a012314(v3, *(int32_t *)(v1 - 16)), *v2);
    int32_t v4 = *(int32_t *)*(int32_t *)(v1 - 117); // 0x100f067
    int32_t v5 = v4; // bp-20, 0x100f067
    int32_t v6 = function_1017418(v4); // 0x100f069
    __asm_out_6(192, (char)v6);
    int32_t * v7; // 0x100f049
    int32_t v8; // 0x100f049
    int32_t v9; // 0x100f049
    int32_t * v10; // 0x100f049
    int32_t v11; // 0x100f049
    if (v3 >= 0) {
        // 0x100f049
        v7 = (int32_t *)v11;
        v10 = &v5;
    } else {
        int32_t v12 = *(int32_t *)(v6 + 4); // 0x100f080
        int32_t v13; // 0x100f049
        bool v14; // 0x100f049
        int32_t v15 = (v14 ? -1 : 1) + v13; // 0x100f083
        uint32_t v16 = *(int32_t *)*v2 & 31; // 0x100f08a
        if (v16 != 0) {
            int32_t * v17 = (int32_t *)(v15 - 0x1afcbffb); // 0x100f08a
            *v17 = *v17 >> v16;
        }
        int32_t v18 = v12 + 141 & 255 | v12 & -256; // 0x100f085
        int32_t v19 = (v11 & 0xff00) + v11 & 0xff00 | v11 & -0xff01; // 0x100f088
        int32_t * v20 = (int32_t *)v19;
        *v20 = *v20 + v15;
        int32_t result = v18 - 0xdfe93a4; // 0x100f092
        v7 = v20;
        v8 = v19;
        int32_t v21; // bp-23, 0x100f049
        v10 = &v21;
        v9 = v15;
        if (result < 0 == ((result ^ v12) & v18 + 0x72016c5c) < 0 != result != 0) {
            // 0x100f099
            return result;
        }
    }
    int32_t v22 = (int32_t)v10;
    *(int32_t *)(v22 - 4) = *(int32_t *)(v1 + 8);
    int32_t * v23 = (int32_t *)(v1 - 8); // 0x100f0ad
    *(int32_t *)(v22 - 8) = *v23;
    *(int32_t *)(v1 - 120) = v9;
    function_1007bd1();
    *v23 = v9;
    *(int32_t *)(v22 - 12) = *v7;
    *v2 = v9;
    int32_t v24 = unknown_73007bd1(); // 0x100f0c8
    *(int32_t *)(v22 - 16) = v24;
    int16_t v25 = v24; // 0x100f0d1
    int16_t v26 = (int16_t)*(char *)v8; // 0x100f0d1
    return v24 & -0x10000 | (int32_t)(v25 / v26 & 255) | (int32_t)(256 * (v25 % v26));
}

// Address range: 0x100f0d5 - 0x100f0e4
int32_t function_100f0d5(int32_t a1, int32_t a2, int32_t a3) {
    int32_t result = __asm_hlt(); // 0x100f0da
    int32_t v1; // 0x100f0d5
    *(int32_t *)v1 = result;
    return result;
}

// Address range: 0x100f0e4 - 0x100f112
int32_t function_100f0e4(int32_t a1) {
    // 0x100f0e4
    int32_t v1; // 0x100f0e4
    *(int32_t *)(v1 - 86) = *(int32_t *)a1;
    int32_t * v2 = (int32_t *)(*(int32_t *)(v1 - 0x76a8fbb7) | v1); // 0x100f102
    *v2 = *v2 + a1;
    int32_t v3; // 0x100f0e4
    int32_t v4; // 0x100f0e4
    int32_t v5; // 0x100f0e4
    int32_t v6; // 0x100f0e4
    return function_100865c(v3, v5, v6, v4);
}

// Address range: 0x100f15e - 0x100f163
int32_t function_100f15e(void) {
    // 0x100f15e
    return function_8ca6e465();
}

// Address range: 0x100f1a6 - 0x100f1ab
int32_t function_100f1a6(void) {
    // 0x100f1a6
    return function_8ca6e52d();
}

// Address range: 0x100f1b3 - 0x100f1b5
int32_t function_100f1b3(void) {
    // 0x100f1b3
    int32_t result; // 0x100f1b3
    return result;
}

// Address range: 0x100f1cd - 0x100f1d0
int32_t function_100f1cd(int32_t a1) {
    // 0x100f1cd
    int32_t result; // 0x100f1cd
    return result;
}

// Address range: 0x100f1d1 - 0x100f1da
int32_t function_100f1d1(int32_t a1) {
    // 0x100f1d1
    int32_t result; // 0x100f1d1
    float80_t v1; // 0x100f1d1
    *(int32_t *)(result + 0x5301b74f) = (int32_t)v1;
    return result;
}

// Address range: 0x100f1dc - 0x100f1fa
int32_t function_100f1dc(void) {
    // 0x100f1dc
    int32_t v1; // 0x100f1dc
    __asm_frstor(*(int864_t *)(v1 - 4));
    int32_t v2; // 0x100f1dc
    uint32_t v3; // 0x100f1dc
    *(char *)v2 = (char)(v3 / 256) + (char)v2;
    int32_t v4; // 0x100f1dc
    __asm_into(v4);
    unknown_2500ee2a();
    return function_100f22d(*(int32_t *)0x5a014f88, (int32_t)&g125);
}

// Address range: 0x100f1fb - 0x100f208
int32_t function_100f1fb(int32_t a1) {
    // 0x100f1fb
    int32_t v1; // 0x100f1fb
    char * v2 = (char *)(v1 - 0x3f470001); // 0x100f1fb
    int32_t v3; // 0x100f1fb
    bool v4; // 0x100f1fb
    char v5 = (char)v4 - (char)v3 + *v2; // 0x100f1fb
    *v2 = v5;
    int32_t result; // 0x100f1fb
    if (v5 == 0) {
        result = function_d0138a2();
    }
    // 0x100f207
    return result;
}

// Address range: 0x100f20a - 0x100f20b
int32_t function_100f20a(void) {
    // 0x100f20a
    int32_t result; // 0x100f20a
    return result;
}

// Address range: 0x100f22d - 0x100f38a
int32_t function_100f22d(int32_t a1, int32_t a2) {
    int32_t v1 = a2;
    int16_t v2; // bp-4, 0x100f22d
    bool v3; // 0x100f22d
    bool v4; // 0x100f22d
    uint32_t v5; // 0x100f22d
    uint32_t v6; // 0x100f22d
    bool v7; // 0x100f22d
    if (v3 == v7 != !v4) {
        // 0x100f237
        int32_t v8; // 0x100f22d
        *(int32_t *)v8 = v6 + v8;
        int16_t v9; // 0x100f22d
        int32_t v10 = unknown_97eab3ba(v9); // 0x100f24a
        int32_t v11 = -0x62f35b0d * *(int32_t *)(v5 + 0x3e183c8); // 0x100f24f
        int32_t v12 = *(int32_t *)(v10 + 4); // 0x100f25a
        v2 = v12;
        unknown_f272c1(0x10000 * v12 / 0x10000);
        int32_t * v13 = (int32_t *)(v5 + 4); // 0x100f264
        *v13 = *v13 & -100;
        int32_t * v14 = (int32_t *)(v11 + 0xb64ffff); // 0x100f274
        *v14 = *v14 | -102;
        int32_t v15; // bp-3, 0x100f22d
        int32_t v16 = &v15; // 0x100f27e
        int32_t * v17 = (int32_t *)(v11 + 1); // 0x100f280
        int32_t v18 = *v17; // 0x100f280
        int32_t v19 = v18 + v16; // 0x100f280
        *v17 = v19;
        char v20 = __asm_in_3((int16_t)*(int32_t *)(v5 + 0x38b044e + 4 * v8)); // 0x100f282
        int32_t result = v16 & -256 | (int32_t)v20; // 0x100f282
        if (((v19 ^ v18) & (v19 ^ v16)) >= 0) {
            // 0x100f285
            return result;
        }
        char * v21 = (char *)result; // 0x100f292
        *v21 = *v21 + v20;
        return 2 * result;
    }
    int32_t v22 = v6 / 256 + v6; // 0x100f298
    int32_t v23 = v6 & -256; // 0x100f298
    bool v24; // 0x100f22d
    int32_t v25 = v24 ? -4 : 4; // 0x100f29a
    int32_t v26; // 0x100f22d
    int32_t v27 = v25 + v26; // 0x100f29a
    int32_t v28 = v22 & 3; // 0x100f29d
    int32_t v29; // 0x100f22d
    __asm_rep_movsb_memcpy((char *)v27, (char *)(v25 + v29), v28);
    int32_t v30 = v24 ? -1 : 1; // 0x100f2a0
    int32_t v31 = v27 + v30 * v28; // 0x100f2a0
    int32_t v32; // 0x100f22d
    char * v33 = (char *)(v32 - 117); // 0x100f2a8
    char v34 = *v33; // 0x100f2a8
    *v33 = 2 * v34;
    int32_t v35; // 0x100f22d
    char v36 = __asm_in_3((int16_t)v35); // 0x100f2ab
    int32_t * v37; // 0x100f22d
    int32_t v38; // 0x100f22d
    int32_t v39; // 0x100f22d
    int32_t v40; // 0x100f22d
    int32_t v41; // 0x100f22d
    int32_t v42; // 0x100f22d
    int32_t v43; // 0x100f22d
    if ((v22 & 255 || v23) == 0x4e6c95b || v34 < 0) {
        char * v44 = (char *)(v31 - 119); // 0x100f2b1
        *v44 = -1 - *v44;
        unknown_e97c27();
        int32_t v45 = v35 & -0xff01; // 0x100f2bb
        int32_t v46 = unknown_2cd37c26(); // 0x100f2be
        int32_t * v47 = (int32_t *)(v32 - 4); // 0x100f2c3
        *v47 = v46;
        function_1007bc1(*(int32_t *)v46);
        int32_t v48 = *(int32_t *)(v32 + 8); // 0x100f2d0
        *(int32_t *)*v47 = v31;
        int32_t * v49 = (int32_t *)v48;
        int32_t v50 = *(int32_t *)*v49; // 0x100f2d7
        v2 = (int16_t)*(int32_t *)(v50 + 4);
        int32_t v51 = *v47; // 0x100f2e1
        *(int32_t *)v51 = v50;
        int32_t * v52 = (int32_t *)*v49; // 0x100f2e8
        int32_t v53 = *v52; // 0x100f2e8
        int32_t v54 = v53 + 4; // 0x100f2ea
        int32_t * v55 = (int32_t *)v54; // 0x100f2ea
        *v55 = *v55 + v51;
        int32_t v56 = &v2; // bp-8, 0x100f2ed
        int32_t v57 = &v56; // 0x100f2ed
        int32_t v58 = *v52; // 0x100f2f0
        __asm_in_5((int16_t)v45);
        *(int32_t *)v58 = *(int32_t *)v53;
        int32_t * v59 = (int32_t *)(8 * v54 + 0x701ffc49 + v58); // 0x100f305
        *v59 = *v59 + v57;
        v37 = v49;
        v39 = 3;
        v41 = 256 * v48 & 0xff00 | v45;
        v38 = v48;
        v43 = v57;
        v42 = v54;
        v40 = v58 + 8;
    } else {
        int32_t v60 = v23 ^ 0x4e6c900 | (int32_t)v36; // 0x100f2ab
        int32_t v61 = *(int32_t *)(8 * a1 + 0x3a044189 + (int32_t)&v1); // 0x100f326
        int32_t v62 = v60 + 139; // 0x100f333
        *(int32_t *)a1 = *(int32_t *)v31;
        int32_t v63 = v25 + a1; // 0x100f336
        int32_t v64 = v31 + v25; // 0x100f336
        char * v65 = (char *)(v62 & 255 | v60 & -256); // 0x100f33f
        *v65 = *v65 + (char)v62;
        int32_t v66 = __asm_iretd(); // 0x100f346
        int32_t v67 = *(int32_t *)(v5 - 13); // 0x100f34c
        int32_t v68 = v67 + v61; // 0x100f34c
        *(char *)v63 = *(char *)v64;
        function_100ed2b();
        int32_t v69 = v32 - 3; // 0x100f355
        unknown_11f0e4(v69);
        int32_t result2 = *(int32_t *)v69;
        if (((v68 ^ v61) & (v68 ^ v67)) >= 0) {
            // 0x100f285
            return result2;
        }
        // 0x100f368
        v2 = (int16_t)*(int32_t *)result2;
        unsigned char v70 = (char)(v5 / 128) & -2; // 0x100f37a
        if (v70 == 0) {
            // 0x100f37e
            return function_1007bd1();
        }
        int32_t v71 = 256 * (int32_t)v70 | v5 & -0xff01; // 0x100f37a
        v37 = (int32_t *)v71;
        v39 = v66;
        v41 = v68;
        v38 = v71;
        v43 = &v2;
        v42 = v64 + v30;
        v40 = v63 + v30;
    }
    int32_t v72 = v43;
    *(int32_t *)(v72 - 4) = unknown_458bffff();
    *(int32_t *)(v72 - 8) = v39;
    *(int32_t *)(v72 - 12) = v41;
    *(int32_t *)(v72 - 16) = v38;
    *(int32_t *)(v72 - 20) = v72;
    *(int32_t *)(v72 - 24) = v32 + 1;
    *(int32_t *)(v72 - 28) = v42;
    *(int32_t *)(v72 - 32) = v40;
    int32_t v73 = *v37; // 0x100f319
    return v73 + 127 & 255 | v73 & -256;
}

// Address range: 0x100f38a - 0x100f3cf
int32_t function_100f38a(int32_t a1) {
    // 0x100f38a
    int32_t v1; // 0x100f38a
    int32_t v2 = v1 & 124 | 131; // 0x100f38f
    int32_t v3 = v1 & -256; // 0x100f38f
    char * v4 = (char *)(v2 | v3); // 0x100f391
    *v4 = *v4 | (char)v2;
    int32_t v5; // 0x100f38a
    return (v3 | (int32_t)*(char *)&v5) - 1;
}

// Address range: 0x100f3cf - 0x100f3fb
int32_t function_100f3cf(void) {
    // 0x100f3cf
    int32_t v1; // 0x100f3cf
    char * v2 = (char *)(v1 + 86); // 0x100f3d4
    int32_t v3; // 0x100f3cf
    bool v4; // 0x100f3cf
    *v2 = (char)v4 + (char)v3 + *v2;
    int32_t v5; // bp-4, 0x100f3cf
    *(int32_t *)(v1 - 0x37b05b5) = (int32_t)&v5;
    __asm_in_1(-27);
    return function_1007cc4((int32_t)&g125);
}

// Address range: 0x100f3fb - 0x100f40a
int32_t function_100f3fb(int32_t a1) {
    // 0x100f3fb
    int32_t v1; // 0x100f3fb
    int32_t * v2 = (int32_t *)(v1 - 0x5674b884); // 0x100f3fd
    *v2 = *v2 - 1;
    int32_t v3; // 0x100f3fb
    char * v4 = (char *)(v3 - 0x74fc7430); // 0x100f403
    *v4 = *v4 | (char)v3;
    int32_t result; // 0x100f3fb
    return result;
}

// Address range: 0x100f40a - 0x100f40b
int32_t function_100f40a(int32_t a1) {
    // 0x100f40a
    int32_t result; // 0x100f40a
    return result;
}

// Address range: 0x100f40c - 0x100f413
int32_t function_100f40c(void) {
    // 0x100f40c
    return function_8cf0f39a();
}

// Address range: 0x100f42d - 0x100f432
int32_t function_100f42d(void) {
    // 0x100f42d
    return function_8ca6e773();
}

// Address range: 0x100f468 - 0x100f47a
int32_t function_100f468(void) {
    // 0x100f468
    int32_t v1; // 0x100f468
    char * v2 = (char *)v1; // 0x100f470
    *v2 = *v2 + (char)v1;
    return function_8ca6e77c();
}

// Address range: 0x100f47a - 0x100f50c
int32_t function_100f47a(void) {
    // 0x100f47a
    int32_t v1; // 0x100f47a
    int32_t v2; // 0x100f47a
    int32_t v3; // 0x100f47a
    __asm_rep_movsb_memcpy((char *)v1, (char *)v2, v3);
    bool v4; // 0x100f47a
    int32_t v5 = (v4 ? -1 : 1) * v3 + v1; // 0x100f47e
    int32_t v6; // bp-20, 0x100f47a
    int32_t v7; // 0x100f47a
    uint32_t v8 = unknown_ae7c60(&v6, v7); // 0x100f48b
    int32_t v9 = 0; // 0x100f496
    v9--;
    while (*(int32_t *)(v5 - 0x7ba76a9) != -0x7fff6400 && v9 != 0) {
        // 0x100f49c
        v9--;
    }
    int32_t v10 = *(int32_t *)(v7 - 0x7400009d); // 0x100f49c
    *(int32_t *)v9 = v8;
    *(int32_t *)(v5 + 4) = 159 * v8 / 256 + v8 & 255 | v8 & -0x10000;
    function_1007bd1();
    *(int32_t *)(v10 - 8) = function_1007c26();
    *(int32_t *)*(int32_t *)(v10 + 29) = v5;
    int32_t v11; // 0x100f47a
    int32_t v12 = *(int32_t *)(v11 - 117); // 0x100f4d2
    int32_t * v13 = (int32_t *)(*(int32_t *)*(int32_t *)v12 - 0x690cfd2a); // 0x100f4f7
    uint32_t v14 = *v13; // 0x100f4f7
    *v13 = v14 / 0x200000 | 2048 * v14;
    *(int32_t *)(v12 - 4) = v10 - 1;
    int32_t v15; // 0x100f47a
    __asm_into(v15);
    return function_b3e99cec();
}

// Address range: 0x100f50c - 0x100f538
int32_t function_100f50c(void) {
    // 0x100f50c
    int32_t v1; // 0x100f50c
    int32_t * v2 = (int32_t *)(v1 + 0x6050f845); // 0x100f50e
    *v2 = *v2 - 1;
    char * v3 = (char *)(v1 + 0x4408b03); // 0x100f515
    int32_t v4; // 0x100f50c
    *v3 = *v3 + (char)v4;
    int32_t v5; // 0x100f50c
    unsigned char v6 = (char)v5; // 0x100f526
    int32_t v7; // 0x100f50c
    int32_t v8; // 0x100f50c
    if ((v8 & 15) > 16 || (v6 & 14) > 9) {
        v7 = (v6 > 153 ? 154 : 250) + v5 & 255 | v5 & -256;
    } else {
        v7 = (v6 > 153 ? v5 + 160 : v5) & 255 | v5 & -256;
    }
    int32_t v9 = v7;
    int32_t v10; // 0x100f50c
    char * v11 = (char *)(4 * v1 + v10); // 0x100f527
    unsigned char v12 = (char)v9; // 0x100f527
    *v11 = *v11 ^ v12;
    int32_t v13; // 0x100f50c
    return (v9 + 189 & 255 | v9 & -256) + v13 + (int32_t)(v12 > 66);
}

// Address range: 0x100f538 - 0x100f579
int32_t function_100f538(void) {
    // 0x100f538
    int32_t v1; // 0x100f538
    int32_t v2 = v1 & 114 | 141; // 0x100f538
    char * v3 = (char *)(v2 | v1 & -256); // 0x100f53c
    *v3 = *v3 + (char)v2;
    int32_t v4 = __asm_wait(); // 0x100f540
    bool v5; // 0x100f538
    int32_t v6 = v5 ? -4 : 4; // 0x100f544
    int32_t v7; // 0x100f538
    int32_t v8; // 0x100f538
    int32_t v9 = v8 + v7 + v6; // 0x100f549
    int32_t v10; // 0x100f538
    *(char *)(v6 + v10) = *(char *)v9;
    int32_t v11; // 0x100f538
    int32_t v12 = v11 - 4; // 0x100f54c
    __asm_arpl(*(int16_t *)v12, (int16_t)(v9 + (v5 ? 0xffff : 1)));
    unknown_ac007be3();
    int32_t * v13 = (int32_t *)(v4 - 0x50003bb); // 0x100f55c
    *v13 = *v13 - 1;
    int32_t v14; // 0x100f538
    function_1007bc1((int32_t)&v14);
    int32_t * v15 = (int32_t *)*(int32_t *)v12; // 0x100f56a
    *v15 = *v15 & -13;
    int32_t v16 = *(int32_t *)v8; // 0x100f56d
    return v16 + 232 & 255 | v16 & -256;
}

// Address range: 0x100f579 - 0x100f5af
int32_t function_100f579(void) {
    // 0x100f579
    int32_t v1; // 0x100f579
    int32_t v2 = *(int32_t *)(v1 + 12); // 0x100f588
    int32_t v3 = v2 & 114 | 141; // 0x100f58b
    char v4 = v3; // 0x100f58d
    int32_t v5; // 0x100f579
    *(char *)v5 = v4;
    bool v6; // 0x100f579
    int32_t v7 = v6 ? -1 : 1; // 0x100f58d
    int32_t v8 = v7 + v5; // 0x100f58d
    int32_t v9; // 0x100f579
    char v10 = __asm_insb((int16_t)v9); // 0x100f58e
    char * v11 = (char *)v8; // 0x100f58e
    *v11 = v10;
    char * v12 = (char *)(v3 | v2 & -256); // 0x100f58f
    *v12 = *v12 + v4;
    int32_t v13 = v3 & 3; // 0x100f59a
    __asm_rep_movsb_memcpy(v11, (char *)v1, v13);
    int32_t * v14 = (int32_t *)(v8 - 0x79e817fc + v13 * v7); // 0x100f5a2
    *v14 = *v14 + 1;
    int32_t v15; // 0x100f579
    return *(int32_t *)(v15 - 4);
}

// Address range: 0x100f5af - 0x100f5cc
int32_t function_100f5af(void) {
    // 0x100f5af
    int32_t result; // 0x100f5af
    return result;
}

// Address range: 0x100f5d1 - 0x100f621
int32_t function_100f5d1(int32_t a1) {
    // 0x100f5d1
    int32_t v1; // 0x100f5d1
    int32_t v2 = v1 & -256; // 0x100f5d1
    int32_t v3; // 0x100f5d1
    int32_t v4; // 0x100f5d1
    int32_t * v5 = (int32_t *)(((v1 + 25 | 223) + v4 & 255 | v2) + v3); // 0x100f5e2
    *v5 = *v5 ^ 79;
    int32_t v6; // 0x100f5d1
    int32_t v7; // 0x100f5d1
    *(char *)v7 = *(char *)&v6;
    bool v8; // 0x100f5d1
    int32_t v9 = v8 ? -1 : 1; // 0x100f5e6
    int32_t v10 = v6 + v9; // 0x100f5e6
    int32_t result = v2 | (int32_t)*(char *)v10; // 0x100f5f2
    v6 = v10 + v9;
    int32_t * v11 = (int32_t *)(v3 - 0xff0b9b); // 0x100f5f3
    int32_t v12 = *v11; // 0x100f5f3
    int32_t v13 = v12 + result; // 0x100f5f3
    *v11 = v13;
    if (((v13 ^ v12) & (v13 ^ v1)) >= 0) {
        // 0x100f5fb
        return result;
    }
    int32_t v14 = __asm_hlt(); // 0x100f608
    char * v15 = (char *)v14; // 0x100f611
    *v15 = *v15 + (char)v14;
    *(int32_t *)(v7 - 1 + v9) = *(int32_t *)v6;
    return *(int32_t *)(a1 + 54);
}

// Address range: 0x100f627 - 0x100f62a
int32_t function_100f627(void) {
    // 0x100f627
    int32_t result; // 0x100f627
    return result;
}

// Address range: 0x100f63d - 0x100f642
int32_t function_100f63d(void) {
    // 0x100f63d
    int32_t v1; // 0x100f63d
    bool v2; // 0x100f63d
    return v1 + (int32_t)v2 & 255 | v1 & -256;
}

// Address range: 0x100f646 - 0x100f649
int32_t function_100f646(int32_t a1) {
    // 0x100f646
    int32_t result; // 0x100f646
    return result;
}

// Address range: 0x100f664 - 0x100f6b6
int32_t function_100f664(void) {
    // 0x100f664
    int32_t v1; // 0x100f664
    int32_t * v2 = (int32_t *)(v1 - 0x174e8924); // 0x100f664
    int32_t v3; // 0x100f664
    *v2 = *v2 + v3;
    int32_t v4; // 0x100f664
    __asm_into(v4);
    int32_t v5; // 0x100f664
    char * v6 = (char *)(v5 + 0x75ff3b66); // 0x100f66d
    *v6 = *v6 + (char)v3;
    int32_t v7; // 0x100f664
    *(int32_t *)(v7 - 4) = __asm_hlt() + 4;
    __asm_out_4(78, unknown_98014714());
    int32_t v8 = __asm_int1(); // 0x100f685
    int32_t v9 = v7 - 6; // 0x100f686
    int32_t v10 = (v9 | 107) + 104 & 119; // 0x100f68c
    int32_t v11 = v10 | v9 & -256; // 0x100f68c
    char * v12 = (char *)v11; // 0x100f68e
    char v13 = v10; // 0x100f68e
    *v12 = *v12 + v13;
    char * v14 = (char *)(v11 + 0x4ffc35ff); // 0x100f690
    *v14 = *v14 + v13;
    int32_t * v15 = (int32_t *)(*(int32_t *)(v1 + 68) + 2); // 0x100f696
    *v15 = *v15 + v11;
    int32_t v16 = v8 - 3; // 0x100f69b
    *(int32_t *)v16 = v1 + 78;
    unknown_1bb71a3c();
    int32_t v17; // 0x100f664
    int32_t v18 = v17 + 1; // 0x100f6a4
    while (v18 != 0) {
        // 0x100f677
        *(int32_t *)(v16 - 4) = *(int32_t *)(v1 - 4);
        __asm_out_4(78, unknown_98014714());
        v8 = __asm_int1();
        v9 = v16 - 6;
        v10 = (v9 | 107) + 104 & 119;
        v11 = v10 | v9 & -256;
        v12 = (char *)v11;
        v13 = v10;
        *v12 = *v12 + v13;
        v14 = (char *)(v11 + 0x4ffc35ff);
        *v14 = *v14 + v13;
        v15 = (int32_t *)(*(int32_t *)(v1 + 68) + 2);
        *v15 = *v15 + v11;
        v16 = v8 - 3;
        *(int32_t *)v16 = v1 + 78;
        unknown_1bb71a3c();
        v18++;
    }
    int32_t result = function_1012314((int32_t)&g125); // 0x100f6ab
    *(int32_t *)(v8 - 7) = *(int32_t *)(v1 + 74);
    return result;
}

// Address range: 0x100f6b6 - 0x100f6bd
int32_t function_100f6b6(void) {
    // 0x100f6b6
    return function_ffbf98e8();
}

// Address range: 0x100f71f - 0x100f72a
int32_t function_100f71f(int32_t a1) {
    // 0x100f71f
    int32_t result; // 0x100f71f
    return result;
}

// Address range: 0x100f730 - 0x100f734
int32_t function_100f730(void) {
    // 0x100f730
    int32_t result; // 0x100f730
    return result;
}

// Address range: 0x100f738 - 0x100f73f
int32_t function_100f738(int32_t a1, int32_t a2) {
    // 0x100f738
    int32_t result; // 0x100f738
    return result;
}

// Address range: 0x100f73f - 0x100f834
int32_t function_100f73f(void) {
    // 0x100f73f
    int32_t v1; // 0x100f73f
    int32_t v2 = *(int32_t *)(v1 - 0x74acaeaf); // 0x100f740
    int32_t * v3 = (int32_t *)v2; // 0x100f746
    int32_t v4; // 0x100f73f
    char * v5 = (char *)(v4 - 0x9cca93c); // 0x100f747
    int32_t v6; // 0x100f73f
    *v5 = *v5 | (char)v6;
    int32_t * v7 = (int32_t *)(*v3 - 4); // 0x100f74d
    int32_t v8; // 0x100f73f
    uint32_t v9; // 0x100f73f
    *(char *)v8 = *(char *)&v8 - (char)(v9 / 256);
    int32_t v10; // 0x100f73f
    *(int32_t *)v6 = *(int32_t *)(v10 + 4) + 1;
    int32_t v11 = v6 - 1; // 0x100f762
    int32_t v12 = *(int32_t *)0x1895704; // 0x100f764
    *(int32_t *)0x1895704 = v12 + *(int32_t *)(v1 - 0x77fe50f1);
    *v3 = *v7;
    int32_t v13; // 0x100f73f
    function_1007c30(v13);
    int32_t * v14 = (int32_t *)(v2 - 4); // 0x100f772
    *v14 = 117;
    *v7 = unknown_1c007c26();
    *(int32_t *)(v2 - 8) = v11;
    int32_t v15 = *v14; // 0x100f786
    int32_t v16 = *v3; // 0x100f786
    int32_t v17 = *(int32_t *)(v2 + 8); // 0x100f786
    int32_t * v18 = (int32_t *)(v2 + 20); // 0x100f786
    *(int32_t *)*v18 = v15;
    uint32_t v19 = *(int32_t *)v15; // 0x100f78b
    char v20 = *(char *)(v15 - 124); // 0x100f790
    int32_t v21 = 256 * (int32_t)(v20 & (char)(v19 / 256)) | v19 & -0x10000; // 0x100f790
    uint32_t v22 = *(int32_t *)(v16 - 66); // 0x100f795
    *(int32_t *)v22 = v21 | 255;
    int32_t v23 = *(int32_t *)(v6 - 0x3a742e76); // 0x100f79a
    char * v24 = (char *)(v21 | 143); // 0x100f7ab
    *v24 = *v24 - 113;
    __asm_rep_movsd_memcpy((char *)v11, (char *)v23, v22 / 4);
    int32_t * v25 = (int32_t *)((v22 & -4) + v11); // 0x100f7be
    *v25 = *v25 - 1;
    function_1007bc1((int32_t)&g125);
    int32_t v26 = *(int32_t *)(v16 - 3); // 0x100f7c6
    int32_t * v27 = (int32_t *)v26; // 0x100f7c9
    *v27 = *v27 + 4;
    *v18 = *(int32_t *)(v26 - 93);
    int32_t v28 = *(int32_t *)*(int32_t *)(v16 - 36); // 0x100f7da
    __writefsdword((int32_t)(*(char *)(v17 + 0x6e408b03) ^ 3) + 4, v26);
    int32_t v29 = *(int32_t *)(*(int32_t *)v17 + 4); // 0x100f7e2
    uint32_t v30 = *(int32_t *)(v29 + 4); // 0x100f7e5
    __asm_rep_movsb_memcpy((char *)v28, (char *)v29, v30 / 256 & 255 ^ v30);
    __asm_int1();
    abort();
    // UNREACHABLE
}

// Address range: 0x100f836 - 0x100f8b2
int32_t function_100f836(void) {
    // 0x100f836
    bool v1; // 0x100f836
    if (v1) {
        function_1012feb();
    }
    // 0x100f83e
    int32_t v2; // 0x100f836
    function_10054d1(*(int32_t *)(v2 - 4));
    int32_t v3; // 0x100f836
    unknown_73a5d1(v3);
    int32_t v4; // 0x100f836
    int32_t v5 = v2 ^ v4; // 0x100f853
    int32_t v6; // 0x100f836
    *(int32_t *)v3 = v6 + 1;
    int32_t v7 = (v3 & 0xff00) + v3 & 0xff00 | v3 & -0xff01; // 0x100f86c
    char * v8 = (char *)(v7 + 0xb8bffff); // 0x100f871
    *v8 = *(char *)(8 * v5 + v3) | (char)v3;
    int32_t v9; // 0x100f836
    *(int32_t *)v9 = v3 & -256 | (int32_t)*v8;
    int32_t * v10 = (int32_t *)(v7 + 1); // 0x100f883
    int32_t v11 = *v10; // 0x100f883
    int32_t v12 = *(int32_t *)v11; // 0x100f885
    char * v13 = (char *)v11; // 0x100f88c
    *v13 = *v13 + (char)v11;
    int32_t * v14 = (int32_t *)(v12 - 0x745acbfd); // 0x100f890
    *v14 = *v14 / 256;
    *(char *)v12 = *(char *)v6;
    *(int32_t *)v5 = *(int32_t *)(*v10 + 4);
    unknown_63000cc1(*(int32_t *)(v4 - 0x7600007d));
    return *(int32_t *)(v7 - 0x5efffb67) + __asm_wait();
}

// Address range: 0x100f8db - 0x100f8e0
int32_t function_100f8db(void) {
    // 0x100f8db
    return function_4ecdebe2();
}

// Address range: 0x100f8e0 - 0x100f8eb
int32_t function_100f8e0(void) {
    // 0x100f8e0
    int32_t v1; // 0x100f8e0
    int32_t v2; // 0x100f8e0
    int32_t v3; // 0x100f8e0
    __asm_rep_movsb_memcpy((char *)v1, (char *)v2, v3);
    return function_100fac3((int32_t)&g125, (int32_t)&g125);
}

// Address range: 0x100f926 - 0x100f959
int32_t function_100f926(int32_t a1) {
    // 0x100f926
    int32_t v1; // 0x100f926
    int32_t * v2 = (int32_t *)v1; // 0x100f926
    int32_t v3; // 0x100f926
    *v2 = v3 + v1;
    int32_t v4; // 0x100f926
    function_100be29(v4);
    while (function_1008d44() == 0) {
        // continue -> 0x100f936
    }
    int32_t v5 = __asm_iretd() ^ 42; // 0x100f940
    *v2 = v5 + v1;
    int32_t * v6 = (int32_t *)v5; // 0x100f94b
    *v6 = *v6 + v5;
    char * v7 = (char *)(v5 + 0x2d1ce8); // 0x100f94d
    *v7 = *v7 + (char)v1;
    int32_t result = v5; // 0x100f957
    int32_t v8; // 0x100f926
    if (v8 == v5) {
        result = function_100f8db();
    }
    // 0x100f959
    return result;
}

// Address range: 0x100f95a - 0x100f95d
int32_t function_100f95a(void) {
    // 0x100f95a
    int32_t result; // 0x100f95a
    return result;
}

// Address range: 0x100f95d - 0x100f965
int32_t function_100f95d(void) {
    int32_t result = unknown_80007b93(); // 0x100f95d
    int32_t v1; // 0x100f95d
    *(int32_t *)v1 = v1 - result;
    return result;
}

// Address range: 0x100f965 - 0x100f968
int32_t function_100f965(void) {
    // 0x100f965
    uint32_t v1; // 0x100f965
    int32_t v2; // 0x100f965
    return v1 / 256 & 255 ^ v2;
}

// Address range: 0x100f96a - 0x100f99f
int32_t function_100f96a(void) {
    // 0x100f96a
    int32_t v1; // 0x100f96a
    int32_t * v2 = (int32_t *)(v1 - 0x5ec739fd); // 0x100f96a
    *v2 = *v2 - 1;
    int32_t v3; // 0x100f96a
    int32_t v4; // 0x100f96a
    *(char *)(v3 + 1) = (char)v4;
    int32_t * v5 = (int32_t *)(v1 + 0x470ff00); // 0x100f973
    *v5 = *v5 + v4;
    int32_t v6; // 0x100f96a
    __asm_outsd(-0x7183, v6);
    int32_t * v7 = (int32_t *)(v1 + 0x14381bd); // 0x100f981
    int32_t v8; // 0x100f96a
    *v7 = *v7 + v8;
    int32_t v9; // 0x100f96a
    *(char *)v9 = *(char *)&v9 & 125;
    int16_t v10; // 0x100f96a
    unknown_c8d0c(v10);
    return function_8ca66c6b();
}

// Address range: 0x100f99f - 0x100fa4c
int32_t function_100f99f(void) {
    // 0x100f99f
    int32_t v1; // 0x100f99f
    int32_t v2; // 0x100f99f
    int32_t v3; // 0x100f99f
    __asm_rep_movsb_memcpy((char *)v1, (char *)v2, v3);
    int32_t v4; // 0x100f99f
    int32_t * v5 = (int32_t *)(v4 + 4); // 0x100f9a7
    function_1007bc1(*v5);
    *v5 = 0;
    return 0;
}

// Address range: 0x100fa4c - 0x100fa99
int32_t function_100fa4c(int32_t a1) {
    // 0x100fa4c
    int32_t v1; // 0x100fa4c
    int32_t v2 = v1 + 232 & 255 | v1 & -256; // 0x100fa4c
    int32_t v3; // 0x100fa4c
    *(int32_t *)(v3 + 4) = v2;
    uint32_t v4; // 0x100fa4c
    uint32_t v5 = v4 / 4; // 0x100fa6b
    __asm_rep_movsd_memcpy((char *)v2, (char *)v3, v5);
    bool v6; // 0x100fa4c
    char * v7 = (char *)(v2 + (v6 ? -4 : 4) * v5); // 0x100fa76
    __asm_rep_movsb_memcpy(v7, v7, 0);
    int32_t * v8 = (int32_t *)*(int32_t *)function_100bbd4(); // 0x100fa81
    *v8 = -*v8;
    int32_t v9; // 0x100fa4c
    *(int32_t *)(v9 - 4) = *(int32_t *)-0x7dcdb08e;
    unknown_935454();
    abort();
    // UNREACHABLE
}

// Address range: 0x100fa99 - 0x100fabd
int32_t function_100fa99(void) {
    // 0x100fa99
    int32_t v1; // 0x100fa99
    function_100f40a(v1);
    int32_t v2; // 0x100fa99
    *(int32_t *)v2 = v2 + v1;
    int32_t v3; // 0x100fa99
    int16_t v4; // 0x100fa99
    return function_100fac3((int32_t)v4, v3);
}

// Address range: 0x100fac3 - 0x100fad3
int32_t function_100fac3(int32_t a1, int32_t a2) {
    // 0x100fac3
    int32_t v1; // 0x100fac3
    int32_t v2; // 0x100fac3
    char * v3 = (char *)(v2 & -256 | v1 & 255); // 0x100faca
    int32_t v4; // 0x100fac3
    *v3 = *v3 & (char)v4;
    int32_t v5; // 0x100fac3
    return *(int32_t *)(v5 + 4);
}

// Address range: 0x100fad4 - 0x100fade
int32_t function_100fad4(void) {
    // 0x100fad4
    int32_t v1; // 0x100fad4
    char * v2 = (char *)(v1 + 91); // 0x100fad7
    int32_t v3; // 0x100fad4
    *v2 = *v2 + (char)v3;
    int32_t v4; // 0x100fad4
    return v4 & v3;
}

// Address range: 0x100fae4 - 0x100fae5
int32_t function_100fae4(int32_t a1) {
    // 0x100fae4
    int32_t result; // 0x100fae4
    return result;
}

// Address range: 0x100fb18 - 0x100fbb2
int32_t function_100fb18(void) {
    // 0x100fb18
    int32_t v1; // 0x100fb18
    int32_t v2 = 2 * v1; // 0x100fb22
    unknown_782cc1();
    int32_t v3; // 0x100fb18
    int32_t v4; // 0x100fb18
    if ((v2 ^ v1) < 0) {
        char * v5 = (char *)(v4 - 0x7af09202); // 0x100fb2e
        char v6 = v4; // 0x100fb2e
        *v5 = *v5 + v6;
        *(char *)v4 = *(char *)&v3 + v6;
        return unknown_47007bfb(*(int32_t *)(*(int32_t *)*(int32_t *)0x71016fa4 + 4));
    }
    // 0x100fb4e
    int32_t v7; // 0x100fb18
    *(int32_t *)v7 = v7 + v4;
    int32_t v8 = v3; // 0x100fb50
    int32_t v9; // 0x100fb18
    uint32_t v10 = *(int32_t *)(v9 + 10 + v4); // 0x100fb52
    v3 = v10;
    int32_t v11 = *(int32_t *)(v10 - 0x72f372d8) + v7; // 0x100fb56
    char * v12 = (char *)(v4 - 117); // 0x100fb5e
    *v12 = *v12 + (char)v11;
    *(int32_t *)v8 = v10 / 512 | 0x800000 * v10;
    unsigned char v13 = (char)v4 & -13; // 0x100fb64
    int32_t result = v4 & -256 | (int32_t)v13; // 0x100fb64
    *(int32_t *)v2 = v10;
    bool v14; // 0x100fb18
    int32_t v15 = v14 ? -4 : 4; // 0x100fb66
    int32_t v16 = v15 + v2; // 0x100fb66
    int32_t v17 = v8 + v15; // 0x100fb66
    int32_t v18 = v11 - 1; // 0x100fb6a
    if (v18 != 0 != (v13 == 0)) {
        // 0x100fb6c
        __asm_rep_movsb_memcpy((char *)v16, (char *)v17, v18);
        return result;
    }
    int32_t v19 = *(int32_t *)(result - 125); // 0x100fb67
    *(int32_t *)(result | 4) = v17;
    function_1007bc1(v16);
    *(int32_t *)(*(int32_t *)v3 + 50) = 0;
    int32_t v20 = g108; // 0x100fb7e
    int16_t v21 = v19; // 0x100fb85
    __asm_out(v21, g108);
    *(int32_t *)(v20 - 4) = *(int32_t *)v19;
    *(int32_t *)v16 = __asm_insd(v21);
    int32_t v22 = v20; // 0x100fb8e
    if (v18 != 0) {
        // 0x100fb90
        *(int32_t *)(v11 + 3) = v20;
        v22 = *(int32_t *)v3;
    }
    // 0x100fba0
    *(char *)*(int32_t *)(v22 + 4) = __asm_insb(v21);
    return function_8ca6eed3();
}

// Address range: 0x100fbb2 - 0x100fbbd
int32_t function_100fbb2(void) {
    // 0x100fbb2
    int32_t v1; // 0x100fbb2
    int32_t v2; // 0x100fbb2
    int32_t v3; // 0x100fbb2
    __asm_rep_movsb_memcpy((char *)v1, (char *)v2, v3);
    return function_193fc40();
}

// Address range: 0x100fbc3 - 0x100fbc4
int32_t function_100fbc3(int32_t a1) {
    // 0x100fbc3
    int32_t result; // 0x100fbc3
    return result;
}

// Address range: 0x100fbe8 - 0x100fbed
int32_t function_100fbe8(void) {
    // 0x100fbe8
    return function_8c94f711();
}

// Address range: 0x100fc04 - 0x100fc22
int32_t function_100fc04(void) {
    // 0x100fc04
    int32_t v1; // 0x100fc04
    char * v2 = (char *)(v1 + 1); // 0x100fc04
    int32_t v3; // 0x100fc04
    *v2 = *v2 ^ (char)v3;
    int32_t v4; // 0x100fc04
    int32_t * v5 = (int32_t *)(v4 + 0x70ff9f40); // 0x100fc07
    *v5 = *v5 + v3;
    int32_t result = unknown_8d00fb93(); // 0x100fc0f
    int32_t * v6 = (int32_t *)(*(int32_t *)(v3 - 0x7b51b2bf) | v3); // 0x100fc1b
    *v6 = *v6 + result;
    return result;
}

// Address range: 0x100fc23 - 0x100fc46
int32_t function_100fc23(int32_t a1, int32_t a2, int32_t a3) {
    int32_t v1 = unknown_1000b3f(); // 0x100fc29
    int32_t v2; // 0x100fc23
    int32_t v3; // 0x100fc23
    if (v3 != -*(int32_t *)(v2 + 0x304e5300)) {
        // 0x100fc30
        return *(int32_t *)v1;
    }
    // 0x100fc33
    __asm_int3();
    return unknown_2700bc54();
}

// Address range: 0x100fc62 - 0x100fc9c
int32_t function_100fc62(int16_t a1) {
    // 0x100fc62
    int32_t v1; // 0x100fc62
    int32_t * v2 = (int32_t *)(v1 - 0x44170b8b); // 0x100fc62
    *v2 = *v2 - 1;
    int32_t * v3 = (int32_t *)(v1 + 0x30fff445); // 0x100fc6a
    *v3 = *v3 - 1;
    unknown_3ca37b87();
    __asm_hlt();
    bool v4; // 0x100fc62
    if (v4) {
        // 0x100fd06
        int32_t v5; // 0x100fc62
        return *(int32_t *)(v5 - 0x17fb8f01);
    }
    // 0x100fc87
    int32_t v6; // 0x100fc62
    char * v7 = (char *)(*(int32_t *)(v6 + 37) + 0x458b044e); // 0x100fc91
    *v7 = *v7 ^ (char)*(int32_t *)(v6 - 12);
    return function_d953527();
}

// Address range: 0x100fc9c - 0x100fcc6
int32_t function_100fc9c(void) {
    // 0x100fc9c
    int32_t v1; // 0x100fc9c
    int32_t v2 = 2 * v1; // 0x100fc9c
    int32_t v3; // 0x100fc9c
    char * v4 = (char *)(v3 + 0x2e9c12f); // 0x100fca0
    *v4 = *v4 + (char)v2;
    int32_t v5; // 0x100fc9c
    int32_t v6; // 0x100fc9c
    __asm_rep_movsd_memcpy((char *)v5, (char *)v6, v2);
    bool v7; // 0x100fc9c
    char * v8 = (char *)((v7 ? -4 : 4) * v2 + v5); // 0x100fcad
    __asm_rep_movsb_memcpy(v8, v8, v1 & 3);
    int32_t v9; // 0x100fc9c
    function_1007bc1(*(int32_t *)((*(int32_t *)(v9 - 12) & v1) + 4));
    return v3 + 1;
}

// Address range: 0x100fcec - 0x100fcf1
int32_t function_100fcec(void) {
    // 0x100fcec
    return function_8ca61d96();
}

// Address range: 0x100fcfe - 0x100fd06
int32_t function_100fcfe(void) {
    // 0x100fcfe
    int32_t v1; // 0x100fcfe
    unsigned char v2 = (char)v1 & 31; // 0x100fcfe
    if (v2 != 0) {
        int32_t v3; // 0x100fcfe
        char * v4 = (char *)(v3 + 0x1fe8ffff); // 0x100fcfe
        *v4 = *v4 >> v2;
    }
    int32_t result; // 0x100fcfe
    return result;
}

// Address range: 0x100fd15 - 0x100fd1a
int32_t function_100fd15(void) {
    // 0x100fd15
    int32_t result; // 0x100fd15
    return result;
}

// Address range: 0x100fd2e - 0x100fdba
int32_t function_100fd2e(int32_t a1, int32_t a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6, int32_t a7) {
    // 0x100fd2e
    int32_t v1; // 0x100fd2e
    int32_t v2 = v1 - 1; // 0x100fd2e
    if (v2 == 0) {
        // 0x100fd30
        int32_t result; // 0x100fd2e
        return result;
    }
    // 0x100fdae
    return 4 * v2 - 0x2afffff4;
}

// Address range: 0x100fdbc - 0x100fe2b
int32_t function_100fdbc(int32_t result2) {
    // 0x100fdbc
    int32_t v1; // 0x100fdbc
    int32_t v2 = unknown_bf7bd1(v1); // 0x100fdc6
    int32_t v3; // 0x100fdbc
    char * v4 = (char *)(v3 + 0x7dff7e52); // 0x100fdce
    unsigned char v5 = *v4; // 0x100fdce
    *v4 = v5 + 92;
    unsigned char v6 = (char)v2; // 0x100fdd4
    bool v7 = v6 > 153 | v5 > 163;
    int32_t v8; // 0x100fdbc
    if ((v6 & 14) > 9 || (v5 & 12) != 0) {
        v8 = (v7 ? 154 : 250) + v2 & 255 | v2 & -256;
    } else {
        v8 = (v7 ? v2 + 160 : v2) & 255 | v2 & -256;
    }
    int32_t v9; // bp-4, 0x100fdbc
    if (&v9 >= NULL) {
        // 0x100fdd9
        unknown_e87b6f();
        __asm_in_1(48);
        int32_t result; // 0x100fdbc
        return result;
    }
    int32_t * v10 = (int32_t *)v8; // 0x100fe09
    *v10 = 512 * *v10;
    int32_t v11; // 0x100fdbc
    __asm_rep_movsb_memcpy((char *)(v11 + 4), (char *)(v3 + 4), v8 & 3);
    *(int32_t *)(result2 + 4) = 0;
    return result2;
}

// Address range: 0x100fe62 - 0x100fe6b
int32_t function_100fe62(void) {
    // 0x100fe62
    int32_t result; // 0x100fe62
    return result;
}

// Address range: 0x100fe87 - 0x100fe94
int32_t function_100fe87(void) {
    // 0x100fe87
    int32_t v1; // 0x100fe87
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x100fe87
    char * v3 = (char *)(v2 - 0x3e3e7408); // 0x100fe89
    int32_t v4; // 0x100fe87
    *v3 = *v3 + (char)v4;
    return function_8c3ef280();
}

// Address range: 0x100fea6 - 0x100fea7
int32_t function_100fea6(void) {
    // 0x100fea6
    int32_t result; // 0x100fea6
    return result;
}

// Address range: 0x100fee4 - 0x100fef9
int32_t function_100fee4(void) {
    // 0x100fee4
    uint32_t v1; // 0x100fee4
    uint32_t result; // 0x100fee4
    if (result >= v1) {
        // 0x100fef1
        return result;
    }
    int32_t result2 = result + 1; // 0x100feeb
    int32_t v2; // 0x100fee4
    *(int32_t *)(v2 + 60) = result2;
    return result2;
}

// Address range: 0x100fefb - 0x100fefe
int32_t function_100fefb(void) {
    // 0x100fefb
    int32_t v1; // 0x100fefb
    bool v2; // 0x100fefb
    bool v3 = v2 | (uint32_t)(v1 & 14) > 9; // 0x100fefd
    int32_t v4 = v3 ? v1 + 10 : v1; // 0x100fefd
    return v4 & 15 | v1 & -0x10000 | 256 * (int32_t)v3 + v1 & 0xff00;
}

// Address range: 0x100ff0b - 0x100ff7d
int32_t function_100ff0b(void) {
    int32_t v1 = __asm_in(168); // 0x100ff0f
    uint32_t v2; // 0x100ff0b
    char v3 = v2 / 256; // 0x100ff13
    if (v3 != -v3) {
        // 0x100ff81
        return v1 & -256;
    }
    // 0x100ff17
    int32_t v4; // 0x100ff0b
    unknown_290254(v4 - 8);
    int32_t * v5 = (int32_t *)(v4 - 4); // 0x100ff20
    if (unknown_93011a18(*(int32_t *)*v5) == 0) {
        // 0x100ff2e
        return *(int32_t *)(*(int32_t *)(*v5 + 4) - 33);
    }
    int32_t * v6 = (int32_t *)(v4 - 16); // 0x100ff62
    unknown_e8007bc1(*v6);
    *(int864_t *)(v4 - 12) = (int864_t)__asm_fnsave();
    *v6 = 0;
    return function_1007bd1();
}

// Address range: 0x100ff7e - 0x100ff81
int32_t function_100ff7e(void) {
    // 0x100ff7e
    int32_t result; // 0x100ff7e
    return result;
}

// Address range: 0x100ffea - 0x100fff0
int32_t function_100ffea(void) {
    // 0x100ffea
    int32_t result; // 0x100ffea
    return result;
}

// Address range: 0x100fffb - 0x101004b
int32_t function_100fffb(int32_t a1) {
    // 0x100fffb
    int32_t v1; // 0x100fffb
    char * v2 = (char *)(v1 + 0x4408bf4); // 0x100fffb
    int32_t v3; // 0x100fffb
    *v2 = *v2 + (char)v3;
    unknown_c4007baf();
    int32_t v4; // 0x100fffb
    *(int32_t *)(v4 - 96) = 0;
    function_1007bc1(v3);
    int32_t * v5 = (int32_t *)*(int32_t *)(v4 - 4); // 0x1010021
    *v5 = *v5 & -82;
    *(int32_t *)*(int32_t *)(v4 + 75) = *(int32_t *)g88;
    int32_t v6 = (int32_t)g88; // 0x1010038
    return v6 + 19 & 56 | v6 & 0x2a5a8d00;
}

// Address range: 0x101004b - 0x1010098
int32_t function_101004b(void) {
    // 0x101004b
    int32_t v1; // 0x101004b
    int32_t v2; // 0x101004b
    *(int32_t *)v1 = __asm_insd((int16_t)v2);
    int32_t v3; // 0x101004b
    char * v4 = (char *)(v3 - 117); // 0x101004c
    int32_t v5; // 0x101004b
    *v4 = *v4 + (char)v5;
    uint32_t v6; // 0x101004b
    uint32_t v7 = v6 / 0x800000; // 0x101004f
    int32_t v8 = v7 | 512 * v6; // 0x101004f
    unknown_b8fc7bc1(*(int32_t *)(*(int32_t *)(v5 - 0x5b0cfc1f) + 4), v3);
    int32_t v9; // 0x101004b
    *(int32_t *)(*(int32_t *)(v9 - 4) + 4) = 0;
    *(int32_t *)(v8 + 4) = *(int32_t *)-0x3b27401;
    *(char *)0x70ff03d3 = (char)v7;
    int32_t * v10 = (int32_t *)(v5 + 0x38b0471); // 0x1010088
    *v10 = *v10 + v8;
    return function_8de27876();
}

// Address range: 0x101009f - 0x10100a4
int32_t function_101009f(void) {
    // 0x101009f
    return function_8ca6f40c();
}

// Address range: 0x10100db - 0x10101a9
int32_t function_10100db(void) {
    // 0x10100db
    int32_t v1; // 0x10100db
    int32_t * v2 = (int32_t *)v1; // 0x10100db
    *v2 = 0;
    int32_t v3 = function_1007c26(); // 0x10100de
    *v2 = v3;
    function_1007bc1(*(int32_t *)v3);
    int32_t v4; // 0x10100db
    int32_t v5 = v4 + v1; // 0x10100f4
    *(int32_t *)v4 = v5;
    int32_t v6; // 0x10100db
    int32_t v7; // 0x10100db
    bool v8; // 0x10100db
    if (v5 < 0 != ((v5 ^ v4) & (v5 ^ v1)) < 0) {
        // 0x10100fa
        int32_t v9; // 0x10100db
        int32_t v10 = v9 - 1; // 0x10100f3
        int32_t v11 = *(int32_t *)(v4 + 0x63817601) | v4; // 0x1010101
        int32_t * v12 = (int32_t *)v11; // 0x1010107
        *v12 = *v12 - 0x74ab0086;
        int32_t v13 = *(int32_t *)-0x74ab0086; // 0x1010109
        uint32_t v14 = *(int32_t *)(v1 - 0x98472c8) + v11; // 0x101010f
        *(char *)-0x74ab00fb = *(char *)-0x74ab00fb + 5;
        *(int32_t *)v10 = *(int32_t *)v13;
        int32_t v15 = v14 / 4 - 1; // 0x1010123
        if (v15 != 0 != v14 < 4) {
            int32_t v16 = (int32_t)*(char *)((v14 & 255) + v1); // 0x101011e
            return (v14 & -256 | v16) / 8 | 0x20000000 * v16;
        }
        int32_t v17 = v8 ? -4 : 4; // 0x101011f
        int32_t v18 = v17 + v10; // 0x101011f
        int32_t v19 = 2 * v18; // 0x1010128
        if ((v19 ^ v18) < 0) {
            int32_t * v20 = (int32_t *)(v7 - 4); // 0x101018b
            *(int32_t *)-0x74ab008a = *v20;
            unknown_87007b9c();
            *v20 = 0;
            *(int32_t *)(v7 - 128) = unknown_507c26();
            return *v20;
        }
        // 0x101012c
        *(int32_t *)-0x74ab008a = function_1007bc1((int32_t)&g125);
        *(int32_t *)-0x74ab008e = v15;
        int32_t v21; // 0x10100db
        *(int32_t *)-0x74ab0092 = *(int32_t *)((v21 & -0xff01 | 0xd300) - 125);
        *(int32_t *)-0x74ab009a = -0x74ab0086;
        *(int32_t *)-0x74ab00a2 = v13 + v17;
        *(int32_t *)-0x74ab00a6 = v19;
        int32_t v22 = *(int32_t *)0x10155a8; // 0x1010137
        int32_t * v23 = (int32_t *)(v22 + 4); // 0x101013c
        int32_t v24 = *v23 - v22; // 0x101013c
        char v25 = llvm_ctpop_i8((char)v24); // 0x101013c
        *v23 = v24;
        *(int32_t *)(v1 + 4) = __asm_int3();
        int32_t result = *(int32_t *)0x11b4f87; // 0x101014c
        if ((v25 & 1) != 0) {
            // 0x1010159
            return result;
        }
        int32_t v26 = *(int32_t *)(result + 4); // 0x1010151
        int32_t v27 = 4 * *(int32_t *)(v26 + 4) + 0x6700000c; // 0x101015c
        __asm_rep_movsd_memcpy((char *)v19, (char *)v26, v27 / 2048);
        v6 = v27;
    }
    int32_t v28 = v6;
    int32_t v29 = *(int32_t *)(v28 & 3 | -0x5017da04) | v28; // 0x1010171
    char v30 = llvm_ctpop_i8((char)v29); // 0x1010171
    bool v31; // 0x10100db
    bool v32; // 0x10100db
    bool v33; // 0x10100db
    *(int32_t *)-0x57afd805 = 0x4000 * (int32_t)v31 | 1024 * (int32_t)v8 | 512 * (int32_t)v32 | 256 * (int32_t)v33 | 64 * (int32_t)(v29 == 0) | 128 * (int32_t)(v29 < 0) | 4 * (int32_t)((v30 & 1) == 0) | 2;
    function_1007bd1();
    int32_t * v34 = (int32_t *)(v7 - 4); // 0x1010182
    *v34 = *v34 & -22;
    return function_101028c();
}

// Address range: 0x10101d3 - 0x10101d8
int32_t function_10101d3(void) {
    // 0x10101d3
    return function_8ca6f4da();
}

// Address range: 0x10101f8 - 0x1010220
int32_t function_10101f8(void) {
    // 0x10101f8
    int32_t v1; // 0x10101f8
    bool v2; // 0x10101f8
    if (v2) {
        v1 = function_10101f8();
    }
    // 0x10101fa
    int32_t v3; // 0x10101f8
    int32_t * v4 = (int32_t *)(v3 + 0x4189fc4d); // 0x10101fc
    *v4 = *v4 - 1;
    unsigned char v5 = (char)v1; // 0x1010202
    char v6 = v5 - 117 + (v5 > 116 ? 116 : 117); // 0x1010204
    if (v6 >= 0) {
        // 0x1010208
        return v1 & -256 | (int32_t)v6;
    }
    char * v7 = (char *)(v1 / 2 | 255); // 0x1010216
    *v7 = *v7 - 1;
    int32_t v8; // 0x10101f8
    int32_t v9; // 0x10101f8
    __asm_out_2((int16_t)v8, v9);
    return function_8ca6f522();
}

// Address range: 0x101023b - 0x1010280
int32_t function_101023b(void) {
    // 0x101023b
    function_100bc54();
    int32_t v1; // 0x101023b
    int32_t v2; // 0x101023b
    function_10062d1(v2, *(int32_t *)(v1 - 54), v1 - 70, *(int32_t *)-0x9feb070);
    unknown_6b7bd1(*(int32_t *)(v1 - 4));
    *(int32_t *)(v1 - 57) = 0;
    int32_t v3; // 0x101023b
    int32_t v4; // 0x101023b
    *(int32_t *)v3 = __asm_insd((int16_t)v4);
    function_100f73f();
    int32_t v5; // 0x101023b
    int32_t v6 = *(int32_t *)(v5 + 0x4d8b008b); // 0x101026a
    char * v7 = (char *)(v5 - 0x3dfc0e62); // 0x1010270
    *v7 = *v7 | (char)v5;
    int32_t v8 = v6 + 200; // 0x1010277
    int32_t result = v6 + 1 & -256 | v8 & 255; // 0x1010277
    *(char *)v5 = *(char *)&v5 + (char)v8;
    char * v9 = (char *)result; // 0x101027b
    *v9 = *v9 + (char)(v5 / 256);
    return result;
}

// Address range: 0x101028c - 0x1010312
int32_t function_101028c(void) {
    // 0x101028c
    int32_t v1; // 0x101028c
    int32_t v2 = function_1008d7b(v1, (int32_t)g96); // 0x101029b
    int32_t v3 = 0; // 0x10102a2
    if (v2 != 0) {
        // 0x10102a4
        v3 = unknown_6f008858(v1, *(int32_t *)0x1bd4fa4);
    }
    int32_t result = v3;
    if (v2 >= 0 != v2 != 0) {
        // 0x10102b3
        *(int32_t *)v1 = result;
        return result;
    }
    int32_t result2 = result + 232 & 255 | result & -256; // 0x101030e
    __asm_out_4(214, result2);
    return result2;
}

// Address range: 0x1010313 - 0x1010332
int32_t function_1010313(int16_t a1) {
    // 0x1010313
    int32_t v1; // 0x1010313
    int32_t * v2 = (int32_t *)(v1 - 0x6ef274fd); // 0x1010313
    *v2 = *v2 - 1;
    int32_t v3; // 0x1010313
    char * v4 = (char *)(v3 - 0x3e3e7408); // 0x1010327
    *v4 = *v4 + (char)v1;
    return function_8ca6f670();
}

// Address range: 0x1010353 - 0x10103d3
int32_t function_1010353(int32_t a1, int32_t a2) {
    // 0x1010353
    int32_t v1; // 0x1010353
    int32_t * v2 = (int32_t *)(v1 + 0xd8f0443); // 0x1010353
    *v2 = *v2 - 1;
    int32_t v3; // 0x1010353
    int32_t * v4 = (int32_t *)(v3 - 117); // 0x101035e
    int32_t v5; // 0x1010353
    bool v6; // 0x1010353
    *v4 = v5 + (int32_t)v6 + *v4;
    int32_t v7; // 0x1010353
    __asm_out_4(4, v7 & -256 | (int32_t)*(char *)-0x74fefeb1);
    int32_t v8 = a1 & 114 | 141; // 0x1010364
    int32_t v9 = v8 | a1 & -256; // 0x1010366
    char * v10 = (char *)v9; // 0x1010368
    *v10 = *v10 + (char)v8;
    int32_t v11 = v9 + 0x1f16403f; // 0x101036c
    __asm_rep_movsd_memcpy(v10, (char *)v3, v1);
    int32_t * v12 = (int32_t *)v11; // 0x1010375
    *v12 = *v12 | -67;
    bool v13; // 0x1010353
    char * v14 = (char *)((v13 ? -4 : 4) * v1 + v9); // 0x1010378
    __asm_rep_movsb_memcpy(v14, v14, v11);
    unknown_27547c26();
    return __asm_int1();
}

// Address range: 0x10103d3 - 0x1010447
int32_t function_10103d3(void) {
    // 0x10103d3
    int32_t v1; // 0x10103d3
    uint32_t v2 = 4 * v1 + 12; // 0x10103f0
    char * v3 = (char *)(v1 + 0x48a9458b); // 0x1010403
    int32_t v4; // 0x10103d3
    int32_t v5; // 0x10103d3
    int32_t v6 = *(int32_t *)((v4 & -256 | (int32_t)__asm_in_3((int16_t)v5)) - 53); // 0x10103eb
    char * v7 = (char *)(v6 - 0x5f1e7c38); // 0x10103fc
    *v7 = *v7 & (char)(v2 / 4);
    char v8 = *v3 | (char)v6; // 0x1010403
    *v3 = v8;
    int32_t * v9; // 0x101040f
    if (v8 == 0) {
        // 0x101040f
        v9 = (int32_t *)(v6 + 0x6083f817);
        *v9 = *v9 - 1;
    }
    int32_t * v10 = (int32_t *)(v6 + 0x41896010); // 0x1010423
    *v10 = *v10 - 1;
    unsigned char v11 = *(char *)(v6 + 88) - 117 ^ -117; // 0x1010434
    while (v11 < 0) {
        // 0x10103e5
        v6 = *(int32_t *)((v2 & -256 | (int32_t)v11) - 53);
        v7 = (char *)(v6 - 0x5f1e7c38);
        *v7 = *v7 & (char)(v2 / 4);
        v8 = *v3 | (char)v6;
        *v3 = v8;
        if (v8 == 0) {
            // 0x101040f
            v9 = (int32_t *)(v6 + 0x6083f817);
            *v9 = *v9 - 1;
        }
        // 0x101041e
        v10 = (int32_t *)(v6 + 0x41896010);
        *v10 = *v10 - 1;
        v11 = *(char *)(v6 + 88) - 117 ^ -117;
    }
    // 0x1010438
    return function_8ca6f749();
}

// Address range: 0x1010458 - 0x101049a
int32_t function_1010458(void) {
    int32_t v1 = unknown_57007c26(); // 0x1010458
    int32_t v2; // 0x1010458
    char * v3 = (char *)(v2 + 51); // 0x1010461
    *v3 = *v3 - 49;
    int32_t v4; // 0x1010458
    *(int32_t *)(v4 - 4) = v1 & -256;
    int32_t v5; // 0x1010458
    int32_t v6 = unknown_13007c4c(v5); // 0x1010469
    int32_t v7; // 0x1010458
    unsigned char v8 = (char)v7 & 31; // 0x1010476
    if (v8 != 0) {
        char * v9 = (char *)(9 * v5); // 0x1010476
        *v9 = *v9 >> v8;
    }
    int32_t v10; // 0x1010458
    int32_t v11 = v10 & -0xff01; // 0x1010472
    int32_t v12 = v6 + v4; // 0x1010474
    int32_t * v13 = (int32_t *)((v11 | 0x8900) + 0x4189fc76); // 0x1010479
    *v13 = *v13 - 1;
    *(int32_t *)v5 = v12 + 183 & 255 | v12 & -256;
    uint32_t v14; // 0x1010458
    unsigned char v15 = (char)(v14 / 256) - 119; // 0x1010484
    bool v16 = v15 < 137;
    unsigned char v17 = (char)((256 * (int32_t)v15 | v11) / 256); // 0x1010486
    char v18 = v16; // 0x1010486
    unsigned char v19 = v17 + v18; // 0x1010486
    unsigned char v20 = (char)v16; // 0x1010486
    bool v21 = v16 ? v20 - v18 > v17 | v19 != -1 : v19 > v17; // 0x1010486
    while (v16) {
        // 0x1010486
        v16 = v21;
        v17 = (char)(256 * (int32_t)v20 / 256);
        v18 = v16;
        v19 = v17 + v18;
        v20 = (char)v16;
        v21 = v16 ? v20 - v18 > v17 | v19 != -1 : v19 > v17;
    }
    // 0x101048a
    unknown_c9987bd1();
    bool v22; // 0x1010458
    *(int32_t *)(v4 - 3) = (v22 ? -4 : 4) + v5;
    return function_1007c26();
}

// Address range: 0x1010515 - 0x101051a
int32_t function_1010515(void) {
    // 0x1010515
    return function_8c02f81c();
}

// Address range: 0x1010535 - 0x1010607
int32_t function_1010535(void) {
    // 0x1010535
    int32_t v1; // 0x1010535
    int32_t v2; // 0x1010535
    int32_t result; // 0x1010535
    if ((llvm_ctpop_i8((char)(v2 - v1)) & 1) == 0) {
        // 0x1010539
        return result;
    }
    // 0x10105af
    bool v3; // 0x1010535
    int16_t v4 = v3 ? -4 : 4; // 0x1010535
    int32_t v5 = v1 & -0x10000 | (int32_t)(v4 + (int16_t)v1); // 0x1010535
    int32_t v6 = result & 3; // 0x10105b6
    __asm_rep_movsb_memcpy((char *)v5, (char *)((v2 & -0x10000 | (int32_t)(v4 + (int16_t)v2)) + 1), v6);
    int32_t v7 = v5 + (v3 ? -1 : 1) * v6; // 0x10105b9
    int32_t v8; // 0x1010535
    int32_t * v9 = (int32_t *)(v8 - 12); // 0x10105bb
    function_10091c1(*v9);
    *v9 = 0;
    function_10089fb(*(int32_t *)(g85 + 4));
    int32_t * v10 = (int32_t *)v7; // 0x10105d4
    uint32_t v11; // 0x1010535
    __asm_outsd((int16_t)v11, *v10);
    int32_t v12 = v3 ? -4 : 4; // 0x10105d5
    int32_t v13 = v7 + v12; // 0x10105d5
    __asm_arpl(*(int16_t *)(v7 + 1), 0);
    uint32_t v14 = __asm_hlt(); // 0x10105dc
    uint32_t v15 = *(int32_t *)(v11 - 117); // 0x10105e7
    *v10 = *(int32_t *)v13;
    int32_t v16; // 0x1010535
    int32_t result2 = (char)(v11 / 256) != -(char)v16 | (v15 / 0x800000 | 512 * v15) != 1 != ((char)(v11 / 256) == -(char)v16) ? v14 / 8 | 0x20000000 * v14 : v13 + v12;
    return result2;
}

// Address range: 0x101065c - 0x10106fa
int32_t function_101065c(void) {
    // 0x101065c
    int32_t v1; // 0x101065c
    if ((v1 & 0xff00) != 0) {
        while (true) {
            // 0x101066f
            int32_t v2; // 0x101065c
            int32_t v3 = v2 - 4; // 0x101066f
            int32_t v4; // 0x101065c
            *(int32_t *)v3 = v4;
            v2 = v3;
            v4 = unknown_1db1a3c();
        }
    }
    // 0x101067b
    int32_t v5; // 0x101065c
    int32_t v6 = v5 + 0xf5084c0; // 0x101067b
    char * v7 = (char *)v6; // 0x1010682
    *v7 = *v7 + (char)v6;
    int32_t v8; // 0x101065c
    unsigned char v9 = *(char *)(v8 + 8); // 0x1010684
    uint32_t v10 = v8 - 4; // 0x1010687
    int32_t v11; // 0x101065c
    *(int32_t *)(v11 - 4) = v10;
    uint32_t v12; // 0x101065c
    int32_t v13 = 256 * (v10 / 256 + v10 + (int32_t)(v9 < (char)(v12 / 256))) & 0xff00 | v10 & -0xff01; // 0x101068b
    *(int32_t *)(v11 - 8) = *(int32_t *)(v13 + 0x3004081d);
    bool v14; // 0x101065c
    char * v15 = (char *)((v14 ? -4 : 4) + v12); // 0x10106a0
    *v15 = *v15 | (char)v12;
    *(int32_t *)(v11 - 14) = v13 & -256 | v8 + 135 & 255;
    char * v16 = (char *)(v1 - 0x44aed4f7); // 0x10106a6
    int32_t v17; // 0x101065c
    *v16 = *v16 | (char)v17 + 1;
    int32_t v18 = *(int32_t *)((v17 & -0xff01 | 0xb100) + 5); // 0x10106af
    if ((v12 + -1 - v18) * (int32_t)g75 <= *(int32_t *)0x72014f5c) {
        // 0x10106c5
        if (*(int32_t *)0x49014f58 == 0) {
            function_480105fc();
        }
    }
    // 0x10106d2
    *(int32_t *)(v11 - 18) = *(int32_t *)(v8 + 78);
    unknown_1f00353f();
    *(int32_t *)(v11 - 22) = *(int32_t *)(v8 - 9);
    abort();
    // UNREACHABLE
}

// Address range: 0x1010706 - 0x1010711
int32_t function_1010706(void) {
    // 0x1010706
    int32_t v1; // 0x1010706
    int32_t * v2 = (int32_t *)(v1 + 0x389fca1); // 0x1010706
    *v2 = *v2 - 1;
    return function_10107ed((int32_t)&g125, (int32_t)&g125);
}

// Address range: 0x101073c - 0x1010744
int32_t function_101073c(void) {
    // 0x101073c
    int32_t result; // 0x101073c
    return result;
}

// Address range: 0x101076a - 0x101076d
int32_t function_101076a(void) {
    // 0x101076a
    int32_t v1; // 0x101076a
    return v1 + 232 & 255 | v1 & -256;
}

// Address range: 0x10107a2 - 0x10107a7
int32_t function_10107a2(void) {
    // 0x10107a2
    return function_8ca6faa9();
}

// Address range: 0x10107c0 - 0x10107c1
int32_t function_10107c0(void) {
    // 0x10107c0
    int32_t result; // 0x10107c0
    return result;
}

// Address range: 0x10107ed - 0x10107fc
int32_t function_10107ed(int32_t a1, int32_t a2) {
    // 0x10107ed
    return function_1007bd1();
}

// Address range: 0x10107fc - 0x101091e
int32_t function_10107fc(int32_t a1) {
    // 0x10107fc
    int32_t v1; // 0x10107fc
    char * v2 = (char *)(v1 + 87); // 0x1010802
    uint32_t v3; // 0x10107fc
    char v4 = v3; // 0x1010802
    *v2 = *v2 | v4;
    int32_t v5 = function_1008f17(); // 0x101080d
    int32_t v6; // 0x10107fc
    char * v7 = (char *)(v6 + v3); // 0x1010816
    *v7 = (char)(v3 / 256);
    int32_t v8; // 0x10107fc
    *(int32_t *)v8 = (v5 + 21 & 255 | v5 & -256) + v8;
    int32_t v9 = v6 + 8; // 0x101081b
    *(int32_t *)v9 = -0x7fffffff;
    function_1012670(v9);
    int32_t v10 = 0; // bp-24, 0x101082d
    int32_t v11 = &v10; // 0x101082d
    *(int32_t *)(unknown_5f007bc1() + 4) = 0;
    int32_t v12; // 0x10107fc
    int32_t v13 = *(int32_t *)(v12 - 36); // 0x1010893
    int32_t v14 = v13 + 232; // 0x1010898
    int32_t v15 = v14 & 255 | v13 & -256; // 0x1010898
    int32_t v16; // 0x10107fc
    *(char *)v16 = (char)v14;
    int32_t * v17 = (int32_t *)(v12 - 0x49764ab3); // 0x101089d
    *v17 = *v17 - 1;
    int32_t v18 = *(int32_t *)(v12 - 115); // 0x10108a6
    int32_t v19 = *(int32_t *)((256 * (int32_t)*v7 | v3 & -0xff01) + 0x4782808); // 0x10108ac
    int32_t v20 = v12 & 32 | 223; // 0x10108b5
    char * v21 = (char *)(v20 | v12 & -256); // 0x10108b7
    *v21 = *v21 + (char)v20;
    char v22 = *(char *)v18; // 0x10108b9
    bool v23; // 0x10107fc
    int32_t v24 = v18 + (v23 ? -1 : 1); // 0x10108b9
    *(int32_t *)v15 = *(int32_t *)v24;
    int32_t v25 = v23 ? -4 : 4; // 0x10108bf
    __asm_rep_movsb_memcpy((char *)(v15 + v25), (char *)(v24 + v25), (int32_t)(v22 & 3 ^ 1));
    *(int32_t *)(v11 - 4) = *(int32_t *)v19;
    *(int32_t *)(v11 - 8) = v9;
    unknown_e28fbbd4();
    *(int32_t *)(v11 - 12) = *(int32_t *)0x79013888;
    *(int32_t *)(v11 - 16) = v9;
    int32_t v26 = unknown_26be29(); // 0x10108dc
    int32_t v27 = v11 - 20; // 0x10108e1
    *(int32_t *)v27 = *(int32_t *)0x1085d27;
    char * v28 = (char *)(v26 + 20); // 0x10108e9
    *v28 = *v28 | v4;
    *(int32_t *)(v11 - 24) = v27;
    uint32_t v29 = __asm_iretd(); // 0x10108ee
    *(int32_t *)(v11 - 30) = v19;
    return 91 * v29 / 256 + v29 & 255 | v29 & -0x10000;
}

// Address range: 0x101091f - 0x1010996
float80_t function_101091f(void) {
    // 0x101091f
    int32_t v1; // 0x101091f
    int32_t * v2 = (int32_t *)(v1 - 0x117038b); // 0x101091f
    *v2 = *v2 - 1;
    float80_t result; // 0x101091f
    bool v3; // 0x101091f
    if (!v3) {
        int32_t * v4 = (int32_t *)(v1 + 0x307ffca2); // 0x1010927
        *v4 = *v4 - 1;
        return result;
    }
    // 0x1010963
    int32_t v5; // 0x101091f
    int32_t v6; // 0x101091f
    __asm_rep_movsb_memcpy((char *)v5, (char *)(v6 - 1), v1);
    if ((v6 & -v6) >= 0) {
        // 0x1010972
        return result;
    }
    // 0x1010976
    __asm_int3();
    int32_t v7; // 0x101091f
    int32_t * v8 = (int32_t *)(v7 + 0x1edfc20); // 0x1010945
    *v8 = *v8 - 1;
    return result / (float80_t)(float32_t)v7;
}

// Address range: 0x101099c - 0x10109ff
int32_t function_101099c(void) {
    // 0x101099c
    uint32_t v1; // 0x101099c
    int32_t v2 = *(int32_t *)(v1 + 4); // 0x101099c
    *(char *)v1 = 2 * (char)v1;
    uint32_t v3 = v1 / 2;
    int32_t v4 = v3 & 0x3fffffff; // 0x10109a8
    *(char *)(v2 + 1) = (char)v3;
    int32_t v5; // 0x101099c
    int32_t * v6 = (int32_t *)(v5 - 0x17af03bb); // 0x10109b9
    *v6 = *v6 + v4;
    __asm_bound(*(int64_t *)(v4 + 0x3235abff + 8 * v2));
    __asm_iretd();
    int32_t v7; // 0x101099c
    *(int32_t *)v7 = v7 + v5;
    function_1007ac8();
    int32_t v8 = unknown_62bd6f(v7, *(int32_t *)(v5 - 4)); // 0x10109d3
    char * v9 = (char *)v8; // 0x10109da
    *v9 = (*v9 | (char)v8) + (char)v7;
    function_100dfef();
    int32_t v10 = __asm_sysexit(); // 0x10109e4
    int32_t * v11 = (int32_t *)v4; // 0x10109e8
    *v11 = *v11 + v10;
    unknown_e800bd0b(v7);
    int32_t v12; // 0x101099c
    return unknown_83007bd1(*(int32_t *)((v12 & -256 | 131) - 4));
}

// Address range: 0x10109ff - 0x1010a16
int32_t function_10109ff(void) {
    // 0x10109ff
    uint32_t v1; // 0x10109ff
    *(char *)0xb744819 = *(char *)0xb744819 + (char)(v1 / 256);
    int32_t v2; // 0x10109ff
    return v2 - 1;
}

// Address range: 0x1010a16 - 0x1010a21
int32_t function_1010a16(int32_t a1) {
    // 0x1010a16
    function_10091ec(a1);
    return function_1010a30();
}

// Address range: 0x1010a21 - 0x1010a30
int32_t function_1010a21(void) {
    // 0x1010a21
    int32_t v1; // 0x1010a21
    return function_10090d7(*(int32_t *)(v1 - 57), *(int32_t *)0x1884f1e);
}

// Address range: 0x1010a30 - 0x1010a33
int32_t function_1010a30(void) {
    // 0x1010a30
    int32_t result; // 0x1010a30
    return result;
}

// Address range: 0x1010a4a - 0x1010a4b
int32_t function_1010a4a(void) {
    // 0x1010a4a
    int32_t result; // 0x1010a4a
    return result;
}

// Address range: 0x1010a51 - 0x1010a52
int32_t function_1010a51(void) {
    // 0x1010a51
    int32_t result; // 0x1010a51
    return result;
}

// Address range: 0x1010a5f - 0x1010a90
int32_t function_1010a5f(int16_t a1, int32_t a2) {
    // 0x1010a5f
    int32_t result; // 0x1010a5f
    bool v1; // 0x1010a5f
    if (v1) {
        // 0x1010a61
        int32_t v2; // 0x1010a5f
        int32_t * v3 = (int32_t *)(v2 + 0x5d8b8aef); // 0x1010a61
        *v3 = *v3 - 1;
        return result;
    }
    int32_t v4 = result & 138 | 117; // 0x1010a8a
    int32_t v5 = v4 | result & -256; // 0x1010a8a
    char * v6 = (char *)v5; // 0x1010a8c
    char v7 = *v6; // 0x1010a8c
    char v8 = v4; // 0x1010a8c
    char v9 = v7 + v8; // 0x1010a8c
    *v6 = v9;
    int32_t result2 = v5; // 0x1010a8e
    if (v9 < 0 == ((v9 ^ v7) & (v9 ^ v8)) < 0 == (v9 != 0)) {
        result2 = function_1010a51();
    }
    // 0x1010a90
    return result2;
}

// Address range: 0x1010aa5 - 0x1010aa7
int32_t function_1010aa5(void) {
    // 0x1010aa5
    int32_t result; // 0x1010aa5
    return result;
}

// Address range: 0x1010ab0 - 0x1010ab2
int32_t function_1010ab0(void) {
    // 0x1010ab0
    return function_1010a4a();
}

// Address range: 0x1010ab5 - 0x1010abc
int32_t function_1010ab5(void) {
    // 0x1010ab5
    int32_t v1; // 0x1010ab5
    return (v1 + 232 & 255 | v1 & -256) + 1;
}

// Address range: 0x1010ad9 - 0x1010ade
int32_t function_1010ad9(void) {
    // 0x1010ad9
    return function_8ca6fde0();
}

// Address range: 0x1010b1b - 0x1010b1d
int32_t function_1010b1b(void) {
    // 0x1010b1b
    int32_t result; // 0x1010b1b
    return result;
}

// Address range: 0x1010b5d - 0x1010b62
int32_t function_1010b5d(void) {
    // 0x1010b5d
    return function_15a6fe64();
}

// Address range: 0x1010ba5 - 0x1010baa
int32_t function_1010ba5(void) {
    // 0x1010ba5
    return function_66a618ac();
}

// Address range: 0x1010bb2 - 0x1010bb5
int32_t function_1010bb2(void) {
    // 0x1010bb2
    int32_t result; // 0x1010bb2
    return result;
}

// Address range: 0x1010bf8 - 0x1010bfd
int32_t function_1010bf8(void) {
    // 0x1010bf8
    return function_8ca6feff();
}

// Address range: 0x1010c0d - 0x1010c58
int32_t function_1010c0d(void) {
    // 0x1010c0d
    int32_t v1; // 0x1010c0d
    int32_t * v2 = (int32_t *)(v1 + 0x6083fcf6); // 0x1010c0d
    *v2 = *v2 - 1;
    int32_t v3 = v1 & -256 | 61; // 0x1010c17
    int32_t v4 = unknown_2009efb(); // 0x1010c1d
    int32_t v5; // 0x1010c0d
    char * v6 = (char *)(v5 - 4); // 0x1010c22
    *v6 = *v6 - 1;
    int32_t v7; // 0x1010c0d
    *(int32_t *)(v7 + 4) = v4;
    int32_t result = *(int32_t *)v3; // 0x1010c28
    int32_t v8 = *(int32_t *)(result - 71); // 0x1010c33
    int32_t v9 = v3 + v5; // 0x1010c36
    int32_t * v10 = (int32_t *)result; // 0x1010c3b
    *v10 = *v10 | result;
    int128_t v11; // 0x1010c0d
    int128_t v12; // 0x1010c0d
    __asm_vpsubsw(v11, v12);
    __asm_rep_movsd_memcpy((char *)v8, (char *)0x458b04d1, v9);
    char * v13 = (char *)(v8 + 4 * v9); // 0x1010c49
    __asm_rep_movsb_memcpy(v13, v13, result & 3);
    return result;
}

// Address range: 0x1010c63 - 0x1010eb1
int32_t function_1010c63(void) {
    // 0x1010c63
    int32_t v1; // 0x1010c63
    int32_t * v2 = (int32_t *)(v1 + 0x14fca35); // 0x1010c63
    *v2 = *v2 - 1;
    int32_t v3; // 0x1010c63
    int32_t * v4 = (int32_t *)(v3 + 0x4e8bf045); // 0x1010c69
    *v4 = *v4 + v3;
    int32_t v5; // 0x1010c63
    int32_t v6 = v5 + 13 & 114 | 141; // 0x1010c71
    int32_t v7 = 0; // bp-4, 0x1010c75
    bool v8; // 0x1010c63
    int32_t v9 = v8 ? -4 : 4; // 0x1010c7f
    int32_t v10 = 0x61c1c18b * (v6 | v5 & -256) + v9; // 0x1010c7f
    int32_t v11 = v6 & 3; // 0x1010c82
    int32_t v12; // 0x1010c63
    __asm_rep_movsb_memcpy((char *)v10, (char *)(v9 + v12), v11);
    int32_t v13 = v8 ? -1 : 1; // 0x1010c85
    int32_t v14; // 0x1010c63
    int32_t v15 = *(int32_t *)*(int32_t *)(v14 + 74); // 0x1010c8a
    int32_t * v16 = (int32_t *)v15; // 0x1010c8c
    int32_t v17 = *v16; // 0x1010c8c
    int32_t v18 = -v17; // 0x1010c8c
    *v16 = v18;
    bool v19 = v18 < 0; // 0x1010c8e
    bool v20 = v17 == 0; // 0x1010c8e
    bool v21 = false; // 0x1010c8e
    int32_t v22 = v15; // 0x1010c8e
    int32_t v23 = 0x7fffffff; // 0x1010c8e
    int32_t v24 = v10 + v13 * v11; // 0x1010c8e
    int32_t v25; // 0x1010c63
    int32_t result = v25;
    int32_t v26 = &v7;
    int32_t * v27; // 0x1010c63
    int32_t v28; // 0x1010c63
    int32_t v29; // 0x1010c63
    int32_t v30; // 0x1010c63
    while (v20 || v19 != v21) {
        // 0x1010d0a
        *(int32_t *)(v26 - 4) = v22;
        function_100bc54();
        int32_t * v31 = (int32_t *)(result - 4);
        int32_t v32 = v26 - 8; // 0x1010d14
        *(int32_t *)v32 = *(int32_t *)*v31;
        v27 = v31;
        v30 = v32;
        v28 = result;
        v29 = v24;
        if ((char)function_1011a18() != 64) {
            goto lab_0x1010d53;
        }
        int32_t v33 = *(int32_t *)v23; // 0x1010d22
        v23 += v9;
        int32_t v34 = *v31 + 1; // 0x1010d23
        int32_t v35 = v33 + 139 & 255 | v33 & -256; // 0x1010d24
        *(int32_t *)(v26 - 12) = v35;
        int32_t v36; // 0x1010c63
        char * v37 = (char *)(v36 + 0x8512b65); // 0x1010d27
        *v37 = *v37 | (char)v34;
        uint32_t v38 = *(int32_t *)(v35 + 4); // 0x1010d2d
        int32_t v39 = v36 - v34; // 0x1010d30
        char v40 = *(char *)v39; // 0x1010d35
        int32_t v41 = v39 * (v26 - 11); // 0x1010d37
        int32_t * v42 = (int32_t *)v34; // 0x1010d3c
        int32_t v43 = *v42 + result; // 0x1010d3c
        int32_t v44 = v43 + result; // 0x1010d42
        *v42 = v44;
        if (v44 < 0 == ((v44 ^ v43) & (v44 ^ result)) < 0 == (v44 != 0)) {
            if (v44 == 0) {
                int32_t * v45 = (int32_t *)(*(int32_t *)(v41 + 8) - 24); // 0x1010e97
                int32_t v46; // 0x1010c63
                *v45 = *v45 + (v46 & -0xff01 | 0x8500);
                return result;
            }
            // 0x1010dae
            *(int32_t *)v41 = *(int32_t *)-0x65fe2014;
            int32_t * v47 = (int32_t *)v39; // 0x1010db4
            *(int32_t *)(v41 - 4) = *v47;
            uint32_t v48 = function_100c05c(); // 0x1010db6
            int32_t v49 = function_1007c18(); // 0x1010dc5
            *v47 = v23 + v9;
            int32_t result2 = v49 - (v48 < 0x33ff0000 ? -0x17cf77fc : -0x17cf77fd); // 0x1010dd1
            __asm_out_4(109, result2);
            return result2;
        }
        int32_t v50 = v38 + 141 & 255 | v38 & -0x10000 | 256 * (int32_t)(v40 + (char)(v38 / 256)); // 0x1010d35
        int32_t v51 = v41 + 4; // 0x1010d40
        v24 -= 2;
        v22 = result & 0x14f693d;
        int32_t * v52 = (int32_t *)v22; // 0x1010d4b
        int32_t v53 = *v52; // 0x1010d4b
        int32_t v54 = v53 + v22; // 0x1010d4b
        *v52 = v54;
        v19 = false;
        v20 = true;
        v21 = (v54 & (v53 ^ -0x80000000)) < 0;
        v36 = v39;
        if (v54 != 0) {
            // 0x1010d46
            v27 = (int32_t *)(v50 - 4);
            v30 = v51;
            v28 = v50;
            v29 = v24;
            goto lab_0x1010d53;
        }
        result = v50;
        v26 = v51;
    }
    // 0x1010c95
    __asm_hlt();
    *(int32_t *)(v26 - 4) = result - 4;
    return function_100bbd4() | 59;
  lab_0x1010d53:
    // 0x1010d53
    *(int32_t *)(v30 - 4) = *(int32_t *)(v28 - 16);
    int32_t v55 = v28 - 12; // 0x1010d5b
    int32_t * v56 = (int32_t *)(v30 - 8); // 0x1010d5b
    *v56 = *(int32_t *)v55;
    __asm_in(147);
    int32_t result3 = function_1007bd1(); // 0x1010d63
    *v56 = *v27;
    __asm_bound(*(int64_t *)v55);
    int32_t * v57 = (int32_t *)(v28 - 0x76af07bb); // 0x1010d7c
    *v57 = *v57 - 1;
    char * v58 = (char *)(v13 - 127 + v29); // 0x1010d82
    *v58 = 2 * *v58;
    return result3;
}

// Address range: 0x1010ec7 - 0x1010ee5
int32_t function_1010ec7(void) {
    // 0x1010ec7
    int32_t v1; // 0x1010ec7
    int32_t v2; // 0x1010ec7
    *(int32_t *)v2 = v2 + v1;
    function_100bd6f(v1);
    function_100bbd4();
    return unknown_650a33(v1);
}

// Address range: 0x1010ee5 - 0x1010fb5
int32_t function_1010ee5(int16_t a1, int32_t a2) {
    // 0x1010ee5
    int32_t v1; // 0x1010ee5
    char * v2 = (char *)(v1 + 86); // 0x1010eee
    char v3 = *v2; // 0x1010eec
    int32_t v4; // bp-4, 0x1010ee5
    bool v5 = &v4 < (int32_t *)16; // 0x1010eec
    int32_t v6; // 0x1010ee5
    unsigned char v7 = (char)v6; // 0x1010ef7
    v5 |= v7 > 153;
    bool v8; // 0x1010ee5
    char v9; // 0x1010ee5
    if (false || (v7 & 14) > 9) {
        v8 = true;
        v9 = (v5 ? 102 : 6) + v7;
    } else {
        v8 = false;
        v9 = v5 ? v7 + 96 : v7;
    }
    v3 = -1 - v3;
    while (v9 != 0) {
        // 0x1010eee
        v7 = (char)(int32_t)v9;
        v5 |= v7 > 153;
        if (v8 || (v7 & 14) > 9) {
            v8 = true;
            v9 = (v5 ? 102 : 6) + v7;
        } else {
            v8 = false;
            v9 = v5 ? v7 + 96 : v7;
        }
        v3 = -1 - v3;
    }
    // 0x1010efa
    *v2 = v3;
    *(int32_t *)v1 = (int32_t)&v4;
    function_1007bd1();
    int32_t v10 = function_1007c26(); // 0x1010f05
    int32_t v11 = a1; // 0x1010f17
    int32_t v12; // 0x1010ee5
    __asm_out_2((int16_t)v12, v11);
    int32_t * v13 = (int32_t *)(v11 - 0x74cf74fd); // 0x1010f2c
    int32_t v14; // 0x1010ee5
    *v13 = *v13 + v14;
    if (v14 < 1) {
        function_1010ec7();
    }
    // 0x1010f3a
    uint32_t v15; // 0x1010ee5
    function_1007bc1(*(int32_t *)(v15 - 0x1e7c3771));
    *(int32_t *)(v10 - 41) = 0;
    int32_t v16 = v11 + 1; // 0x1010f63
    char v17 = v16; // 0x1010f64
    unsigned char v18 = v17 - 1; // 0x1010f64
    int32_t v19 = v16 & -256; // 0x1010f64
    if (((v18 ^ v17) & -v17) >= 0) {
        // 0x1010f68
        return v19 | (int32_t)v18;
    }
    int32_t v20 = *(int32_t *)v11; // 0x1010f60
    int32_t * v21 = (int32_t *)(v20 + 0x7989f84d); // 0x1010f6c
    *v21 = *v21 - 1;
    int32_t v22 = v19 | v11 + 22 & 255; // 0x1010f77
    int32_t * v23 = (int32_t *)(v20 + (v15 & -4)); // 0x1010f79
    *v23 = *v23 ^ v22;
    int32_t v24 = *(int32_t *)(v22 + 4); // 0x1010f7e
    char v25; // 0x1010ee5
    __asm_rep_movsb_memcpy((char *)v24, (char *)0x458ba4f4, (int32_t)(v25 + (char)(v15 / 512) & 3));
    int32_t v26 = *(int32_t *)v20; // 0x1010f96
    int32_t v27; // bp-11, 0x1010ee5
    function_100ded4(&v27, v26, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125);
    unknown_eca26826();
    __asm_insb((int16_t)*(int32_t *)(v11 - 117 + 8 * v1));
    abort();
    // UNREACHABLE
}

// Address range: 0x1010fcd - 0x1010fce
int32_t function_1010fcd(void) {
    // 0x1010fcd
    int32_t result; // 0x1010fcd
    return result;
}

// Address range: 0x1010fd7 - 0x1010fd9
int32_t function_1010fd7(void) {
    // 0x1010fd7
    return function_1010fcd();
}

// Address range: 0x1011036 - 0x101103b
int32_t function_1011036(void) {
    // 0x1011036
    return function_8ca7033d();
}

// Address range: 0x101103c - 0x101103d
int32_t function_101103c(void) {
    // 0x101103c
    int32_t result; // 0x101103c
    return result;
}

// Address range: 0x1011050 - 0x1011057
int32_t function_1011050(void) {
    // 0x1011050
    return function_458b0004();
}

// Address range: 0x1011080 - 0x1011085
int32_t function_1011080(void) {
    // 0x1011080
    return function_9ba68587();
}

// Address range: 0x10110bf - 0x10110c4
int32_t function_10110bf(void) {
    // 0x10110bf
    return function_10110d8();
}

// Address range: 0x10110c4 - 0x10110d8
int32_t function_10110c4(void) {
    // 0x10110c4
    int32_t v1; // 0x10110c4
    return v1 - 16;
}

// Address range: 0x10110d8 - 0x10110e9
int32_t function_10110d8(void) {
    // 0x10110d8
    int32_t v1; // 0x10110d8
    int32_t result = *(int32_t *)(v1 - 4); // 0x10110d8
    int32_t * v2 = (int32_t *)(result + 0x2de8a304); // 0x10110dd
    bool v3; // 0x10110d8
    *v2 = *v2 + (v3 ? 19 : 18);
    char * v4 = (char *)result; // 0x10110e5
    *v4 = *v4 + (char)result;
    return result;
}

// Address range: 0x10110ea - 0x10110f7
int32_t function_10110ea(void) {
    // 0x10110ea
    int32_t v1; // 0x10110ea
    uint32_t result = *(int32_t *)(v1 - 2); // 0x10110ea
    uint32_t v2; // 0x10110ea
    if (result >= v2) {
        // 0x10110f7
        return result;
    }
    int32_t result2 = result + 1; // 0x10110f1
    *(int32_t *)(v1 + 12) = result2;
    return result2;
}

// Address range: 0x10110fb - 0x1011111
int32_t function_10110fb(int32_t a1) {
    // 0x10110fb
    int32_t v1; // 0x10110fb
    char * v2 = (char *)(v1 + 0x50f0d88d); // 0x1011100
    uint32_t v3; // 0x10110fb
    int32_t v4; // 0x10110fb
    *v2 = *v2 - (char)v4 + (char)((char)(v3 / 256) < 53);
    function_1011a9a((int32_t)&g125, (int32_t)&g125);
    int32_t v5; // 0x10110fb
    return *(int32_t *)(v5 - 4);
}

// Address range: 0x10111c0 - 0x10111c1
int32_t function_10111c0(void) {
    // 0x10111c0
    int32_t result; // 0x10111c0
    return result;
}

// Address range: 0x10111c8 - 0x10111e8
int32_t function_10111c8(void) {
    int32_t v1 = unknown_3cf25c(); // 0x10111c8
    int32_t v2 = v1; // 0x10111cf
    if (v1 == 0) {
        v2 = function_1011270((int32_t)&g125, (int32_t)&g125, (int32_t)&g125);
    }
    int32_t v3 = v2 + 1; // 0x10111d5
    int32_t result = v3; // 0x10111d6
    if (v3 < 0 == (v3 & (v2 ^ -0x80000000)) < 0) {
        result = function_10111c0();
    }
    // 0x10111d8
    return result;
}

// Address range: 0x10111e8 - 0x10111fb
int32_t function_10111e8(void) {
    // 0x10111e8
    int32_t result; // 0x10111e8
    int32_t * v1 = (int32_t *)(result - 117); // 0x10111ea
    *v1 = *v1 + 1;
    int32_t v2; // 0x10111e8
    float80_t v3; // 0x10111e8
    *(int64_t *)(v2 + 0x4f6fa138) = (int64_t)v3;
    *(int32_t *)v2 = result + v2;
    return result;
}

// Address range: 0x10111fd - 0x10111fe
int32_t function_10111fd(int32_t a1) {
    // 0x10111fd
    int32_t result; // 0x10111fd
    return result;
}

// Address range: 0x101120a - 0x1011219
int32_t function_101120a(int32_t a1) {
    // 0x101120a
    int32_t result; // 0x101120a
    return result;
}

// Address range: 0x101121b - 0x1011220
int32_t function_101121b(void) {
    // 0x101121b
    return function_8c5d05cf();
}

// Address range: 0x1011265 - 0x101126a
int32_t function_1011265(void) {
    // 0x1011265
    return function_8c47056c();
}

// Address range: 0x1011270 - 0x1011277
int32_t function_1011270(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1011270
    int32_t result; // 0x1011270
    return result;
}

// Address range: 0x1011288 - 0x101132b
int32_t function_1011288(void) {
    struct struct1 v1; // 0x1011290
    // 0x1011288
    int32_t v2; // 0x1011288
    int32_t * v3 = (int32_t *)(v2 - 0x9cce1bb); // 0x1011288
    *v3 = *v3 - 1;
    int32_t v4; // 0x1011288
    v1 = __asm_cpuid(v4);
    int32_t v5 = __asm_in(0) - 2; // 0x1011297
    int32_t v6 = v5; // 0x1011298
    if (v5 != 0) {
        v6 = function_1017d65();
    }
    // 0x101129e
    int32_t v7; // 0x1011288
    bool v8; // 0x1011288
    int32_t v9 = v4 + v7 + (int32_t)v8; // 0x101128e
    int32_t v10 = v1.e1; // 0x1011290
    int32_t v11 = *(int32_t *)v10; // bp-8, 0x10112a4
    int32_t * v12 = &v11; // 0x10112ad
    int32_t v13; // 0x1011288
    if (v6 != 0) {
        int32_t v14 = v9; // bp-12, 0x10112b3
        *(int32_t *)(v13 + 37) = v9;
        v12 = &v14;
    }
    int32_t v15 = (int32_t)v12;
    function_1007bd1();
    int32_t * v16 = (int32_t *)(v13 + 12); // 0x10112bc
    *v16 = v9;
    *(int32_t *)(v10 - 0x17cf00f4) = unknown_74007c26();
    int32_t * v17 = (int32_t *)(v10 - 0x3f76f3a9); // 0x10112cd
    *v17 = *v17 - 1;
    int32_t v18 = *(int32_t *)*(int32_t *)0x13b4fd8; // 0x10112d8
    *(int32_t *)(v15 - 4) = *(int32_t *)(v18 + 4);
    int32_t v19 = unknown_21d9fb(); // 0x10112dd
    int32_t v20 = *v16; // 0x10112e2
    *(int32_t *)v20 = v19;
    int32_t v21 = *(int32_t *)-0x2cbb028; // 0x10112e7
    int32_t v22 = *(int32_t *)v21; // 0x10112ec
    int32_t v23 = (v21 | 139) ^ 0xc8d7039; // 0x10112f5
    char * v24 = (char *)v23; // 0x10112fa
    *v24 = *v24 + (char)v23;
    char * v25 = (char *)(v10 - 0x4c16483f); // 0x10112fc
    *v25 = *v25 + (char)v20;
    int32_t v26; // 0x1011288
    __asm_rep_movsd_memcpy((char *)v26, (char *)(-0x55f61a75 * v22), v20);
    bool v27; // 0x1011288
    int32_t v28 = v20 * (v27 ? -4 : 4) + v26; // 0x1011302
    char * v29 = (char *)v28; // 0x1011309
    __asm_rep_movsb_memcpy(v29, v29, 2);
    int32_t v30 = v28 + (v27 ? -2 : 2); // 0x1011309
    int32_t v31 = *(int32_t *)(v13 + 13); // 0x101130b
    int32_t v32 = v15 - 8; // 0x101130e
    *(int32_t *)v32 = *(int32_t *)(v31 + 4);
    *(int32_t *)(v15 - 12) = v31;
    *(int32_t *)(v15 - 16) = 0;
    *(int32_t *)(v15 - 20) = v1.e3;
    *(int32_t *)(v15 - 24) = v10;
    *(int32_t *)(v15 - 28) = v32;
    *(int32_t *)(v15 - 32) = 69 * *(int32_t *)(v10 - 0x74000098);
    *(int32_t *)(v15 - 36) = v30;
    *(int32_t *)(v15 - 40) = v30;
    return *(int32_t *)(g107 + 4);
}

// Address range: 0x101132b - 0x101133a
int32_t function_101132b(void) {
    // 0x101132b
    int32_t v1; // 0x101132b
    int32_t * v2 = (int32_t *)(v1 + 0x41891801); // 0x101132c
    *v2 = *v2 - 1;
    int32_t v3; // 0x101132b
    __asm_into(v3);
    return function_b2017228();
}

// Address range: 0x1011348 - 0x101134d
int32_t function_1011348(int32_t a1) {
    // 0x1011348
    uint32_t result; // 0x1011348
    *(int32_t *)result = result / 0x80000000 | 2 * result;
    return result;
}

// Address range: 0x101134e - 0x1011353
int32_t function_101134e(void) {
    // 0x101134e
    return function_8ca70655();
}

// Address range: 0x1011361 - 0x101137b
int32_t function_1011361(void) {
    // 0x1011361
    return function_e30113e5(-1);
}

// Address range: 0x101137b - 0x1011430
int32_t function_101137b(void) {
    // 0x101137b
    function_1008d44();
    int32_t v1; // 0x101137b
    unsigned char v2 = (char)v1;
    *(char *)v1 = v2 / 128 | 2 * v2;
    int32_t v3 = unknown_bf007bd1(); // 0x1011394
    int32_t v4; // 0x101137b
    int32_t * v5 = (int32_t *)v4; // 0x10113a1
    *v5 = v3;
    int32_t v6 = v3 | 255; // 0x10113a3
    char * v7 = (char *)(v4 + 0x4fd4a130); // 0x10113ad
    *v7 = *v7 & (char)v4;
    *v5 = v6 + v4;
    int16_t v8; // 0x101137b
    int32_t v9 = unknown_87007bfb(*(int32_t *)(*(int32_t *)v6 + 4), 0x458bff47, v8); // 0x10113ba
    uint32_t v10 = *(int32_t *)-0x56fffff4; // 0x10113bf
    unsigned char v11 = (char)v9; // 0x10113c5
    int32_t v12 = v11 % 79; // 0x10113c5
    *(int32_t *)v10 = (v9 & -0x10000 | v12 | 256 * (int32_t)(v11 / 79)) + v9;
    *(char *)0x458b044e = *(char *)0x458b044e ^ (char)(v10 / 256);
    char * v13 = (char *)(v1 - 117); // 0x10113d8
    uint32_t v14; // 0x101137b
    *v13 = *v13 + (char)(v14 / 256);
    bool v15; // 0x101137b
    int32_t v16 = v15 ? -4 : 4; // 0x10113e0
    int32_t v17 = v16 + v1; // 0x10113e0
    int32_t v18 = v12 & 3; // 0x10113e3
    int32_t v19 = *(int32_t *)(*(int32_t *)-0x5700006c + 67); // 0x10113eb
    int32_t v20 = v19; // bp-23, 0x10113eb
    function_1007bc1(v19);
    int32_t v21 = *(int32_t *)-0x56fffff4; // 0x10113f3
    int32_t v22 = v17; // bp-55, 0x10113f7
    int32_t v23; // 0x101137b
    int32_t v24; // 0x101137b
    int16_t v25; // 0x101137b
    int32_t v26 = unknown_747b7a(v25, v17, v16 + v23, -0x57000001, &v20, 256 * v14 & 0xff00 ^ v24 & -256 | 139, v14 + 0x8b00 & 0xff00 | v14 & -0xff01, v18, v21); // 0x1011405
    *(int32_t *)(v18 | 4) = v26;
    *(int32_t *)(*(int32_t *)(v17 + 12) - 0x7674f2b2) = v18;
    return function_75a70732(&v22);
}

// Address range: 0x1011437 - 0x1011472
int32_t function_1011437(void) {
    // 0x1011437
    function_100be29((int32_t)&g125);
    function_1007bd1();
    int32_t v1; // 0x1011437
    int16_t v2; // 0x1011437
    function_100bd7e(v1, v2);
    int32_t result = unknown_3e0ee5(v1, v1, g94); // 0x1011466
    int32_t * v3 = (int32_t *)(v1 + 81); // 0x101146c
    *v3 = *v3 ^ v1;
    return result;
}

// Address range: 0x10114c5 - 0x10114ca
int32_t function_10114c5(void) {
    // 0x10114c5
    return function_8ca707cc();
}

// Address range: 0x1011502 - 0x1011569
int32_t function_1011502(int32_t a1) {
    // 0x1011502
    int32_t v1; // 0x1011502
    int32_t v2 = v1 + 132 & 155 | 100; // 0x1011504
    char * v3 = (char *)(v2 | v1 & -256); // 0x1011508
    *v3 = *v3 + (char)v2;
    int32_t v4; // 0x1011502
    int32_t v5; // 0x1011502
    uint32_t v6; // 0x1011502
    __asm_rep_movsd_memcpy((char *)v4, (char *)v5, v6 / 4);
    __asm_in(243);
    int16_t v7; // 0x1011502
    function_1010ee5(v7, (int32_t)&g125);
    int32_t v8; // 0x1011502
    int32_t * v9 = (int32_t *)(v8 + 111); // 0x1011527
    *v9 = *v9 + 1;
    if (function_100e461() == 0) {
        // 0x1011554
        int32_t v10; // 0x1011502
        return function_100c46f(v10, *(int32_t *)(v8 - 3));
    }
    // 0x1011536
    function_1007bd1();
    *(int32_t *)(v8 - 3) = 0;
    __asm_wait();
    abort();
    // UNREACHABLE
}

// Address range: 0x1011569 - 0x10115e9
int32_t function_1011569(int32_t a1) {
    // 0x1011569
    unknown_7a660a04();
    int32_t result = unknown_492c8982() - 1; // 0x1011582
    if (result == 0) {
        // 0x1011585
        return result;
    }
    // 0x1011589
    int32_t v1; // 0x1011569
    *(int32_t *)v1 = result + v1;
    return result;
}

// Address range: 0x10115ed - 0x10115ef
int32_t function_10115ed(void) {
    // 0x10115ed
    return function_101160f((int32_t)&g125);
}

// Address range: 0x1011603 - 0x1011607
int32_t function_1011603(void) {
    // 0x1011603
    int32_t result; // 0x1011603
    return result;
}

// Address range: 0x101160f - 0x1011683
int32_t function_101160f(int32_t a1) {
    // 0x101160f
    int32_t v1; // 0x101160f
    bool v2; // 0x101160f
    int32_t v3 = v1 + 1 + (int32_t)v2 & 255 | v1 & -256; // 0x101160f
    int32_t v4; // 0x101160f
    int32_t v5; // 0x101160f
    int32_t v6 = *(int32_t *)(v5 - 40) + v4; // 0x1011614
    int32_t v7; // 0x101160f
    int32_t v8; // 0x101160f
    int32_t v9 = v8 > v7 ? v8 : v7;
    uint32_t v10 = v3 < v6 ? v6 : a1;
    uint32_t v11 = v3 < v6 ? v3 : v9;
    int32_t v12; // 0x101160f
    int32_t * v13 = (int32_t *)((v3 < v6 ? v5 : v12) - 0xf74f7b5); // 0x101162d
    *v13 = *v13 - 1;
    int32_t v14 = *(int32_t *)(v9 - (v3 < v6 ? 0 : v6) + 0x7cc13b09); // 0x1011633
    *(int32_t *)(v12 - 8) = v14;
    int32_t v15 = *(int32_t *)(v4 + 0x46b8987); // 0x1011642
    int32_t v16 = v4 + 12; // 0x1011648
    *(int32_t *)(v12 - 24) = v16;
    char v17 = __asm_in_1(-117); // 0x1011653
    char * v18 = (char *)(v16 & -256 | (int32_t)v17); // 0x101165f
    *v18 = *v18 + v17;
    float80_t v19; // 0x101160f
    *(float64_t *)(v7 + 0x3b83c053 + (2 * v15 & -512 | 64)) = (float64_t)v19;
    int32_t v20 = v4 + 1; // 0x101166d
    int32_t v21 = __asm_hlt(); // 0x1011670
    char * v22 = (char *)v20; // 0x1011672
    *v22 = *v22 + (char)v20;
    char * v23 = (char *)v21; // 0x1011674
    char v24 = *v23; // 0x1011674
    *v23 = v24 + (char)(v10 / 256 + v10 + (int32_t)(v11 < v6));
    return function_1011716();
}

// Address range: 0x1011683 - 0x10116c5
int32_t function_1011683(int16_t a1) {
    // 0x1011683
    int32_t v1; // 0x1011683
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x1011683
    int32_t v3; // 0x1011683
    if (*(int32_t *)(v3 - 8) >= v2) {
        int32_t v4 = *(int32_t *)(v3 + 12) + v2; // 0x1011691
        return v4 + 59 & 255 | v4 & -256;
    }
    // 0x10116a9
    int32_t v5; // 0x1011683
    char * v6 = (char *)(v5 + 0x47390843); // 0x10116ac
    int32_t v7; // 0x1011683
    *v6 = *v6 + (char)v7;
    int32_t v8; // 0x1011683
    int32_t v9 = v2 - *(int32_t *)(v8 + 8); // 0x10116b5
    return (v9 + 174 | 43) + 59 & 254 | v9 & -256;
}

// Address range: 0x10116c5 - 0x1011705
int32_t function_10116c5(int32_t a1) {
    char v1 = __asm_in_1(-70); // 0x10116c7
    int32_t v2 = a1;
    int32_t v3; // 0x10116c5
    int32_t v4 = &v3;
    int32_t v5 = __asm_in_1(4); // 0x10116cc
    int32_t v6; // 0x10116c5
    int32_t v7 = (v6 & -256 | (int32_t)v1) & -256 | v5; // 0x10116cc
    int32_t v8 = v2 + 2; // 0x10116cf
    int32_t v9 = v4 - 8; // 0x10116d2
    int32_t v10 = v7 - 0x7cff1fac; // 0x10116d3
    while (v10 < 0 == ((v10 ^ v7) & v7 + 0x300e054) < 0) {
        // 0x10116ca
        v2 = v8;
        v4 = v9;
        v5 = __asm_in_1(4);
        v7 = v10 & -256 | v5;
        v8 = v2 + 2;
        v9 = v4 - 8;
        v10 = v7 - 0x7cff1fac;
    }
    // 0x10116da
    int32_t v11; // 0x10116c5
    *(int32_t *)v11 = v10;
    bool v12 = (v5 & 12) == 12 | (v10 & 14) > 9; // 0x10116db
    int32_t v13 = v12 ? v5 + 10 : v10; // 0x10116db
    int32_t result = (v13 & 15 | v10 & -0x10000 | 256 * (int32_t)v12 + v10 & 0xff00) - 1; // 0x10116e3
    *(int32_t *)(v2 - 2) = result;
    int32_t * v14 = (int32_t *)(v4 - 0x74f68b78 + 8 * v8); // 0x10116e7
    uint32_t v15 = *v14; // 0x10116e7
    *v14 = v15 - 69;
    char * v16 = (char *)(v2 - 0x14b735b9); // 0x10116ef
    *v16 = *v16 + (char)((v7 >> 31) / 256) + (char)(v15 < 69);
    return result;
}

// Address range: 0x1011705 - 0x1011712
int32_t function_1011705(void) {
    // 0x1011705
    int32_t v1; // 0x1011705
    uint32_t v2 = *(int32_t *)(v1 - 98); // 0x1011705
    uint32_t v3; // 0x1011705
    uint32_t v4; // 0x1011705
    int32_t v5 = (0x100000000 * (int64_t)v3 | (int64_t)v4) / (int64_t)v2; // 0x1011705
    int32_t v6; // 0x1011705
    int32_t * v7 = (int32_t *)(v6 + 0x4dff04c1); // 0x1011709
    bool v8; // 0x1011705
    *v7 = v5 + (int32_t)v8 + *v7;
    return v5 + 1;
}

// Address range: 0x1011716 - 0x101171d
int32_t function_1011716(void) {
    // 0x1011716
    int32_t v1; // 0x1011716
    int32_t v2; // 0x1011716
    *(char *)v1 = (char)v2 + (char)v1;
    int32_t v3; // 0x1011716
    bool v4; // 0x1011716
    int32_t * v5 = (int32_t *)((v4 ? -1 : 1) + v3); // 0x101171b
    *v5 = *v5 / 2;
    int32_t v6; // 0x1011716
    return v6 & -0x10000 | v3 & 255 | (v6 | 256 * v2) & 0xff00;
}

// Address range: 0x1011726 - 0x1011729
int32_t function_1011726(void) {
    // 0x1011726
    int32_t result; // 0x1011726
    return result;
}

// Address range: 0x101172d - 0x10117a8
int32_t function_101172d(int32_t a1, int32_t a2, int32_t a3) {
    // 0x101172d
    bool v1; // 0x101172d
    uint32_t v2 = v1 ? 0x75fc553a : 0x75fc5539; // 0x101172d
    int32_t v3; // 0x101172d
    char * v4 = (char *)(v3 + 0x4438301); // 0x1011732
    uint32_t v5; // 0x101172d
    *v4 = *v4 - (char)v3 + (char)(v1 | v5 < v2);
    int32_t v6; // 0x101172d
    int32_t * v7 = (int32_t *)(v6 + 4); // 0x1011738
    *v7 = *v7 + 1;
    bool v8; // 0x101172d
    int32_t v9 = v8 ? -1 : 1; // 0x1011744
    int32_t v10 = v9 + a1; // 0x1011744
    int32_t v11; // 0x101172d
    int32_t result = *(int32_t *)(v9 + v11); // 0x1011745
    *(int32_t *)v10 = result;
    uint32_t v12; // 0x101172d
    if (*(int32_t *)(v10 + 4) > 1) {
        // 0x1011781
        int32_t v13; // 0x101172d
        float80_t v14; // 0x101172d
        *(int64_t *)(v13 - 4) = (int64_t)v14;
        int32_t v15; // 0x101172d
        char * v16 = (char *)(v15 + 9); // 0x1011786
        *v16 = *v16 + (char)(v12 / 256);
        return result;
    }
    // 0x1011792
    *(int32_t *)v12 = v12 + 1;
    int16_t v17 = v12; // 0x10117a0
    *(char *)a2 = __asm_insb(v17);
    return result & 0xaaff00 | (int32_t)__asm_in_3(v17) | -0x74ab0000;
}

// Address range: 0x10117c1 - 0x10118e3
int32_t function_10117c1(int32_t a1) {
    // 0x10117c1
    int32_t v1; // 0x10117c1
    int32_t v2 = v1 - 4; // 0x10117c3
    int32_t v3; // 0x10117c1
    uint32_t v4 = v3 + 1; // 0x10117c7
    int32_t v5; // 0x10117c1
    int32_t v6; // 0x10117c1
    int32_t v7 = unknown_947bfb(v6, v5); // 0x10117c9
    int32_t result2 = *(int32_t *)(v1 - 17); // 0x10117d0
    int32_t result; // 0x10117c1
    uint32_t v8; // 0x10117c1
    if (v4 == 0) {
        // 0x10117d5
        *(int32_t *)v7 = *(int32_t *)result * (result2 + 139 & 255 | result2 & -256);
        int32_t * v9 = (int32_t *)(v7 + 12); // 0x10117e3
        *v9 = *v9 - v8;
        int32_t v10; // 0x10117c1
        *(int32_t *)(v3 + 0x8e0ff5) = *(int32_t *)(v10 + 4);
        uint32_t v11 = 2 * v8; // 0x10117f7
        *(int32_t *)v8 = v11;
        int32_t * v12 = (int32_t *)(v1 - 28); // 0x10117fd
        *v12 = result + 12;
        int32_t v13 = *(int32_t *)(*(int32_t *)(result + 8) + *(int32_t *)(v10 + 93)); // 0x1011800
        *(int32_t *)(v1 - 32) = v13;
        *(int32_t *)v2 = *v12;
        int32_t * v14 = (int32_t *)(v8 + 4); // 0x101180e
        *v14 = *v14 + (v11 < v8 ? -118 : -119);
        __asm_in_3((int16_t)*(int32_t *)(result + 4));
        return result;
    }
    if (v4 <= 0) {
        // 0x101185c
        return result2;
    }
    // 0x1011828
    *(char *)(9 * v7) = -1;
    if (v8 == 1) {
        int32_t v15 = function_1012770(*(int32_t *)*(int32_t *)(v1 - 16), result2 & -0x10000); // 0x1011839
        return (*(int32_t *)(v7 + 116) | v15) & -0xff01;
    }
    int32_t v16 = v4 & -256 | (int32_t)*(char *)v2; // 0x101181f
    int32_t v17; // bp-4, 0x10117c1
    int32_t v18 = &v17;
    int32_t * v19 = (int32_t *)(v1 - 60); // 0x1011863
    *v19 = 0;
    uint32_t v20 = *(int32_t *)(result - 0x4b001364); // 0x1011869
    char * v21 = (char *)(result - 0x72adcacb); // 0x101186f
    char v22 = v20; // 0x101186f
    *v21 = *v21 + v22;
    *(int32_t *)(v18 - 4) = result2 | 139;
    *(int32_t *)(v1 - 24) = v20;
    uint32_t v23 = unknown_9f0147d0(); // 0x101187b
    int32_t v24 = v18 - 8; // 0x1011880
    *(int32_t *)v24 = *v19;
    *(int32_t *)(v20 - 0x17ba7438) = v16;
    unsigned char v25 = (char)(v20 / 256); // 0x101188a
    unsigned char v26 = (char)(v23 / 256) + v25; // 0x101188a
    if (v26 != 0) {
        int32_t result3 = unknown_c70126d0(); // 0x10118a0
        int32_t * v27 = (int32_t *)(v1 - 8); // 0x10118a5
        *v27 = *v27 + 1;
        *(int32_t *)(v18 - 12) = result3;
        *(int32_t *)(v18 - 16) = *(int32_t *)(8 * v1 - 117 + result3);
        *(int32_t *)(v18 - 20) = v16;
        *(int32_t *)(v18 - 28) = v24;
        *(int32_t *)(v18 - 36) = result3;
        return result3;
    }
    char * v28 = (char *)result; // 0x1011892
    unsigned char v29 = *v28; // 0x1011892
    unsigned char v30 = v22 & 31; // 0x1011892
    bool v31 = v26 < v25; // 0x1011892
    if (v30 != 0) {
        char v32 = v29 >> 8 - v30 | v29 << v30; // 0x1011892
        *v28 = v32;
        v31 = (v32 & 1) != 0;
    }
    int32_t * v33 = (int32_t *)result; // 0x1011894
    uint32_t v34 = *v33; // 0x1011894
    *v33 = v34 / 0x4000 | 0x80000 * v34 | 0x40000 * (int32_t)v31;
    return 256 * (int32_t)v26 | v20 & -0xff01;
}

// Address range: 0x10118ea - 0x10118ec
int32_t function_10118ea(void) {
    // 0x10118ea
    return function_10118fe();
}

// Address range: 0x10118fc - 0x10118fe
int32_t function_10118fc(void) {
    // 0x10118fc
    int32_t v1; // 0x10118fc
    return v1 + 1 & 255 | v1 & -256;
}

// Address range: 0x10118fe - 0x1011913
int32_t function_10118fe(void) {
    // 0x10118fe
    return function_10047c1();
}

// Address range: 0x1011913 - 0x1011934
int32_t function_1011913(int32_t a1) {
    // 0x1011913
    int32_t v1; // 0x1011913
    int32_t v2; // 0x1011913
    return function_1011986(v1, v2);
}

// Address range: 0x101195a - 0x101195b
int32_t function_101195a(void) {
    // 0x101195a
    int32_t result; // 0x101195a
    return result;
}

// Address range: 0x1011961 - 0x1011977
int32_t function_1011961(int32_t a1, int32_t a2) {
    // 0x1011961
    int32_t v1; // 0x1011961
    char * v2 = (char *)(v1 + 0x8968310); // 0x1011961
    int32_t v3; // 0x1011961
    *v2 = *v2 | (char)v3;
    return function_1011979((int32_t)&g125);
}

// Address range: 0x1011977 - 0x1011979
int32_t function_1011977(void) {
    // 0x1011977
    return 0;
}

// Address range: 0x1011979 - 0x1011983
int32_t function_1011979(int32_t a1) {
    // 0x1011979
    int32_t v1; // 0x1011979
    unsigned char v2 = (char)v1 + 48; // 0x1011979
    int32_t v3 = v1 & -256 | (int32_t)v2; // 0x101197b
    if (v2 != 0) {
        v3 = function_101198c();
    }
    int32_t result = v3;
    int32_t v4; // 0x1011979
    int32_t v5 = v4 - 1; // 0x101197d
    bool v6 = v5 == 0; // 0x1011980
    while (v5 >= 0 == (v5 != 0)) {
        // 0x101197b
        v3 = result;
        if (!v6) {
            v3 = function_101198c();
        }
        // 0x101197d
        result = v3;
        v5--;
        v6 = v5 == 0;
    }
    // 0x1011982
    return result;
}

// Address range: 0x1011986 - 0x101198c
int32_t function_1011986(int32_t a1, int32_t a2) {
    // 0x1011986
    int32_t result; // 0x1011986
    bool v1; // 0x1011986
    if (!v1) {
        result = function_10119c6();
    }
    // 0x1011988
    return result;
}

// Address range: 0x101198c - 0x101199b
int32_t function_101198c(void) {
    // 0x101198c
    int32_t v1; // 0x101198c
    int32_t v2; // 0x101198c
    return *(int32_t *)(v2 - 0x74f3b275 + (int32_t)__asm_in_3((int16_t)v1));
}

// Address range: 0x101199f - 0x10119a0
int32_t function_101199f(void) {
    // 0x101199f
    int32_t result; // 0x101199f
    return result;
}

// Address range: 0x10119b0 - 0x10119b2
int32_t function_10119b0(void) {
    // 0x10119b0
    int32_t result; // 0x10119b0
    return result;
}

// Address range: 0x10119c6 - 0x10119dc
int32_t function_10119c6(void) {
    // 0x10119c6
    int32_t v1; // 0x10119c6
    int32_t * v2 = (int32_t *)(v1 + 12); // 0x10119d5
    int32_t v3; // 0x10119c6
    *v2 = *v2 - v3;
    int32_t result; // 0x10119c6
    return result;
}

// Address range: 0x10119dc - 0x1011a00
int32_t function_10119dc(void) {
    int32_t v1 = 0; // 0x10119df
    int32_t v2; // 0x10119dc
    int32_t v3; // 0x10119dc
    if (v3 > *(int32_t *)(v2 + 65)) {
        // 0x10119e1
        v1 = *(int32_t *)*(int32_t *)(v2 + 8);
        int32_t * v4 = (int32_t *)(v2 - 91); // 0x10119e6
        *v4 = *v4 - 4;
    }
    uint32_t v5 = v1;
    *(int32_t *)0x90b8bd0 = 1024 * *(int32_t *)0x90b8bd0;
    return v5 + 235 + 43 * v5 / 256 & 255 | v5 & -0x10000;
}

// Address range: 0x1011a00 - 0x1011a0d
int32_t function_1011a00(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1011a00
    int32_t v1; // 0x1011a00
    int32_t v2; // 0x1011a00
    if (v2 >= 0 == (v2 != 0)) {
        v1 = function_10119dc();
    }
    int32_t result = v1; // 0x1011a04
    if (v2 < 0) {
        result = function_10119c6();
    }
    // 0x1011a06
    return result;
}

// Address range: 0x1011a16 - 0x1011a18
int32_t function_1011a16(void) {
    // 0x1011a16
    int32_t result; // 0x1011a16
    return result;
}

// Address range: 0x1011a18 - 0x1011a3c
int32_t function_1011a18(void) {
    // 0x1011a18
    int32_t v1; // 0x1011a18
    int32_t v2 = v1 - 0x74fbdbb4 & -256 | v1 + 207 & 255; // 0x1011a1e
    int32_t v3; // 0x1011a18
    int32_t v4; // 0x1011a18
    int32_t * v5 = (int32_t *)(v4 + v3); // 0x1011a20
    uint32_t v6 = *v5; // 0x1011a20
    *v5 = v6 / 1024 | 0x400000 * v6;
    int32_t v7; // 0x1011a18
    int32_t * v8 = (int32_t *)(v7 - 0x2da6fb11); // 0x1011a26
    int32_t v9 = *v8 | v2; // 0x1011a26
    while (v2 >= 0 == (v2 != 0) == v9 == 0) {
        // 0x1011a24
        v9 = v2;
    }
    // 0x1011a38
    *v8 = v9;
    return 0;
}

// Address range: 0x1011a3c - 0x1011a98
int32_t function_1011a3c(int32_t a1, int32_t a2) {
    // 0x1011a3c
    int32_t v1; // 0x1011a3c
    char * v2 = (char *)(v1 - 0x74efdba4); // 0x1011a4f
    int32_t v3; // 0x1011a3c
    *v2 = (char)v3;
    int32_t v4 = v3 & -256 | (int32_t)*v2; // 0x1011a4f
    int32_t v5; // 0x1011a3c
    int32_t v6 = *(int32_t *)(v1 + 0x7f010378) + v5; // 0x1011a55
    int32_t v7 = *(int32_t *)v4; // 0x1011a5b
    if (v7 >= 0) {
        int32_t v8 = v6; // 0x1011a5f
        if (v7 != 0) {
            v8 = function_1011ab5((int32_t)&g125);
        }
        int32_t result = function_1007bc1(v8); // 0x1011a62
        *(int32_t *)v1 = v7;
        return result;
    }
    int32_t v9 = v6 + 232 & 255 | v6 & -0x10000 | 256 * (int32_t)*(char *)(v4 - 1); // 0x1011a6d
    int32_t * v10 = (int32_t *)(v4 - 0x5c3974fd); // 0x1011a70
    int32_t v11 = *v10; // 0x1011a70
    *v10 = v11 - 1;
    int32_t v12 = 4 * v4 + 12; // 0x1011a76
    __asm_rep_movsd_memcpy((char *)v9, (char *)a1, v12);
    bool v13; // 0x1011a3c
    char * v14 = (char *)(v9 + v12 * (v13 ? -4 : 4)); // 0x1011a8b
    __asm_rep_movsb_memcpy(v14, v14, (v12 & 12) > 9 | (v11 & 15) > 16 ? 2 : 0);
    __asm_iretd();
    return __asm_sti();
}

// Address range: 0x1011a9a - 0x1011a9d
int32_t function_1011a9a(int32_t a1, int32_t a2) {
    // 0x1011a9a
    int32_t v1; // 0x1011a9a
    bool v2; // 0x1011a9a
    return (v2 ? 255 : 0) | v1 & -256;
}

// Address range: 0x1011ab5 - 0x1011ccc
int32_t function_1011ab5(int32_t a1) {
    // 0x1011ab5
    bool v1; // 0x1011ab5
    int32_t v2; // 0x1011ab5
    int32_t v3; // 0x1011ab5
    if (v1) {
        // 0x1011ab7
        *(int32_t *)v3 = v3 * v2;
        // 0x1011af1
        int32_t result; // 0x1011ab5
        return result;
    }
    // 0x1011aca
    bool v4; // 0x1011ab5
    bool v5; // 0x1011ab5
    bool v6; // 0x1011ab5
    bool v7; // 0x1011ab5
    bool v8; // 0x1011ab5
    bool v9; // 0x1011ab5
    bool v10; // 0x1011ab5
    bool v11; // 0x1011ab5
    bool v12; // 0x1011ab5
    int32_t v13 = 0x4000 * (int32_t)v11 | 2048 * (int32_t)v12 | 1024 * (int32_t)v4 | 512 * (int32_t)v5 | 256 * (int32_t)v6 | 128 * (int32_t)v7 | 16 * (int32_t)v8 | (int32_t)v10 | 4 * (int32_t)v9 | 2; // 0x1011aca
    int32_t v14; // 0x1011ab5
    char * v15 = (char *)(v14 + 0x4303903); // 0x1011acd
    int32_t v16; // 0x1011ab5
    char v17 = v16; // 0x1011acd
    char v18 = *v15 | v17; // 0x1011acd
    *v15 = v18;
    int32_t v19; // 0x1011ab5
    int32_t v20; // 0x1011ab5
    int32_t v21; // 0x1011ab5
    if (v18 >= 0 != v18 != 0) {
        // 0x1011ad5
        if (*(int32_t *)(v3 + 12) == v16) {
            // 0x1011ada
            int32_t v22; // 0x1011ab5
            if (*(int32_t *)(v3 - 121) == v22) {
                uint32_t v23 = v3 ^ v16; // 0x1011adf
                __asm_out_2((int16_t)v21, v3);
                int32_t result2 = v3 & -256 | (int32_t)*(char *)(v19 + ((v23 / 256 | v3) & 255)); // 0x1011ae6
                int32_t * v24 = (int32_t *)(v23 + 0x476203b); // 0x1011ae9
                int32_t v25 = *v24; // 0x1011ae9
                *v24 = v25 - 1;
                if (v25 <= 1) {
                    // 0x1011af1
                    return result2;
                }
                // 0x1011af8
                *(int32_t *)(v14 - 8) = result2;
                return function_8c040e0c();
            }
        }
        // 0x1011b1c
        *(int32_t *)(v14 - 4) = *(int32_t *)(v20 + 16);
        *(int32_t *)(v14 - 12) = v19;
        // 0x1011af1
        return unknown_2517a5(v13);
    }
    unsigned char v26 = *(char *)&v19; // 0x1011b42
    *(char *)v19 = v26 / 8 | 32 * v26;
    unsigned char v27 = *(char *)(v21 - 0x4fad0000) ^ v17; // 0x1011b45
    if (v27 != 0) {
        char * v28 = (char *)(v19 - 0x3e3e81a3); // 0x1011b75
        *v28 = *v28 + v27;
        return function_f49ca082(v13);
    }
    // 0x1011b50
    if (*(int32_t *)0x1a24f58 == -58) {
        // 0x1011b5d
        *(int32_t *)(v14 - 4) = 0;
        unknown_9961c1(v13);
        *(int32_t *)(v14 - 8) = *(int32_t *)(v2 + 4);
        function_1009095();
        return function_a98d044e();
    }
    uint32_t v29 = v16 & -256 | (int32_t)v27; // 0x1011b45
    int32_t v30 = v19; // 0x1011c79
    int32_t v31 = *(int32_t *)(v14 + 4); // 0x1011c7a
    v19 = v31;
    int32_t v32 = *(int32_t *)(v14 + 8); // 0x1011c7b
    __asm_in_3((int16_t)v21);
    int32_t v33 = v29 - 24; // 0x1011c83
    int32_t v34 = *(int32_t *)(v31 + 0x308b5608); // 0x1011c86
    *(int32_t *)v20 = v30;
    char * v35 = (char *)(v30 + 106); // 0x1011c92
    *v35 = (char)(v29 < 24) + (char)v33 + *v35;
    int32_t v36 = v33 + v20; // 0x1011c95
    *(int32_t *)v30 = 0x7d892f3b;
    *(int32_t *)(v34 - 24) = v32;
    if (v36 < 0 != ((v36 ^ v33) & (v36 ^ v20)) < 0) {
        // 0x1011ca3
        unknown_f9e4f9ed();
    }
    // 0x1011ca8
    *(int32_t *)(v20 - 4) = v19;
    char * v37 = (char *)(v34 + 12); // 0x1011ca9
    *v37 = *v37 ^ (char)v19;
    int32_t v38 = *(int32_t *)(v19 + 4); // 0x1011cac
    int32_t * v39 = (int32_t *)(v30 - 0xa0c550); // 0x1011cba
    *v39 = *v39 + v34;
    __asm_arpl(*(int16_t *)(v30 + 0x4b2b084e), (int16_t)v36);
    *(int32_t *)(v20 - 8) = v32;
    return v38 + 182 & 255 | v38 & -256;
}

// Address range: 0x1011cd1 - 0x1011cea
int32_t function_1011cd1(int32_t a1, int32_t a2) {
    // 0x1011cd1
    uint32_t v1; // 0x1011cd1
    *(char *)0xb930f0e = *(char *)0xb930f0e | (char)(v1 / 256);
    int32_t v2; // 0x1011cd1
    char * v3 = (char *)(v2 + 0x6aa9b844); // 0x1011cdd
    int32_t v4; // 0x1011cd1
    char v5 = v4; // 0x1011cdd
    *v3 = *v3 | v5;
    char * v6 = (char *)(v4 - 0x2a5d03bb); // 0x1011ce3
    *v6 = *v6 + v5;
    int32_t result; // 0x1011cd1
    return result;
}

// Address range: 0x1011cec - 0x1011cf3
int32_t function_1011cec(void) {
    // 0x1011cec
    return function_7e80476();
}

// Address range: 0x1011cf6 - 0x1011cfa
int32_t function_1011cf6(void) {
    // 0x1011cf6
    int32_t v1; // 0x1011cf6
    return v1 + 141 & 255 | v1 & -256;
}

// Address range: 0x1011d2b - 0x1011d32
int32_t function_1011d2b(void) {
    // 0x1011d2b
    return function_8cf9a887();
}

// Address range: 0x1011d36 - 0x1011d39
int32_t function_1011d36(int32_t a1) {
    // 0x1011d36
    int32_t result; // 0x1011d36
    return result;
}

// Address range: 0x1011d81 - 0x1011dd2
int32_t function_1011d81(void) {
    // 0x1011d81
    int32_t v1; // 0x1011d81
    bool v2; // 0x1011d81
    *(char *)v1 = (char)v2 + (char)v1;
    int32_t v3; // 0x1011d81
    int32_t * v4 = (int32_t *)(v3 - 16); // 0x1011d84
    int32_t v5; // 0x1011d81
    *v4 = *v4 + v5;
    unknown_2ee95c19(0);
    int32_t v6; // 0x1011d81
    int32_t v7 = v6 + 1; // 0x1011d92
    int32_t v8; // 0x1011d81
    *(int32_t *)v8 = 0;
    int32_t v9; // 0x1011d81
    int32_t v10; // 0x1011d81
    *(int32_t *)v9 = *(int32_t *)(v10 + 4);
    *(int32_t *)(v9 - 4) = *(int32_t *)(v9 + 101);
    int32_t v11 = *(int32_t *)(v10 + 0x753e044e) ^ v10; // 0x1011da6
    int32_t * v12 = (int32_t *)(2 * v11 + v7); // 0x1011dac
    *v12 = v7;
    uint32_t v13 = *v12;
    int32_t v14 = v11 + v5; // 0x1011daf
    int32_t v15 = v13 / 256 + v13 & 255 | v13 & -256; // 0x1011db2
    int32_t * v16 = (int32_t *)(v14 - 0x745a0cfe); // 0x1011db8
    *v16 = *v16 / 256;
    char v17 = *(char *)(v8 - 0x745b0cfd) & (char)v14; // 0x1011dbf
    int32_t v18 = v14 & -256 | (int32_t)v17; // 0x1011dc5
    while (v17 != 0) {
        // 0x1011daf
        v13 = v15;
        v14 = v18 + v5;
        v15 = v13 / 256 + v13 & 255 | v13 & -256;
        v16 = (int32_t *)(v14 - 0x745a0cfe);
        *v16 = *v16 / 256;
        v17 = *(char *)(v8 - 0x745b0cfd) & (char)v14;
        v18 = v14 & -256 | (int32_t)v17;
    }
    char v19 = llvm_ctpop_i8(v17); // 0x1011dbf
    __asm_outsd((int16_t)v15, v8);
    return v5 & -0xff01 | 0x8000 * (int32_t)(v17 < 0) | 0x4000 * (int32_t)(v17 == 0) | 1024 * (int32_t)((v19 & 1) == 0) | 512;
}

// Address range: 0x1011e02 - 0x1011e08
int32_t function_1011e02(void) {
    // 0x1011e02
    int32_t result; // 0x1011e02
    return result;
}

// Address range: 0x1011e14 - 0x1011ea3
int32_t function_1011e14(int32_t a1, int32_t a2) {
    // 0x1011e14
    int32_t v1; // 0x1011e14
    bool v2; // 0x1011e14
    bool v3; // 0x1011e14
    bool v4; // 0x1011e14
    if (v3 == v2 != !v4) {
        int32_t v5; // 0x1011e14
        int32_t v6; // 0x1011e14
        if (v6 != 0) {
            v5 = function_1011e02();
        }
        // 0x1011e1a
        if (*(int32_t *)(v1 - 20) != 0) {
            // 0x1011e20
            *(int32_t *)v6 = -v6;
            return v1 - 16;
        }
        int32_t * v7 = (int32_t *)(v1 - 3); // 0x1011e56
        *v7 = *v7 + 4;
        int32_t * v8 = (int32_t *)(v1 + 13); // 0x1011e5a
        *v8 = *v8 - 1;
        return v5 | 139;
    }
    // 0x1011e7b
    int32_t v9; // 0x1011e14
    int32_t * v10 = (int32_t *)(v9 - 0x56ffd9); // 0x1011e7b
    *v10 = *v10 + 1;
    int32_t v11; // 0x1011e14
    bool v12; // 0x1011e14
    int32_t v13 = v11 + 0x100107c + (int32_t)v12; // 0x1011e81
    if (v9 != 0) {
        // 0x1011e72
        uint32_t v14; // 0x1011e14
        return v13 | v14 / 256 & 255;
    }
    int32_t v15 = *(int32_t *)(v1 - 12); // 0x1011e94
    int32_t * v16 = (int32_t *)(v15 - 48); // 0x1011e97
    *v16 = *v16 & *(int32_t *)(v1 + 12);
    __asm_arpl(*(int16_t *)(v15 + 4), (int16_t)v13);
    int32_t * v17 = (int32_t *)v13; // 0x1011e9d
    *v17 = *v17 + v13;
    char * v18 = (char *)v13; // 0x1011e9f
    *v18 = *v18 + (char)v13;
    return function_1011ecf((int32_t)&g125, (int32_t)&g125);
}

// Address range: 0x1011ea3 - 0x1011ecf
int32_t function_1011ea3(void) {
    // 0x1011ea3
    int32_t v1; // 0x1011ea3
    int32_t v2 = *(int32_t *)(v1 + 105); // 0x1011ea3
    int32_t v3; // 0x1011ea3
    int32_t * v4 = (int32_t *)(v3 + 0x1f9cd69); // 0x1011ea6
    int32_t v5; // 0x1011ea3
    *v4 = *v4 - v5;
    int32_t v6 = *(int32_t *)(v5 + 0x418b4c4d); // 0x1011eb0
    int32_t * v7 = (int32_t *)(v5 + 0x458b01f9); // 0x1011ec0
    int32_t v8 = *v7; // 0x1011ec0
    int32_t v9 = v8 + 1; // 0x1011ec0
    *v7 = v9;
    int32_t v10 = __asm_hlt(); // 0x1011ec6
    int32_t v11; // 0x1011ea3
    *(int32_t *)(v10 + 4) = v11 - v6 + (int32_t)(((char)v2 ^ -2) < 126);
    int32_t result = v10; // 0x1011eca
    if (v9 < 0 == (v9 & (v8 ^ -0x80000000)) < 0 == (v9 != 0)) {
        result = function_1011ef3();
    }
    // 0x1011ecc
    return result;
}

// Address range: 0x1011ecf - 0x1011edd
int32_t function_1011ecf(int32_t a1, int32_t a2) {
    // 0x1011ecf
    int32_t v1; // 0x1011ecf
    int32_t * v2 = (int32_t *)(v1 + 0x36ff0875); // 0x1011ed4
    *v2 = *v2 - 1;
    int32_t result; // 0x1011ecf
    __asm_out_4(181, result);
    return result;
}

// Address range: 0x1011ede - 0x1011ee7
int32_t function_1011ede(void) {
    // 0x1011ede
    int32_t v1; // 0x1011ede
    int32_t * v2 = (int32_t *)(v1 - 0x3635a0c2); // 0x1011ede
    *v2 = *v2 - 1;
    int32_t result; // 0x1011ede
    return result;
}

// Address range: 0x1011ef3 - 0x101207e
int32_t function_1011ef3(void) {
    // 0x1011f14
    int32_t v1; // 0x1011ef3
    *(int32_t *)(v1 - 4) = *(int32_t *)(v1 + 29);
    int32_t v2; // 0x1011ef3
    *(int32_t *)(v1 - 8) = v2 | 1;
    return v2 | 233;
}

// Address range: 0x1012080 - 0x101208e
int32_t function_1012080(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1012080
    int32_t result; // 0x1012080
    return result;
}

// Address range: 0x10120bc - 0x1012155
int32_t function_10120bc(void) {
    int32_t v1 = __asm_hlt(); // 0x10120be
    int32_t v2; // 0x10120bc
    int32_t * v3 = (int32_t *)(v2 + 12); // 0x10120c1
    int32_t v4 = *v3; // 0x10120c1
    __asm_iretd();
    *(char *)-0x740bba06 = *(char *)-0x740bba06 + 70;
    int32_t v5 = v1 + 1; // 0x10120d0
    int32_t v6; // 0x10120bc
    *(int32_t *)(v6 - 4) = v5;
    int32_t v7; // 0x10120bc
    int32_t v8 = *(int32_t *)(v7 + 36); // 0x10120d9
    int32_t v9 = v8 - *(int32_t *)(v4 + 4) - *(int32_t *)(v4 + 8); // 0x10120e2
    *v3 = 0;
    int32_t * v10 = (int32_t *)v9; // 0x10120eb
    int32_t v11 = *v10 + v5; // 0x10120eb
    *v10 = v11;
    *(int32_t *)(v1 + 9) = v9;
    int32_t * v12 = (int32_t *)v5; // 0x10120f2
    uint32_t v13 = *v12 * v7; // 0x10120f2
    *(int32_t *)v7 = v13;
    int32_t v14 = v13; // 0x10120f7
    if (v11 != 0) {
        while (true) {
            // 0x10120f2
            v14 *= *v12;
            *(int32_t *)v7 = v14;
        }
    }
    // 0x10120fa
    *(int32_t *)(v2 + 101) = v5;
    function_1007bc1((int32_t)&g125);
    *(int32_t *)(v2 - 78) = 0;
    int32_t v15 = v6 - 8; // 0x101210d
    *(int32_t *)v15 = *(int32_t *)(v7 + 4);
    int32_t v16 = function_1007ba4(); // 0x1012110
    *(int32_t *)(v2 - 8) = v16;
    int32_t v17 = v16 & -256; // 0x101211a
    int32_t v18 = v16 + 13 & 114 | 141; // 0x101211c
    char * v19 = (char *)(v18 | v17); // 0x1012120
    *v19 = *v19 + (char)v18;
    if (v13 >= 4) {
        int32_t v20 = v13 / 4; // 0x1012129
        __asm_outsb((int16_t)v5, *(char *)&v7);
        while (v20 != 1) {
            v20--;
            __asm_outsb((int16_t)v5, *(char *)&v7);
        }
    }
    int32_t v21 = v13 - 1; // 0x101212e
    *(int32_t *)(v13 - 4) = v21;
    *(char *)v5 = -117;
    *(int32_t *)v21 = v15;
    int32_t v22 = v21 - *(int32_t *)(v17 | v18 + 139 & 250 | 4); // 0x101213f
    *(int32_t *)(v13 - 8) = 0x7d83084b;
    __asm_hlt();
    char * v23 = (char *)(v22 - 0x7173f7b8); // 0x1012148
    *v23 = *v23 + (char)v22;
    return function_f922fd55();
}

// Address range: 0x1012158 - 0x1012170
int32_t function_1012158(void) {
    // 0x1012158
    int32_t v1; // 0x1012158
    *(int32_t *)*(int32_t *)(v1 - 20) = 0;
    return function_10018f83();
}

// Address range: 0x1012170 - 0x1012243
int32_t function_1012170(void) {
    // 0x1012170
    int32_t v1; // 0x1012170
    int32_t v2 = v1 - 4;
    int32_t * v3 = (int32_t *)v2;
    *(int32_t *)(v1 - 24) = 1;
    int32_t v4 = unknown_51007bc3(*v3); // 0x101217a
    int32_t * v5; // 0x1012170
    int32_t v6; // 0x1012170
    int32_t v7; // 0x1012170
    int32_t v8; // 0x1012170
    int32_t v9; // 0x1012170
    int32_t v10; // 0x1012170
    int32_t v11; // 0x1012170
    bool v12; // 0x1012170
    bool v13; // 0x1012170
    if (v13 == v12) {
        // 0x1012186
        unknown_73007b8c();
        uint32_t v14; // 0x1012170
        int32_t v15 = __asm_in_5((int16_t)v14); // 0x101218c
        int32_t v16 = v15 & -256 | v15 + 13 & 114 | 141; // 0x1012191
        int32_t v17 = *(int32_t *)(v16 + 106); // 0x1012193
        uint32_t v18 = v8;
        int32_t v19 = v18 / 256 & 255 ^ v18; // 0x101219c
        __asm_rep_movsd_memcpy((char *)v16, (char *)v11, v19);
        int32_t * v20 = (int32_t *)(v18 - 92); // 0x10121a5
        *v20 = *v20 | 106;
        unsigned char v21 = (char)v11; // 0x10121a9
        unsigned char v22 = (char)(v14 / 256) + v21; // 0x10121a9
        int32_t v23 = *(int32_t *)(v17 + 1); // 0x10121ac
        char * v24 = (char *)(v14 - 1); // 0x10121ad
        *v24 = v22 + (char)(v22 < v21) + *v24;
        *(char *)v18 = *(char *)&v8 + (char)v18;
        *(int32_t *)(v23 - 16) = unknown_547c4c();
        v5 = (int32_t *)(v23 - 4);
        v7 = v11 & -256 | (int32_t)v22;
        v10 = v17 + 5;
        v6 = v23;
        v9 = v16 + 1 + 4 * v19;
    } else {
        int32_t result = __asm_int3(); // 0x10121f7
        int32_t v25 = v4 - 1; // 0x10121f8
        v8 = v25;
        bool v26; // 0x1012170
        if (v25 != 0 != v26) {
            // 0x10121fa
            return result;
        }
        char * v27 = (char *)(result + 0x23ffa486); // 0x10121fd
        *v27 = *v27 + (char)result;
        int32_t v28 = v2; // bp-8, 0x1012207
        v5 = v3;
        v7 = v11 & -0xff01 | 0xc000;
        v10 = &v28;
        int32_t v29; // 0x1012170
        bool v30; // 0x1012170
        v9 = (v30 ? -4 : 4) + v29;
    }
    int32_t * v31 = (int32_t *)v7; // 0x1012218
    *v31 = *v31 + 1;
    int32_t result2 = function_101195a(); // 0x101221b
    *(int32_t *)(v10 - 4) = *(int32_t *)(v6 - 8);
    unsigned char v32 = (char)v7; // 0x1012231
    unsigned char v33 = *(char *)v9; // 0x1012231
    int32_t v34 = v7 & -256 | (int32_t)(v32 - v33); // 0x1012231
    *(int32_t *)(v10 - 8) = *v5;
    *(int32_t *)(v10 - 12) = v34;
    uint32_t v35 = v8 & 31; // 0x1012237
    if (v35 != 0) {
        int32_t * v36 = (int32_t *)(v8 - 1); // 0x1012237
        uint32_t v37 = *v36; // 0x1012237
        *v36 = (int32_t)(v33 > v32) << 32 - v35 | v37 >> v35 | (int32_t)((int64_t)v37 << (int64_t)(33 - v35));
    }
    int32_t * v38 = (int32_t *)(v34 + 0x2b99e845); // 0x101223a
    *v38 = *v38 - 1;
    return result2;
}

// Address range: 0x1012243 - 0x1012251
int32_t function_1012243(void) {
    // 0x1012243
    int32_t v1; // 0x1012243
    *(int32_t *)(v1 - 40) = 0;
    *(int32_t *)(v1 - 4) = *(int32_t *)(v1 - 16);
    return function_1012257();
}

// Address range: 0x1012255 - 0x1012257
int32_t function_1012255(void) {
    // 0x1012255
    int32_t result; // 0x1012255
    return result;
}

// Address range: 0x1012257 - 0x1012272
int32_t function_1012257(void) {
    // 0x1012257
    int32_t v1; // 0x1012257
    *(int32_t *)v1 = -v1;
    int32_t v2; // 0x1012257
    unknown_a21a3c(v2 - 8, *(int32_t *)(v2 - 4), 0x69000000);
    return unknown_6b7bc1();
}

// Address range: 0x1012273 - 0x1012275
int32_t function_1012273(void) {
    // 0x1012273
    int32_t result; // 0x1012273
    return result;
}

// Address range: 0x1012275 - 0x101227e
int32_t function_1012275(int32_t a1) {
    // 0x1012275
    return __asm_iretd();
}

// Address range: 0x101228d - 0x10122d9
int32_t function_101228d(int32_t a1) {
    // 0x101228d
    int32_t v1; // 0x101228d
    unsigned char v2 = (char)v1;
    *(char *)v1 = v2 / 16 | 16 * v2;
    int32_t v3; // 0x101228d
    int32_t * v4 = (int32_t *)(v3 + 0x29fff845); // 0x1012293
    *v4 = *v4 - 1;
    int32_t v5; // 0x101228d
    int32_t v6; // 0x101228d
    *(char *)v5 = *(char *)&v5 | (char)v6;
    while (true) {
        // 0x101229c
        __asm_hlt();
    }
}

// Address range: 0x10122eb - 0x1012301
int32_t function_10122eb(int32_t a1) {
    // 0x10122eb
    bool v1; // 0x10122eb
    if (!v1) {
        // 0x10122f6
        int32_t v2; // 0x10122eb
        return unknown_fb007b5a(*(int32_t *)(v2 + 2));
    }
    int32_t v3 = __asm_in(131); // 0x10122ed
    int32_t result; // 0x10122eb
    *(int32_t *)result = a1;
    int32_t v4; // 0x10122eb
    *(int32_t *)(v4 + 4) = v3;
    return result;
}

// Address range: 0x1012314 - 0x101237e
int32_t function_1012314(int32_t a1) {
    // 0x1012314
    abort();
    // UNREACHABLE
}

// Address range: 0x101238e - 0x1012390
int32_t function_101238e(void) {
    int32_t result = function_1012397((int32_t)&g125, (int32_t)&g125, (int32_t)&g125, (int32_t)&g125); // 0x101238e
    return result;
}

// Address range: 0x1012390 - 0x1012395
int32_t function_1012390(int32_t a1) {
    // 0x1012390
    uint32_t v1; // 0x1012390
    int32_t v2; // 0x1012390
    bool v3; // 0x1012390
    return v2 - v1 / 256 + (int32_t)v3 & 255 | v2 & -256;
}

// Address range: 0x1012397 - 0x101239e
int32_t function_1012397(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    // 0x1012397
    int32_t result; // 0x1012397
    return result;
}

// Address range: 0x101239e - 0x10123bd
int32_t function_101239e(int32_t a1) {
    // 0x101239e
    int32_t v1; // 0x101239e
    __asm_in_3((int16_t)v1);
    int32_t v2; // 0x101239e
    int32_t v3; // 0x101239e
    int32_t v4; // 0x101239e
    int16_t v5; // 0x101239e
    unknown_80730000(v5, v2, v3, v4);
    return unknown_b200674c();
}

// Address range: 0x10123df - 0x10123eb
int32_t function_10123df(void) {
    // 0x10123df
    int32_t v1; // 0x10123df
    int32_t * v2 = (int32_t *)(v1 + 0x689fc45); // 0x10123df
    *v2 = *v2 - 1;
    int32_t result; // 0x10123df
    return result;
}

// Address range: 0x10123eb - 0x101246c
int32_t function_10123eb(void) {
    // 0x10123eb
    int32_t v1; // 0x10123eb
    if (v1 == -1) {
        // 0x10123fb
        int32_t v2; // 0x10123eb
        return 0x10000 * v2 / 0x10000;
    }
    // 0x10123ff
    abort();
    // UNREACHABLE
}

// Address range: 0x101246e - 0x101246f
int32_t function_101246e(int32_t a1) {
    // 0x101246e
    int32_t result; // 0x101246e
    return result;
}

// Address range: 0x101246f - 0x1012643
int32_t function_101246f(int32_t a1) {
    // 0x101246f
    int32_t v1; // 0x101246f
    *(char *)(v1 + 93) = -1;
    int32_t v2; // 0x101246f
    int32_t v3 = v2;
    *(char *)v3 = *(char *)&v2 | (char)v3;
    int32_t v4; // 0x101246f
    int32_t v5; // 0x101246f
    int32_t result; // 0x101246f
    *(int32_t *)v5 = v5 - v1 + (int32_t)(v2 + 1 > -2 - v4 - result);
    return result;
}

// Address range: 0x1012644 - 0x101266f
int32_t function_1012644(void) {
    // 0x1012644
    __asm_int3();
    __asm_int3();
    int16_t v1; // 0x1012644
    int32_t v2 = unknown_cccccccc(v1); // 0x1012649
    int32_t v3 = v2 & -214; // 0x1012653
    int32_t v4; // 0x1012644
    bool v5; // 0x1012644
    int32_t v6 = (v5 ? -4 : 4) + v4; // 0x1012655
    char * v7 = (char *)v3; // 0x1012656
    *v7 = *v7 + (char)v3;
    int32_t v8; // 0x1012644
    __writefsdword(v6, v8);
    int16_t v9 = (int16_t)*(int32_t *)(v3 - 58); // 0x1012665
    __asm_outsd(v9, v8);
    *(char *)v6 = __asm_insb(v9);
    return v2 & -256;
}

// Address range: 0x1012670 - 0x1012676
int32_t function_1012670(int32_t a1) {
    // 0x1012670
    int32_t result; // 0x1012670
    return result;
}

// Address range: 0x1012678 - 0x101267d
int32_t function_1012678(void) {
    // 0x1012678
    int32_t result; // 0x1012678
    __asm_out_6(36, (char)result);
    return result;
}

// Address range: 0x10126b0 - 0x10126c1
int32_t function_10126b0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x10126b0
    int32_t v1; // 0x10126b0
    int32_t v2; // 0x10126b0
    int32_t * v3 = (int32_t *)(v1 + 44 + v2); // 0x10126b0
    int32_t result; // 0x10126b0
    *v3 = *v3 + result;
    function_101b112();
    return result;
}

// Address range: 0x10126c1 - 0x10126f1
int32_t function_10126c1(void) {
    // 0x10126c1
    __asm_int3();
    __asm_int3();
    int32_t v1 = __asm_int3(); // 0x10126c5
    uint32_t v2; // 0x10126c1
    uint32_t v3; // 0x10126c1
    int32_t v4 = v3 - v2; // 0x10126ce
    int32_t v5; // 0x10126c1
    char v6 = *(char *)(v5 + 0xb14248f); // 0x10126d0
    *(char *)0x4c8bf475 = (char)v1;
    uint32_t v7 = *(int32_t *)(v2 + 12); // 0x10126dd
    int32_t result = v7 / (v4 & -256 | (int32_t)((char)v4 + (char)(v3 < v2) - v6)) & -139; // 0x10126e9
    *(int32_t *)-0x74c4740f = result;
    return result;
}

// Address range: 0x101270e - 0x1012715
int32_t function_101270e(void) {
    // 0x101270e
    return function_39d302dc();
}

// Address range: 0x1012758 - 0x101275b
int32_t function_1012758(int32_t a1) {
    // 0x1012758
    int32_t result; // 0x1012758
    return result;
}

// Address range: 0x101276c - 0x1012770
float80_t function_101276c(int32_t a1) {
    // 0x101276c
    __asm_int3();
    __asm_int3();
    float80_t result; // 0x101276c
    return result;
}

// Address range: 0x1012770 - 0x1012789
int32_t function_1012770(int32_t a1, int32_t a2) {
    int32_t * v1 = (int32_t *)a2; // 0x101277e
    *v1 = *v1 | -117;
    return (a1 & -249) + 1;
}

// Address range: 0x1012789 - 0x10127a2
int32_t function_1012789(void) {
    // 0x1012789
    int32_t v1; // 0x1012789
    int32_t v2; // 0x1012789
    __asm_out_4(225, v2 * v1 & -256);
    return function_1012770((int32_t)&g125, (int32_t)&g125);
}

// Address range: 0x10127a2 - 0x10127a3
int32_t function_10127a2(void) {
    // 0x10127a2
    int32_t result; // 0x10127a2
    return result;
}

// Address range: 0x10127a3 - 0x10127b0
void function_10127a3(void (**First)(), void (**Last)()) {
    // 0x10127a3
    _initterm(First, Last);
}

// Address range: 0x10127b0 - 0x10127c2
int32_t function_10127b0(void) {
    // 0x10127b0
    int32_t v1; // 0x10127b0
    char * v2 = (char *)(v1 + 89); // 0x10127be
    int32_t v3; // 0x10127b0
    *v2 = *v2 + (char)v3;
    int32_t result; // 0x10127b0
    return result;
}

// Address range: 0x10127c2 - 0x10127c5
int32_t function_10127c2(void) {
    // 0x10127c2
    return 0;
}

// Address range: 0x10127c8 - 0x10127c9
int32_t function_10127c8(int32_t * a1, int32_t a2) {
    // 0x10127c8
    int32_t result; // 0x10127c8
    return result;
}

// Address range: 0x10127e2 - 0x1012801
int32_t function_10127e2(int32_t a1) {
    // 0x10127e2
    int32_t v1; // 0x10127e2
    char * v2 = (char *)(v1 - 0x55efdb94); // 0x10127e2
    int32_t v3; // 0x10127e2
    bool v4; // 0x10127e2
    char v5 = (char)v4 + (char)v3 + *v2; // 0x10127e2
    *v2 = v5;
    int32_t result; // 0x10127e2
    if (v3 != 1 && v5 != 0) {
        result = function_1012867();
    }
    // 0x10127ea
    int32_t v6; // bp-12, 0x10127e2
    *(int32_t *)(v1 - 122) = (int32_t)&v6;
    *(int32_t *)(v1 - 2) = -0xed01;
    *(int32_t *)(v1 - 6) = result;
    return result;
}

// Address range: 0x1012801 - 0x1012810
int32_t function_1012801(int32_t a1, int32_t a2) {
    // 0x1012801
    int32_t v1; // 0x1012801
    int32_t v2 = *(int32_t *)(v1 + 73); // 0x1012801
    int32_t * v3 = (int32_t *)(v2 + 0xf0000d); // 0x1012804
    *v3 = *v3 | v2;
    char * v4 = (char *)(v2 + 95); // 0x101280a
    int32_t v5; // 0x1012801
    *v4 = *v4 + (char)v5;
    int32_t result; // 0x1012801
    return result;
}

// Address range: 0x1012811 - 0x1012812
int32_t function_1012811(void) {
    // 0x1012811
    int32_t result; // 0x1012811
    return result;
}

// Address range: 0x1012812 - 0x1012847
int32_t function_1012812(void) {
    // 0x1012812
    function_10127c8(&g2, 20);
    int32_t v1; // 0x1012812
    *(int32_t *)(v1 - 4) = 0;
    int32_t v2 = function_1012877(); // 0x1012828
    char * v3 = (char *)(v2 - 50); // 0x101282f
    *v3 = *v3 | (char)v2;
    int32_t v4; // 0x1012812
    char * v5 = (char *)(v4 + 0x55ff082c); // 0x1012832
    unsigned char v6 = *v5; // 0x1012832
    *v5 = v6 / 2 | 128 * v6;
    int32_t v7; // 0x1012812
    __asm_in_5((int16_t)v7);
    *(int32_t *)(v4 - 4) = -1;
    return function_1012801((int32_t)&g125, (int32_t)&g125);
}

// Address range: 0x1012855 - 0x1012856
int32_t function_1012855(void) {
    // 0x1012855
    int32_t result; // 0x1012855
    return result;
}

// Address range: 0x1012867 - 0x101286b
int32_t function_1012867(void) {
    // 0x1012867
    int32_t result; // 0x1012867
    return result;
}

// Address range: 0x101286b - 0x1012870
int32_t function_101286b(void) {
    // 0x101286b
    return function_1012877();
}

// Address range: 0x1012877 - 0x101287f
int32_t function_1012877(void) {
    // 0x1012877
    int32_t v1; // 0x1012877
    int32_t v2 = v1 | 104; // 0x1012877
    char * v3 = (char *)v2; // 0x1012879
    int32_t v4; // 0x1012877
    *v3 = *v3 + (char)v4;
    int32_t v5; // 0x1012877
    return v2 + v5;
}

// Address range: 0x1012896 - 0x1012897
int32_t function_1012896(void) {
    // 0x1012896
    int32_t result; // 0x1012896
    return result;
}

// Address range: 0x10128a1 - 0x10128a6
int32_t function_10128a1(void) {
    // 0x10128a1
    return function_1012896();
}

// Address range: 0x10128a6 - 0x10128be
int32_t function_10128a6(void) {
    // 0x10128a6
    int16_t v1; // 0x10128a6
    unknown_9185fe(v1);
    int32_t v2; // 0x10128a6
    int32_t * v3 = (int32_t *)(v2 - 4); // 0x10128ad
    *v3 = *v3 | -67;
    unknown_f10128be();
    return function_1012801((int32_t)&g125, (int32_t)&g125);
}

// Address range: 0x10128c3 - 0x10128ee
int32_t function_10128c3(void) {
    // 0x10128c3
    int32_t v1; // 0x10128c3
    int32_t v2; // 0x10128c3
    int32_t v3; // 0x10128c3
    bool v4; // 0x10128c3
    if (v3 + v2 == (int32_t)v4) {
        // 0x10128d0
        return unknown_d3012818(*(int32_t *)(v1 - 105));
    }
    // 0x10128c7
    function_1012855();
    *(int32_t *)0x121825 = *(int32_t *)0x121825 + v1;
    return _3f_terminate_40__40_YAXXZ();
}

// Address range: 0x10128ee - 0x101290c
int32_t function_10128ee(void) {
    // 0x10128ee
    int32_t v1; // 0x10128ee
    *(int32_t *)v1 = ((int32_t)*(char *)0x29f4b8ff | 0x1012900) + v1;
    int16_t v2; // 0x10128ee
    return unknown_1edd3c(v2);
}

// Address range: 0x101290c - 0x1012916
int32_t function_101290c(void) {
    // 0x101290c
    return 0x1012b14;
}

// Address range: 0x1012916 - 0x1012920
int32_t function_1012916(void) {
    // 0x1012916
    return function_101103c();
}

// Address range: 0x1012920 - 0x1012923
int32_t function_1012920(void) {
    // 0x1012920
    int32_t result; // 0x1012920
    return result;
}

// Address range: 0x10129d0 - 0x10129d6
int32_t function_10129d0(int32_t a1, int32_t a2) {
    // 0x10129d0
    int32_t v1; // 0x10129d0
    *(char *)v1 = 2 * (char)v1;
    int32_t result; // 0x10129d0
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    return result;
}

// Address range: 0x1012a8f - 0x1012ab2
int32_t function_1012a8f(void) {
    // 0x1012a8f
    int32_t v1; // 0x1012a8f
    *(char *)v1 = 2 * (char)v1;
    char * v2 = (char *)(v1 - 0x17f8ddc0); // 0x1012a97
    int32_t v3; // 0x1012a8f
    *v2 = *v2 + (char)v3;
    int32_t v4; // 0x1012a8f
    char v5 = v4;
    char * v6 = (char *)v4; // 0x1012aa4
    *v6 = 2 * v5;
    *v6 = *(char *)&v4 + v5;
    *(char *)(v4 + 32) = v5;
    int32_t v7; // 0x1012a8f
    *(int32_t *)v3 = v3 + v7;
    int32_t v8; // 0x1012a8f
    return function_51a82ab1(*(int32_t *)(v8 + 0x1b01004b));
}

// Address range: 0x1012af0 - 0x1012af1
int32_t function_1012af0(int32_t a1) {
    // 0x1012af0
    int32_t result; // 0x1012af0
    return result;
}

// Address range: 0x1012b12 - 0x1012b2c
int32_t function_1012b12(void) {
    // 0x1012b12
    int32_t v1; // 0x1012b12
    int32_t * v2 = (int32_t *)(v1 + 0x8199305); // 0x1012b12
    *v2 = *v2 + v1;
    int32_t v3; // 0x1012b12
    int32_t v4 = v3;
    *(char *)v4 = *(char *)&v3 + (char)v4;
    int32_t v5; // 0x1012b12
    int32_t v6; // 0x1012b12
    char * v7 = (char *)(v6 + 1 + 2 * v5); // 0x1012b1b
    *v7 = *v7 + (char)v3;
    int32_t * v8 = (int32_t *)(2 * v3); // 0x1012b1f
    *v8 = *v8 + v3;
    int32_t v9; // 0x1012b12
    *(char *)v9 = (char)v3;
    return unknown_101();
}

// Address range: 0x1012b2d - 0x1012b33
int32_t function_1012b2d(void) {
    // 0x1012b2d
    int32_t result; // 0x1012b2d
    *(char *)result = 2 * (char)result;
    return result;
}

// Address range: 0x1012b40 - 0x1012b80
int32_t function_1012b40(void) {
    // 0x1012b40
    uint32_t v1; // 0x1012b40
    char * v2 = (char *)(v1 + 0x40880000); // 0x1012b40
    int32_t v3; // 0x1012b40
    *v2 = *v2 + (char)v3;
    int32_t v4; // 0x1012b40
    *(int32_t *)v1 = v4 + v1;
    int32_t v5 = unknown_a0012ac7(); // 0x1012b48
    char * v6 = (char *)v5; // 0x1012b52
    *v6 = *v6 + (char)v5;
    int32_t v7 = v5 + 0x100ea00; // 0x1012b54
    char * v8 = (char *)v7; // 0x1012b5a
    *v8 = *v8 + (char)v7;
    int32_t v9; // 0x1012b40
    *(int32_t *)275 = *(int32_t *)275 + v9;
    *(int32_t *)v9 = v3 + v9;
    int32_t v10 = v7 - v1 + 0x21993; // 0x1012b65
    int32_t v11 = v10 + v1 / 256; // 0x1012b6a
    int32_t v12 = v11 & 255 | v10 & -256; // 0x1012b6a
    int32_t * v13 = (int32_t *)v12; // 0x1012b70
    *v13 = *v13 + v12;
    char * v14 = (char *)v12; // 0x1012b72
    *v14 = *v14 + (char)v11;
    __asm_out_6(0, 0);
    abort();
    // UNREACHABLE
}

// Address range: 0x1012feb - 0x1012fec
int32_t function_1012feb(void) {
    // 0x1012feb
    int32_t result; // 0x1012feb
    return result;
}

// Address range: 0x1013026 - 0x1013027
int32_t function_1013026(void) {
    // 0x1013026
    int32_t result; // 0x1013026
    return result;
}

// Address range: 0x101313a - 0x101313b
int32_t function_101313a(void) {
    // 0x101313a
    int32_t result; // 0x101313a
    return result;
}

// Address range: 0x10131b6 - 0x10131b7
int32_t function_10131b6(int32_t a1) {
    // 0x10131b6
    int32_t result; // 0x10131b6
    return result;
}

// Address range: 0x10133b8 - 0x10133b9
int32_t function_10133b8(void) {
    // 0x10133b8
    int32_t result; // 0x10133b8
    return result;
}

// Address range: 0x1013454 - 0x1013455
int32_t function_1013454(char * a1, int32_t a2, int32_t * a3, int32_t a4) {
    // 0x1013454
    int32_t result; // 0x1013454
    return result;
}

// Address range: 0x1013c73 - 0x1013c74
int32_t function_1013c73(int32_t a1, int32_t a2) {
    // 0x1013c73
    int32_t result; // 0x1013c73
    return result;
}

// Address range: 0x101427e - 0x1014301
int32_t function_101427e(void) {
    // 0x101427e
    int32_t v1; // 0x101427e
    *(char *)v1 = 2 * (char)v1;
    int32_t v2; // 0x101427e
    int32_t v3; // 0x101427e
    *(char *)v2 = __asm_insb((int16_t)v3);
    int32_t v4; // 0x101427e
    int32_t v5 = v4;
    *(char *)v5 = *(char *)&v4 + (char)v5;
    *(char *)v3 = *(char *)&v3 + (char)(v4 / 256);
    int32_t v6 = v4;
    *(char *)v6 = *(char *)&v4 + (char)v6;
    __asm_arpl(*(int16_t *)&v4, (int16_t)v4);
    int32_t v7 = v4;
    *(char *)v7 = *(char *)&v4 + (char)v7;
    int32_t v8 = v4;
    __writefsbyte(v8, __readfsbyte(v4) + (char)v8);
    int32_t v9; // 0x101427e
    *(char *)v9 = *(char *)&v9 + (char)(v3 / 256);
    int32_t v10 = v4;
    *(char *)v10 = *(char *)&v4 + (char)v10;
    int32_t v11; // 0x101427e
    __asm_outsd((int16_t)v3, v11);
    int32_t v12 = v4;
    *(char *)v12 = *(char *)&v4 + (char)v12;
    *(char *)v3 = *(char *)&v3 + (char)v4;
    int32_t v13 = v4;
    *(char *)v13 = *(char *)&v4 + (char)v13;
    int32_t v14; // 0x101427e
    *(char *)v4 = *(char *)&v4 + (char)v14;
    int32_t v15 = v4;
    *(char *)v15 = *(char *)&v4 + (char)v15;
    *(char *)v3 = *(char *)&v3 + (char)v14;
    int32_t v16 = v4;
    *(char *)v16 = *(char *)&v4 + (char)v16;
    *(char *)v4 = *(char *)&v4 + (char)v3;
    int32_t v17 = v4;
    *(char *)v17 = *(char *)&v4 + (char)v17;
    *(char *)v14 = *(char *)&v14 + (char)v4;
    int32_t v18 = v4;
    *(char *)v18 = *(char *)&v4 + (char)v18;
    *(char *)v11 = *(char *)&v11 + (char)(v3 / 256);
    int32_t v19 = v4;
    *(char *)v19 = *(char *)&v4 + (char)v19;
    int32_t v20 = v4;
    *(char *)v20 = *(char *)&v4 + (char)v20;
    int32_t v21 = v4;
    *(char *)v21 = *(char *)&v4 + (char)v21;
    int32_t v22 = v4;
    *(char *)v22 = *(char *)&v4 + (char)v22;
    int32_t v23 = v4;
    *(char *)v23 = *(char *)&v4 + (char)v23;
    int32_t v24 = v4;
    *(char *)v24 = *(char *)&v4 + (char)v24;
    int32_t v25 = v2 + v4; // 0x10142c1
    int32_t * v26 = (int32_t *)v2; // 0x10142c1
    *v26 = v25;
    char * v27 = (char *)(v14 - 0x6affffff); // 0x10142c3
    *v27 = *v27 + (char)v3;
    *v26 = v25;
    char * v28 = (char *)(v9 - 0x6bffffff); // 0x10142cb
    *v28 = *v28 + (char)v3;
    *v26 = v25;
    char * v29 = (char *)(v2 + 0x19a0000 + v14); // 0x10142d3
    *v29 = *v29 + (char)v3;
    char v30 = v2; // 0x10142da
    *(char *)v2 = *(char *)&v2 + v30;
    int32_t result; // 0x101427e
    int32_t v31 = result + v2; // 0x10142dd
    int32_t * v32 = (int32_t *)result; // 0x10142dd
    *v32 = v31;
    char * v33 = (char *)(v2 - 0x6dffffff); // 0x10142df
    *v33 = *v33 + v30;
    *v32 = v31;
    char * v34 = (char *)(v14 - 0x69ffffff); // 0x10142e7
    *v34 = *v34 + v30;
    *v32 = v31;
    char * v35 = (char *)(result - 0x69ffffff); // 0x10142ef
    *v35 = *v35 + v30;
    *v32 = v31;
    char v36 = result; // 0x10142f7
    char * v37 = (char *)result; // 0x10142f7
    *v37 = *(char *)&result + v36;
    *v37 = *(char *)&result + v36;
    *v37 = *(char *)&result + v36;
    *v37 = *(char *)&result + v36;
    return result;
}

// Address range: 0x10149bc - 0x1014a00
int32_t function_10149bc(int32_t a1) {
    // 0x10149bc
    int32_t v1; // 0x10149bc
    *(int32_t *)v1 = 2 * v1;
    int32_t result; // 0x10149bc
    int32_t v2 = result;
    *(char *)v2 = *(char *)&result + (char)v2;
    int32_t v3 = result;
    *(char *)v3 = *(char *)&result + (char)v3;
    int32_t v4 = result;
    *(char *)v4 = *(char *)&result + (char)v4;
    int32_t v5 = result;
    *(int32_t *)v5 = 2 * v5;
    int32_t v6 = result;
    *(char *)v6 = *(char *)&result + (char)v6;
    int32_t v7 = result;
    *(char *)v7 = *(char *)&result + (char)v7;
    int32_t v8 = result;
    *(char *)v8 = *(char *)&result + (char)v8;
    int32_t v9 = result;
    *(char *)v9 = *(char *)&result + (char)v9;
    int32_t v10 = result;
    *(char *)v10 = *(char *)&result + (char)v10;
    int32_t v11 = result;
    *(int32_t *)v11 = 2 * v11;
    int32_t v12 = result;
    *(char *)v12 = *(char *)&result + (char)v12;
    int32_t v13 = result;
    *(char *)v13 = *(char *)&result + (char)v13;
    int32_t v14 = result;
    *(char *)v14 = *(char *)&result + (char)v14;
    int32_t v15 = result;
    *(char *)v15 = *(char *)&result + (char)v15;
    int32_t v16 = result;
    *(char *)v16 = *(char *)&result + (char)v16;
    int32_t v17 = result;
    *(char *)v17 = *(char *)&result + (char)v17;
    int32_t v18 = result;
    *(char *)v18 = *(char *)&result + (char)v18;
    int32_t v19 = result;
    *(char *)v19 = *(char *)&result + (char)v19;
    int32_t v20 = result;
    *(char *)v20 = *(char *)&result + (char)v20;
    int32_t v21 = result;
    *(char *)v21 = *(char *)&result + (char)v21;
    int32_t v22 = result;
    *(char *)v22 = *(char *)&result + (char)v22;
    int32_t v23 = result;
    *(char *)v23 = *(char *)&result + (char)v23;
    int32_t v24 = result;
    *(char *)v24 = *(char *)&result + (char)v24;
    int32_t v25 = result;
    *(char *)v25 = *(char *)&result + (char)v25;
    int32_t v26 = result;
    *(char *)v26 = *(char *)&result + (char)v26;
    int32_t v27 = result;
    *(char *)v27 = *(char *)&result + (char)v27;
    int32_t v28 = result;
    *(char *)v28 = *(char *)&result + (char)v28;
    int32_t v29 = result;
    *(char *)v29 = *(char *)&result + (char)v29;
    int32_t v30 = result;
    *(char *)v30 = *(char *)&result + (char)v30;
    int32_t v31 = result;
    *(char *)v31 = *(char *)&result + (char)v31;
    int32_t v32 = result;
    *(char *)v32 = *(char *)&result + (char)v32;
    int32_t v33 = result;
    *(char *)v33 = *(char *)&result + (char)v33;
    int32_t v34 = result;
    *(char *)v34 = *(char *)&result + (char)v34;
    return result;
}

// Address range: 0x1014bc1 - 0x1014bc2
int32_t function_1014bc1(int32_t a1) {
    // 0x1014bc1
    int32_t result; // 0x1014bc1
    return result;
}

// Address range: 0x1015257 - 0x1015258
int32_t function_1015257(void) {
    // 0x1015257
    int32_t result; // 0x1015257
    return result;
}

// Address range: 0x1015fef - 0x1015ff0
int32_t function_1015fef(void) {
    // 0x1015fef
    int32_t result; // 0x1015fef
    return result;
}

// Address range: 0x101636f - 0x1016370
int32_t function_101636f(int32_t a1) {
    // 0x101636f
    int32_t result; // 0x101636f
    return result;
}

// Address range: 0x1017418 - 0x1017419
int32_t function_1017418(int32_t a1) {
    // 0x1017418
    int32_t result; // 0x1017418
    return result;
}

// Address range: 0x1017570 - 0x1017571
int32_t function_1017570(int32_t a1, int32_t a2, int32_t a3) {
    // 0x1017570
    int32_t result; // 0x1017570
    return result;
}

// Address range: 0x101763c - 0x101763d
int32_t function_101763c(int32_t a1, int32_t a2) {
    // 0x101763c
    int32_t result; // 0x101763c
    return result;
}

// Address range: 0x1017d65 - 0x1017d66
int32_t function_1017d65(void) {
    // 0x1017d65
    int32_t result; // 0x1017d65
    return result;
}

// Address range: 0x10194f5 - 0x10194f6
int32_t function_10194f5(void) {
    // 0x10194f5
    int32_t result; // 0x10194f5
    return result;
}

// Address range: 0x101a670 - 0x101a671
int32_t function_101a670(int32_t a1) {
    // 0x101a670
    int32_t result; // 0x101a670
    return result;
}

// Address range: 0x101b112 - 0x101b113
int32_t function_101b112(void) {
    // 0x101b112
    int32_t result; // 0x101b112
    return result;
}

// Address range: 0x1036cb2 - 0x1036cb3
int32_t function_1036cb2(void) {
    // 0x1036cb2
    int32_t result; // 0x1036cb2
    return result;
}

// Address range: 0x1053dd7 - 0x1053dd8
int32_t function_1053dd7(void) {
    // 0x1053dd7
    int32_t result; // 0x1053dd7
    return result;
}

// Address range: 0x1146521 - 0x1146522
int32_t function_1146521(void) {
    // 0x1146521
    int32_t result; // 0x1146521
    return result;
}

// Address range: 0x11681a6 - 0x11681a7
int32_t function_11681a6(int32_t a1) {
    // 0x11681a6
    int32_t result; // 0x11681a6
    return result;
}

// Address range: 0x11e3246 - 0x11e3247
int32_t function_11e3246(int32_t a1) {
    // 0x11e3246
    int32_t result; // 0x11e3246
    return result;
}

// Address range: 0x11e6336 - 0x11e6337
int32_t function_11e6336(void) {
    // 0x11e6336
    int32_t result; // 0x11e6336
    return result;
}

// Address range: 0x1301c78 - 0x1301c79
int32_t function_1301c78(void) {
    // 0x1301c78
    int32_t result; // 0x1301c78
    return result;
}

// Address range: 0x131c1d3 - 0x131c1d4
int32_t function_131c1d3(void) {
    // 0x131c1d3
    int32_t result; // 0x131c1d3
    return result;
}

// Address range: 0x13270a7 - 0x13270a8
int32_t function_13270a7(void) {
    // 0x13270a7
    int32_t result; // 0x13270a7
    return result;
}

// Address range: 0x132ce93 - 0x132ce94
int32_t function_132ce93(void) {
    // 0x132ce93
    int32_t result; // 0x132ce93
    return result;
}

// Address range: 0x13a4f3e - 0x13a4f3f
int32_t function_13a4f3e(void) {
    // 0x13a4f3e
    int32_t result; // 0x13a4f3e
    return result;
}

// Address range: 0x13b4e95 - 0x13b4e96
int32_t function_13b4e95(void) {
    // 0x13b4e95
    int32_t result; // 0x13b4e95
    return result;
}

// Address range: 0x1496049 - 0x149604a
int32_t function_1496049(void) {
    // 0x1496049
    int32_t result; // 0x1496049
    return result;
}

// Address range: 0x14d90a1 - 0x14d90a2
int32_t function_14d90a1(void) {
    // 0x14d90a1
    int32_t result; // 0x14d90a1
    return result;
}

// Address range: 0x154c44d - 0x154c44e
int32_t function_154c44d(void) {
    // 0x154c44d
    int32_t result; // 0x154c44d
    return result;
}

// Address range: 0x1655726 - 0x1655727
int32_t function_1655726(void) {
    // 0x1655726
    int32_t result; // 0x1655726
    return result;
}

// Address range: 0x16e6998 - 0x16e6999
int32_t function_16e6998(void) {
    // 0x16e6998
    int32_t result; // 0x16e6998
    return result;
}

// Address range: 0x17159c1 - 0x17159c2
int32_t function_17159c1(void) {
    // 0x17159c1
    int32_t result; // 0x17159c1
    return result;
}

// Address range: 0x17f42eb - 0x17f42ec
int32_t function_17f42eb(void) {
    // 0x17f42eb
    int32_t result; // 0x17f42eb
    return result;
}

// Address range: 0x18993b3 - 0x18993b4
int32_t function_18993b3(void) {
    // 0x18993b3
    int32_t result; // 0x18993b3
    return result;
}

// Address range: 0x193fc40 - 0x193fc41
int32_t function_193fc40(void) {
    // 0x193fc40
    int32_t result; // 0x193fc40
    return result;
}

// Address range: 0x1985792 - 0x1985793
int32_t function_1985792(void) {
    // 0x1985792
    int32_t result; // 0x1985792
    return result;
}

// Address range: 0x1c48996 - 0x1c48997
int32_t function_1c48996(void) {
    // 0x1c48996
    int32_t result; // 0x1c48996
    return result;
}

// Address range: 0x1df3232 - 0x1df3233
int32_t function_1df3232(void) {
    // 0x1df3232
    int32_t result; // 0x1df3232
    return result;
}

// Address range: 0x1ee7a24 - 0x1ee7a25
int32_t function_1ee7a24(void) {
    // 0x1ee7a24
    int32_t result; // 0x1ee7a24
    return result;
}

// Address range: 0x1f321f2 - 0x1f321f3
int32_t function_1f321f2(void) {
    // 0x1f321f2
    int32_t result; // 0x1f321f2
    return result;
}

// Address range: 0x2008cab - 0x2008cac
int32_t function_2008cab(void) {
    // 0x2008cab
    int32_t result; // 0x2008cab
    return result;
}

// Address range: 0x3116931 - 0x3116932
int32_t function_3116931(void) {
    // 0x3116931
    int32_t result; // 0x3116931
    return result;
}

// Address range: 0x3ea39e1 - 0x3ea39e2
int32_t function_3ea39e1(void) {
    // 0x3ea39e1
    int32_t result; // 0x3ea39e1
    return result;
}

// Address range: 0x5fc52ca - 0x5fc52cb
int32_t function_5fc52ca(void) {
    // 0x5fc52ca
    int32_t result; // 0x5fc52ca
    return result;
}

// Address range: 0x7e80476 - 0x7e80477
int32_t function_7e80476(void) {
    // 0x7e80476
    int32_t result; // 0x7e80476
    return result;
}

// Address range: 0x924968f - 0x9249690
int32_t function_924968f(void) {
    // 0x924968f
    int32_t result; // 0x924968f
    return result;
}

// Address range: 0xb0059b5 - 0xb0059b6
int32_t function_b0059b5(void) {
    // 0xb0059b5
    int32_t result; // 0xb0059b5
    return result;
}

// Address range: 0xc8d046d - 0xc8d046e
int32_t function_c8d046d(void) {
    // 0xc8d046d
    int32_t result; // 0xc8d046d
    return result;
}

// Address range: 0xd0138a2 - 0xd0138a3
int32_t function_d0138a2(void) {
    // 0xd0138a2
    int32_t result; // 0xd0138a2
    return result;
}

// Address range: 0xd6783ab - 0xd6783ac
int32_t function_d6783ab(void) {
    // 0xd6783ab
    int32_t result; // 0xd6783ab
    return result;
}

// Address range: 0xd953527 - 0xd953528
int32_t function_d953527(void) {
    // 0xd953527
    int32_t result; // 0xd953527
    return result;
}

// Address range: 0x10018f83 - 0x10018f84
int32_t function_10018f83(void) {
    // 0x10018f83
    int32_t result; // 0x10018f83
    return result;
}

// Address range: 0x11198154 - 0x11198155
int32_t function_11198154(void) {
    // 0x11198154
    int32_t result; // 0x11198154
    return result;
}

// Address range: 0x14a6bdff - 0x14a6be00
int32_t function_14a6bdff(void) {
    // 0x14a6bdff
    int32_t result; // 0x14a6bdff
    return result;
}

// Address range: 0x15a6c3a9 - 0x15a6c3aa
int32_t function_15a6c3a9(void) {
    // 0x15a6c3a9
    int32_t result; // 0x15a6c3a9
    return result;
}

// Address range: 0x15a6fe64 - 0x15a6fe65
int32_t function_15a6fe64(void) {
    // 0x15a6fe64
    int32_t result; // 0x15a6fe64
    return result;
}

// Address range: 0x1a009b79 - 0x1a009b7a
int32_t function_1a009b79(void) {
    // 0x1a009b79
    int32_t result; // 0x1a009b79
    return result;
}

// Address range: 0x1ae14e0c - 0x1ae14e0d
int32_t function_1ae14e0c(int32_t a1) {
    // 0x1ae14e0c
    int32_t result; // 0x1ae14e0c
    return result;
}

// Address range: 0x1ee9c1c1 - 0x1ee9c1c2
int32_t function_1ee9c1c1(void) {
    // 0x1ee9c1c1
    int32_t result; // 0x1ee9c1c1
    return result;
}

// Address range: 0x24642976 - 0x24642977
int32_t function_24642976(void) {
    // 0x24642976
    int32_t result; // 0x24642976
    return result;
}

// Address range: 0x25a16ea2 - 0x25a16ea3
int32_t function_25a16ea2(void) {
    // 0x25a16ea2
    int32_t result; // 0x25a16ea2
    return result;
}

// Address range: 0x28006e08 - 0x28006e09
int32_t function_28006e08(int32_t a1) {
    // 0x28006e08
    int32_t result; // 0x28006e08
    return result;
}

// Address range: 0x29f2a2d3 - 0x29f2a2d4
int32_t function_29f2a2d3(void) {
    // 0x29f2a2d3
    int32_t result; // 0x29f2a2d3
    return result;
}

// Address range: 0x2b5d1885 - 0x2b5d1886
int32_t function_2b5d1885(void) {
    // 0x2b5d1885
    int32_t result; // 0x2b5d1885
    return result;
}

// Address range: 0x2c08c6c5 - 0x2c08c6c6
int32_t function_2c08c6c5(int32_t a1) {
    // 0x2c08c6c5
    int32_t result; // 0x2c08c6c5
    return result;
}

// Address range: 0x2e016128 - 0x2e016129
int32_t function_2e016128(void) {
    // 0x2e016128
    int32_t result; // 0x2e016128
    return result;
}

// Address range: 0x30a6cae8 - 0x30a6cae9
int32_t function_30a6cae8(void) {
    // 0x30a6cae8
    int32_t result; // 0x30a6cae8
    return result;
}

// Address range: 0x30c6bbc1 - 0x30c6bbc2
int32_t function_30c6bbc1(void) {
    // 0x30c6bbc1
    int32_t result; // 0x30c6bbc1
    return result;
}

// Address range: 0x30cc0c5d - 0x30cc0c5e
int32_t function_30cc0c5d(void) {
    // 0x30cc0c5d
    int32_t result; // 0x30cc0c5d
    return result;
}

// Address range: 0x34a5bebd - 0x34a5bebe
int32_t function_34a5bebd(void) {
    // 0x34a5bebd
    int32_t result; // 0x34a5bebd
    return result;
}

// Address range: 0x3766cfdb - 0x3766cfdc
int32_t function_3766cfdb(void) {
    // 0x3766cfdb
    int32_t result; // 0x3766cfdb
    return result;
}

// Address range: 0x388d0c8d - 0x388d0c8e
int32_t function_388d0c8d(void) {
    // 0x388d0c8d
    int32_t result; // 0x388d0c8d
    return result;
}

// Address range: 0x389bf445 - 0x389bf446
int32_t function_389bf445(void) {
    // 0x389bf445
    int32_t result; // 0x389bf445
    return result;
}

// Address range: 0x39d302dc - 0x39d302dd
int32_t function_39d302dc(void) {
    // 0x39d302dc
    int32_t result; // 0x39d302dc
    return result;
}

// Address range: 0x3a004cae - 0x3a004caf
int32_t function_3a004cae(void) {
    // 0x3a004cae
    int32_t result; // 0x3a004cae
    return result;
}

// Address range: 0x3b0059bb - 0x3b0059bc
int32_t function_3b0059bb(void) {
    // 0x3b0059bb
    int32_t result; // 0x3b0059bb
    return result;
}

// Address range: 0x3bc03357 - 0x3bc03358
int32_t function_3bc03357(int32_t a1) {
    // 0x3bc03357
    int32_t result; // 0x3bc03357
    return result;
}

// Address range: 0x3c01468d - 0x3c01468e
int32_t function_3c01468d(void) {
    // 0x3c01468d
    int32_t result; // 0x3c01468d
    return result;
}

// Address range: 0x3c0d8b04 - 0x3c0d8b05
int32_t function_3c0d8b04(void) {
    // 0x3c0d8b04
    int32_t result; // 0x3c0d8b04
    return result;
}

// Address range: 0x3e4dfecb - 0x3e4dfecc
int32_t function_3e4dfecb(void) {
    // 0x3e4dfecb
    int32_t result; // 0x3e4dfecb
    return result;
}

// Address range: 0x400011a4 - 0x400011a5
int32_t function_400011a4(int32_t a1) {
    // 0x400011a4
    int32_t result; // 0x400011a4
    return result;
}

// Address range: 0x44d716a7 - 0x44d716a8
int32_t function_44d716a7(void) {
    // 0x44d716a7
    int32_t result; // 0x44d716a7
    return result;
}

// Address range: 0x44e13c24 - 0x44e13c25
int32_t function_44e13c24(void) {
    // 0x44e13c24
    int32_t result; // 0x44e13c24
    return result;
}

// Address range: 0x450154ab - 0x450154ac
int32_t function_450154ab(void) {
    // 0x450154ab
    int32_t result; // 0x450154ab
    return result;
}

// Address range: 0x451186ed - 0x451186ee
int32_t function_451186ed(int32_t a1) {
    // 0x451186ed
    int32_t result; // 0x451186ed
    return result;
}

// Address range: 0x45417c2a - 0x45417c2b
int32_t function_45417c2a(void) {
    // 0x45417c2a
    int32_t result; // 0x45417c2a
    return result;
}

// Address range: 0x455affff - 0x455b0000
int32_t function_455affff(void) {
    // 0x455affff
    int32_t result; // 0x455affff
    return result;
}

// Address range: 0x455b7812 - 0x455b7813
int32_t function_455b7812(void) {
    // 0x455b7812
    int32_t result; // 0x455b7812
    return result;
}

// Address range: 0x455d667b - 0x455d667c
int32_t function_455d667b(void) {
    // 0x455d667b
    int32_t result; // 0x455d667b
    return result;
}

// Address range: 0x458b0004 - 0x458b0005
int32_t function_458b0004(void) {
    // 0x458b0004
    int32_t result; // 0x458b0004
    return result;
}

// Address range: 0x4590831c - 0x4590831d
int32_t function_4590831c(void) {
    // 0x4590831c
    int32_t result; // 0x4590831c
    return result;
}

// Address range: 0x45a9ffff - 0x45aa0000
int32_t function_45a9ffff(int32_t a1, int32_t a2) {
    // 0x45a9ffff
    int32_t result; // 0x45a9ffff
    return result;
}

// Address range: 0x46095804 - 0x46095805
int32_t function_46095804(void) {
    // 0x46095804
    int32_t result; // 0x46095804
    return result;
}

// Address range: 0x46795a37 - 0x46795a38
int32_t function_46795a37(void) {
    // 0x46795a37
    int32_t result; // 0x46795a37
    return result;
}

// Address range: 0x468c9169 - 0x468c916a
int32_t function_468c9169(void) {
    // 0x468c9169
    int32_t result; // 0x468c9169
    return result;
}

// Address range: 0x468c925a - 0x468c925b
int32_t function_468c925a(void) {
    // 0x468c925a
    int32_t result; // 0x468c925a
    return result;
}

// Address range: 0x46ad5ad8 - 0x46ad5ad9
int32_t function_46ad5ad8(void) {
    // 0x46ad5ad8
    int32_t result; // 0x46ad5ad8
    return result;
}

// Address range: 0x46d15b49 - 0x46d15b4a
int32_t function_46d15b49(void) {
    // 0x46d15b49
    int32_t result; // 0x46d15b49
    return result;
}

// Address range: 0x47195bca - 0x47195bcb
int32_t function_47195bca(void) {
    // 0x47195bca
    int32_t result; // 0x47195bca
    return result;
}

// Address range: 0x473d5c1a - 0x473d5c1b
int32_t function_473d5c1a(void) {
    // 0x473d5c1a
    int32_t result; // 0x473d5c1a
    return result;
}

// Address range: 0x47f15dad - 0x47f15dae
int32_t function_47f15dad(void) {
    // 0x47f15dad
    int32_t result; // 0x47f15dad
    return result;
}

// Address range: 0x480105fc - 0x480105fd
int32_t function_480105fc(void) {
    // 0x480105fc
    int32_t result; // 0x480105fc
    return result;
}

// Address range: 0x4835ff51 - 0x4835ff52
int32_t function_4835ff51(void) {
    // 0x4835ff51
    int32_t result; // 0x4835ff51
    return result;
}

// Address range: 0x48675eb8 - 0x48675eb9
int32_t function_48675eb8(int32_t a1) {
    // 0x48675eb8
    int32_t result; // 0x48675eb8
    return result;
}

// Address range: 0x492a60d2 - 0x492a60d3
int32_t function_492a60d2(void) {
    // 0x492a60d2
    int32_t result; // 0x492a60d2
    return result;
}

// Address range: 0x49c962ab - 0x49c962ac
int32_t function_49c962ab(void) {
    // 0x49c962ab
    int32_t result; // 0x49c962ab
    return result;
}

// Address range: 0x49d56305 - 0x49d56306
int32_t function_49d56305(void) {
    // 0x49d56305
    int32_t result; // 0x49d56305
    return result;
}

// Address range: 0x4a07f545 - 0x4a07f546
int32_t function_4a07f545(void) {
    // 0x4a07f545
    int32_t result; // 0x4a07f545
    return result;
}

// Address range: 0x4a4463a6 - 0x4a4463a7
int32_t function_4a4463a6(void) {
    // 0x4a4463a6
    int32_t result; // 0x4a4463a6
    return result;
}

// Address range: 0x4a7964e8 - 0x4a7964e9
int32_t function_4a7964e8(void) {
    // 0x4a7964e8
    int32_t result; // 0x4a7964e8
    return result;
}

// Address range: 0x4a89671c - 0x4a89671d
int32_t function_4a89671c(void) {
    // 0x4a89671c
    int32_t result; // 0x4a89671c
    return result;
}

// Address range: 0x4a916539 - 0x4a91653a
int32_t function_4a916539(void) {
    // 0x4a916539
    int32_t result; // 0x4a916539
    return result;
}

// Address range: 0x4a977b0a - 0x4a977b0b
int32_t function_4a977b0a(void) {
    // 0x4a977b0a
    int32_t result; // 0x4a977b0a
    return result;
}

// Address range: 0x4ab063f7 - 0x4ab063f8
int32_t function_4ab063f7(void) {
    // 0x4ab063f7
    int32_t result; // 0x4ab063f7
    return result;
}

// Address range: 0x4ab9680d - 0x4ab9680e
int32_t function_4ab9680d(void) {
    // 0x4ab9680d
    int32_t result; // 0x4ab9680d
    return result;
}

// Address range: 0x4e0a926e - 0x4e0a926f
int32_t function_4e0a926e(void) {
    // 0x4e0a926e
    int32_t result; // 0x4e0a926e
    return result;
}

// Address range: 0x4e8c92f0 - 0x4e8c92f1
int32_t function_4e8c92f0(void) {
    // 0x4e8c92f0
    int32_t result; // 0x4e8c92f0
    return result;
}

// Address range: 0x4ecdebe2 - 0x4ecdebe3
int32_t function_4ecdebe2(void) {
    // 0x4ecdebe2
    int32_t result; // 0x4ecdebe2
    return result;
}

// Address range: 0x4fcfe9d1 - 0x4fcfe9d2
int32_t function_4fcfe9d1(void) {
    // 0x4fcfe9d1
    int32_t result; // 0x4fcfe9d1
    return result;
}

// Address range: 0x51a82ab1 - 0x51a82ab2
int32_t function_51a82ab1(int32_t a1) {
    // 0x51a82ab1
    int32_t result; // 0x51a82ab1
    return result;
}

// Address range: 0x52a62791 - 0x52a62792
int32_t function_52a62791(void) {
    // 0x52a62791
    int32_t result; // 0x52a62791
    return result;
}

// Address range: 0x558cebcc - 0x558cebcd
int32_t function_558cebcc(void) {
    // 0x558cebcc
    int32_t result; // 0x558cebcc
    return result;
}

// Address range: 0x56180406 - 0x56180407
int32_t function_56180406(void) {
    // 0x56180406
    int32_t result; // 0x56180406
    return result;
}

// Address range: 0x58a6c05b - 0x58a6c05c
int32_t function_58a6c05b(void) {
    // 0x58a6c05b
    int32_t result; // 0x58a6c05b
    return result;
}

// Address range: 0x5affa4f3 - 0x5affa4f4
int32_t function_5affa4f3(void) {
    // 0x5affa4f3
    int32_t result; // 0x5affa4f3
    return result;
}

// Address range: 0x6100cb8a - 0x6100cb8b
int32_t function_6100cb8a(void) {
    // 0x6100cb8a
    int32_t result; // 0x6100cb8a
    return result;
}

// Address range: 0x6319e274 - 0x6319e275
int32_t function_6319e274(void) {
    // 0x6319e274
    int32_t result; // 0x6319e274
    return result;
}

// Address range: 0x66a618ac - 0x66a618ad
int32_t function_66a618ac(void) {
    // 0x66a618ac
    int32_t result; // 0x66a618ac
    return result;
}

// Address range: 0x6900398e - 0x6900398f
int32_t function_6900398e(void) {
    // 0x6900398e
    int32_t result; // 0x6900398e
    return result;
}

// Address range: 0x6ba6ab41 - 0x6ba6ab42
int32_t function_6ba6ab41(void) {
    // 0x6ba6ab41
    int32_t result; // 0x6ba6ab41
    return result;
}

// Address range: 0x71908972 - 0x71908973
int32_t function_71908972(void) {
    // 0x71908972
    int32_t result; // 0x71908972
    return result;
}

// Address range: 0x734ac721 - 0x734ac722
int32_t function_734ac721(void) {
    // 0x734ac721
    int32_t result; // 0x734ac721
    return result;
}

// Address range: 0x75a70732 - 0x75a70733
int32_t function_75a70732(int32_t * a1) {
    // 0x75a70732
    int32_t result; // 0x75a70732
    return result;
}

// Address range: 0x768a91dc - 0x768a91dd
int32_t function_768a91dc(void) {
    // 0x768a91dc
    int32_t result; // 0x768a91dc
    return result;
}

// Address range: 0x79f15558 - 0x79f15559
int32_t function_79f15558(void) {
    // 0x79f15558
    int32_t result; // 0x79f15558
    return result;
}

// Address range: 0x7e004061 - 0x7e004062
int32_t function_7e004061(void) {
    // 0x7e004061
    int32_t result; // 0x7e004061
    return result;
}

// Address range: 0x7ea6c36b - 0x7ea6c36c
int32_t function_7ea6c36b(void) {
    // 0x7ea6c36b
    int32_t result; // 0x7ea6c36b
    return result;
}

// Address range: 0x8143408b - 0x8143408c
int32_t function_8143408b(void) {
    // 0x8143408b
    int32_t result; // 0x8143408b
    return result;
}

// Address range: 0x88003348 - 0x88003349
int32_t function_88003348(void) {
    // 0x88003348
    int32_t result; // 0x88003348
    return result;
}

// Address range: 0x8a0b077c - 0x8a0b077d
int32_t function_8a0b077c(void) {
    // 0x8a0b077c
    int32_t result; // 0x8a0b077c
    return result;
}

// Address range: 0x8b00003d - 0x8b00003e
int32_t function_8b00003d(void) {
    // 0x8b00003d
    int32_t result; // 0x8b00003d
    return result;
}

// Address range: 0x8b00004e - 0x8b00004f
int32_t function_8b00004e(void) {
    // 0x8b00004e
    int32_t result; // 0x8b00004e
    return result;
}

// Address range: 0x8b308903 - 0x8b308904
int32_t function_8b308903(void) {
    // 0x8b308903
    int32_t result; // 0x8b308903
    return result;
}

// Address range: 0x8b9a6ce4 - 0x8b9a6ce5
int32_t function_8b9a6ce4(int32_t a1) {
    // 0x8b9a6ce4
    int32_t result; // 0x8b9a6ce4
    return result;
}

// Address range: 0x8c01e9d3 - 0x8c01e9d4
int32_t function_8c01e9d3(void) {
    // 0x8c01e9d3
    int32_t result; // 0x8c01e9d3
    return result;
}

// Address range: 0x8c02f81c - 0x8c02f81d
int32_t function_8c02f81c(void) {
    // 0x8c02f81c
    int32_t result; // 0x8c02f81c
    return result;
}

// Address range: 0x8c040e0c - 0x8c040e0d
int32_t function_8c040e0c(void) {
    // 0x8c040e0c
    int32_t result; // 0x8c040e0c
    return result;
}

// Address range: 0x8c067c12 - 0x8c067c13
int32_t function_8c067c12(void) {
    // 0x8c067c12
    int32_t result; // 0x8c067c12
    return result;
}

// Address range: 0x8c1e0110 - 0x8c1e0111
int32_t function_8c1e0110(void) {
    // 0x8c1e0110
    int32_t result; // 0x8c1e0110
    return result;
}

// Address range: 0x8c384357 - 0x8c384358
int32_t function_8c384357(void) {
    // 0x8c384357
    int32_t result; // 0x8c384357
    return result;
}

// Address range: 0x8c3ef280 - 0x8c3ef281
int32_t function_8c3ef280(void) {
    // 0x8c3ef280
    int32_t result; // 0x8c3ef280
    return result;
}

// Address range: 0x8c47056c - 0x8c47056d
int32_t function_8c47056c(void) {
    // 0x8c47056c
    int32_t result; // 0x8c47056c
    return result;
}

// Address range: 0x8c5d05cf - 0x8c5d05d0
int32_t function_8c5d05cf(void) {
    // 0x8c5d05cf
    int32_t result; // 0x8c5d05cf
    return result;
}

// Address range: 0x8c7bd7c0 - 0x8c7bd7c1
int32_t function_8c7bd7c0(void) {
    // 0x8c7bd7c0
    int32_t result; // 0x8c7bd7c0
    return result;
}

// Address range: 0x8c88cada - 0x8c88cadb
int32_t function_8c88cada(void) {
    // 0x8c88cada
    int32_t result; // 0x8c88cada
    return result;
}

// Address range: 0x8c94f711 - 0x8c94f712
int32_t function_8c94f711(void) {
    // 0x8c94f711
    int32_t result; // 0x8c94f711
    return result;
}

// Address range: 0x8c9ca3a6 - 0x8c9ca3a7
int32_t function_8c9ca3a6(void) {
    // 0x8c9ca3a6
    int32_t result; // 0x8c9ca3a6
    return result;
}

// Address range: 0x8ca5d2f2 - 0x8ca5d2f3
int32_t function_8ca5d2f2(void) {
    // 0x8ca5d2f2
    int32_t result; // 0x8ca5d2f2
    return result;
}

// Address range: 0x8ca5ffb8 - 0x8ca5ffb9
int32_t function_8ca5ffb8(void) {
    // 0x8ca5ffb8
    int32_t result; // 0x8ca5ffb8
    return result;
}

// Address range: 0x8ca60ec1 - 0x8ca60ec2
int32_t function_8ca60ec1(void) {
    // 0x8ca60ec1
    int32_t result; // 0x8ca60ec1
    return result;
}

// Address range: 0x8ca6117a - 0x8ca6117b
int32_t function_8ca6117a(void) {
    // 0x8ca6117a
    int32_t result; // 0x8ca6117a
    return result;
}

// Address range: 0x8ca61814 - 0x8ca61815
int32_t function_8ca61814(void) {
    // 0x8ca61814
    int32_t result; // 0x8ca61814
    return result;
}

// Address range: 0x8ca61d96 - 0x8ca61d97
int32_t function_8ca61d96(void) {
    // 0x8ca61d96
    int32_t result; // 0x8ca61d96
    return result;
}

// Address range: 0x8ca6234c - 0x8ca6234d
int32_t function_8ca6234c(int32_t * a1) {
    // 0x8ca6234c
    int32_t result; // 0x8ca6234c
    return result;
}

// Address range: 0x8ca6267b - 0x8ca6267c
int32_t function_8ca6267b(int16_t a1) {
    // 0x8ca6267b
    int32_t result; // 0x8ca6267b
    return result;
}

// Address range: 0x8ca62886 - 0x8ca62887
int32_t function_8ca62886(void) {
    // 0x8ca62886
    int32_t result; // 0x8ca62886
    return result;
}

// Address range: 0x8ca62b04 - 0x8ca62b05
int32_t function_8ca62b04(void) {
    // 0x8ca62b04
    int32_t result; // 0x8ca62b04
    return result;
}

// Address range: 0x8ca62b25 - 0x8ca62b26
int32_t function_8ca62b25(void) {
    // 0x8ca62b25
    int32_t result; // 0x8ca62b25
    return result;
}

// Address range: 0x8ca62cad - 0x8ca62cae
int32_t function_8ca62cad(void) {
    // 0x8ca62cad
    int32_t result; // 0x8ca62cad
    return result;
}

// Address range: 0x8ca63006 - 0x8ca63007
int32_t function_8ca63006(void) {
    // 0x8ca63006
    int32_t result; // 0x8ca63006
    return result;
}

// Address range: 0x8ca6311f - 0x8ca63120
int32_t function_8ca6311f(void) {
    // 0x8ca6311f
    int32_t result; // 0x8ca6311f
    return result;
}

// Address range: 0x8ca63a59 - 0x8ca63a5a
int32_t function_8ca63a59(void) {
    // 0x8ca63a59
    int32_t result; // 0x8ca63a59
    return result;
}

// Address range: 0x8ca6409e - 0x8ca6409f
int32_t function_8ca6409e(void) {
    // 0x8ca6409e
    int32_t result; // 0x8ca6409e
    return result;
}

// Address range: 0x8ca64615 - 0x8ca64616
int32_t function_8ca64615(void) {
    // 0x8ca64615
    int32_t result; // 0x8ca64615
    return result;
}

// Address range: 0x8ca64665 - 0x8ca64666
int32_t function_8ca64665(void) {
    // 0x8ca64665
    int32_t result; // 0x8ca64665
    return result;
}

// Address range: 0x8ca6474e - 0x8ca6474f
int32_t function_8ca6474e(void) {
    // 0x8ca6474e
    int32_t result; // 0x8ca6474e
    return result;
}

// Address range: 0x8ca64974 - 0x8ca64975
int32_t function_8ca64974(void) {
    // 0x8ca64974
    int32_t result; // 0x8ca64974
    return result;
}

// Address range: 0x8ca64f12 - 0x8ca64f13
int32_t function_8ca64f12(void) {
    // 0x8ca64f12
    int32_t result; // 0x8ca64f12
    return result;
}

// Address range: 0x8ca66a8b - 0x8ca66a8c
int32_t function_8ca66a8b(void) {
    // 0x8ca66a8b
    int32_t result; // 0x8ca66a8b
    return result;
}

// Address range: 0x8ca66c6b - 0x8ca66c6c
int32_t function_8ca66c6b(void) {
    // 0x8ca66c6b
    int32_t result; // 0x8ca66c6b
    return result;
}

// Address range: 0x8ca671cf - 0x8ca671d0
int32_t function_8ca671cf(void) {
    // 0x8ca671cf
    int32_t result; // 0x8ca671cf
    return result;
}

// Address range: 0x8ca67233 - 0x8ca67234
int32_t function_8ca67233(void) {
    // 0x8ca67233
    int32_t result; // 0x8ca67233
    return result;
}

// Address range: 0x8ca67578 - 0x8ca67579
int32_t function_8ca67578(void) {
    // 0x8ca67578
    int32_t result; // 0x8ca67578
    return result;
}

// Address range: 0x8ca6761c - 0x8ca6761d
int32_t function_8ca6761c(void) {
    // 0x8ca6761c
    int32_t result; // 0x8ca6761c
    return result;
}

// Address range: 0x8ca67ee2 - 0x8ca67ee3
int32_t function_8ca67ee2(void) {
    // 0x8ca67ee2
    int32_t result; // 0x8ca67ee2
    return result;
}

// Address range: 0x8ca67fb2 - 0x8ca67fb3
int32_t function_8ca67fb2(void) {
    // 0x8ca67fb2
    int32_t result; // 0x8ca67fb2
    return result;
}

// Address range: 0x8ca6809a - 0x8ca6809b
int32_t function_8ca6809a(void) {
    // 0x8ca6809a
    int32_t result; // 0x8ca6809a
    return result;
}

// Address range: 0x8ca68182 - 0x8ca68183
int32_t function_8ca68182(void) {
    // 0x8ca68182
    int32_t result; // 0x8ca68182
    return result;
}

// Address range: 0x8ca68431 - 0x8ca68432
int32_t function_8ca68431(int16_t a1) {
    // 0x8ca68431
    int32_t result; // 0x8ca68431
    return result;
}

// Address range: 0x8ca6854a - 0x8ca6854b
int32_t function_8ca6854a(int32_t a1) {
    // 0x8ca6854a
    int32_t result; // 0x8ca6854a
    return result;
}

// Address range: 0x8ca68727 - 0x8ca68728
int32_t function_8ca68727(void) {
    // 0x8ca68727
    int32_t result; // 0x8ca68727
    return result;
}

// Address range: 0x8ca68bb0 - 0x8ca68bb1
int32_t function_8ca68bb0(void) {
    // 0x8ca68bb0
    int32_t result; // 0x8ca68bb0
    return result;
}

// Address range: 0x8ca68f9c - 0x8ca68f9d
int32_t function_8ca68f9c(void) {
    // 0x8ca68f9c
    int32_t result; // 0x8ca68f9c
    return result;
}

// Address range: 0x8ca6a263 - 0x8ca6a264
int32_t function_8ca6a263(void) {
    // 0x8ca6a263
    int32_t result; // 0x8ca6a263
    return result;
}

// Address range: 0x8ca6a329 - 0x8ca6a32a
int32_t function_8ca6a329(void) {
    // 0x8ca6a329
    int32_t result; // 0x8ca6a329
    return result;
}

// Address range: 0x8ca6a808 - 0x8ca6a809
int32_t function_8ca6a808(void) {
    // 0x8ca6a808
    int32_t result; // 0x8ca6a808
    return result;
}

// Address range: 0x8ca6a893 - 0x8ca6a894
int32_t function_8ca6a893(void) {
    // 0x8ca6a893
    int32_t result; // 0x8ca6a893
    return result;
}

// Address range: 0x8ca6aa67 - 0x8ca6aa68
int32_t function_8ca6aa67(void) {
    // 0x8ca6aa67
    int32_t result; // 0x8ca6aa67
    return result;
}

// Address range: 0x8ca6ae74 - 0x8ca6ae75
int32_t function_8ca6ae74(void) {
    // 0x8ca6ae74
    int32_t result; // 0x8ca6ae74
    return result;
}

// Address range: 0x8ca6b2c3 - 0x8ca6b2c4
int32_t function_8ca6b2c3(void) {
    // 0x8ca6b2c3
    int32_t result; // 0x8ca6b2c3
    return result;
}

// Address range: 0x8ca6b604 - 0x8ca6b605
int32_t function_8ca6b604(void) {
    // 0x8ca6b604
    int32_t result; // 0x8ca6b604
    return result;
}

// Address range: 0x8ca6b7bd - 0x8ca6b7be
int32_t function_8ca6b7bd(int32_t a1) {
    // 0x8ca6b7bd
    int32_t result; // 0x8ca6b7bd
    return result;
}

// Address range: 0x8ca6beab - 0x8ca6beac
int32_t function_8ca6beab(void) {
    // 0x8ca6beab
    int32_t result; // 0x8ca6beab
    return result;
}

// Address range: 0x8ca6bf3c - 0x8ca6bf3d
int32_t function_8ca6bf3c(void) {
    // 0x8ca6bf3c
    int32_t result; // 0x8ca6bf3c
    return result;
}

// Address range: 0x8ca6c008 - 0x8ca6c009
int32_t function_8ca6c008(void) {
    // 0x8ca6c008
    int32_t result; // 0x8ca6c008
    return result;
}

// Address range: 0x8ca6c0c2 - 0x8ca6c0c3
int32_t function_8ca6c0c2(void) {
    // 0x8ca6c0c2
    int32_t result; // 0x8ca6c0c2
    return result;
}

// Address range: 0x8ca6c2e0 - 0x8ca6c2e1
int32_t function_8ca6c2e0(void) {
    // 0x8ca6c2e0
    int32_t result; // 0x8ca6c2e0
    return result;
}

// Address range: 0x8ca6c579 - 0x8ca6c57a
int32_t function_8ca6c579(void) {
    // 0x8ca6c579
    int32_t result; // 0x8ca6c579
    return result;
}

// Address range: 0x8ca6c683 - 0x8ca6c684
int32_t function_8ca6c683(void) {
    // 0x8ca6c683
    int32_t result; // 0x8ca6c683
    return result;
}

// Address range: 0x8ca6c8e7 - 0x8ca6c8e8
int32_t function_8ca6c8e7(void) {
    // 0x8ca6c8e7
    int32_t result; // 0x8ca6c8e7
    return result;
}

// Address range: 0x8ca6d005 - 0x8ca6d006
int32_t function_8ca6d005(void) {
    // 0x8ca6d005
    int32_t result; // 0x8ca6d005
    return result;
}

// Address range: 0x8ca6d238 - 0x8ca6d239
int32_t function_8ca6d238(void) {
    // 0x8ca6d238
    int32_t result; // 0x8ca6d238
    return result;
}

// Address range: 0x8ca6d4f9 - 0x8ca6d4fa
int32_t function_8ca6d4f9(void) {
    // 0x8ca6d4f9
    int32_t result; // 0x8ca6d4f9
    return result;
}

// Address range: 0x8ca6d547 - 0x8ca6d548
int32_t function_8ca6d547(void) {
    // 0x8ca6d547
    int32_t result; // 0x8ca6d547
    return result;
}

// Address range: 0x8ca6d6f0 - 0x8ca6d6f1
int32_t function_8ca6d6f0(void) {
    // 0x8ca6d6f0
    int32_t result; // 0x8ca6d6f0
    return result;
}

// Address range: 0x8ca6d74e - 0x8ca6d74f
int32_t function_8ca6d74e(void) {
    // 0x8ca6d74e
    int32_t result; // 0x8ca6d74e
    return result;
}

// Address range: 0x8ca6d91d - 0x8ca6d91e
int32_t function_8ca6d91d(void) {
    // 0x8ca6d91d
    int32_t result; // 0x8ca6d91d
    return result;
}

// Address range: 0x8ca6d9a5 - 0x8ca6d9a6
int32_t function_8ca6d9a5(void) {
    // 0x8ca6d9a5
    int32_t result; // 0x8ca6d9a5
    return result;
}

// Address range: 0x8ca6da9e - 0x8ca6da9f
int32_t function_8ca6da9e(void) {
    // 0x8ca6da9e
    int32_t result; // 0x8ca6da9e
    return result;
}

// Address range: 0x8ca6dbb2 - 0x8ca6dbb3
int32_t function_8ca6dbb2(void) {
    // 0x8ca6dbb2
    int32_t result; // 0x8ca6dbb2
    return result;
}

// Address range: 0x8ca6dc03 - 0x8ca6dc04
int32_t function_8ca6dc03(void) {
    // 0x8ca6dc03
    int32_t result; // 0x8ca6dc03
    return result;
}

// Address range: 0x8ca6dd32 - 0x8ca6dd33
int32_t function_8ca6dd32(void) {
    // 0x8ca6dd32
    int32_t result; // 0x8ca6dd32
    return result;
}

// Address range: 0x8ca6e0e4 - 0x8ca6e0e5
int32_t function_8ca6e0e4(void) {
    // 0x8ca6e0e4
    int32_t result; // 0x8ca6e0e4
    return result;
}

// Address range: 0x8ca6e30a - 0x8ca6e30b
int32_t function_8ca6e30a(void) {
    // 0x8ca6e30a
    int32_t result; // 0x8ca6e30a
    return result;
}

// Address range: 0x8ca6e465 - 0x8ca6e466
int32_t function_8ca6e465(void) {
    // 0x8ca6e465
    int32_t result; // 0x8ca6e465
    return result;
}

// Address range: 0x8ca6e52d - 0x8ca6e52e
int32_t function_8ca6e52d(void) {
    // 0x8ca6e52d
    int32_t result; // 0x8ca6e52d
    return result;
}

// Address range: 0x8ca6e773 - 0x8ca6e774
int32_t function_8ca6e773(void) {
    // 0x8ca6e773
    int32_t result; // 0x8ca6e773
    return result;
}

// Address range: 0x8ca6e77c - 0x8ca6e77d
int32_t function_8ca6e77c(void) {
    // 0x8ca6e77c
    int32_t result; // 0x8ca6e77c
    return result;
}

// Address range: 0x8ca6eed3 - 0x8ca6eed4
int32_t function_8ca6eed3(void) {
    // 0x8ca6eed3
    int32_t result; // 0x8ca6eed3
    return result;
}

// Address range: 0x8ca6f077 - 0x8ca6f078
int32_t function_8ca6f077(void) {
    // 0x8ca6f077
    int32_t result; // 0x8ca6f077
    return result;
}

// Address range: 0x8ca6f40c - 0x8ca6f40d
int32_t function_8ca6f40c(void) {
    // 0x8ca6f40c
    int32_t result; // 0x8ca6f40c
    return result;
}

// Address range: 0x8ca6f4da - 0x8ca6f4db
int32_t function_8ca6f4da(void) {
    // 0x8ca6f4da
    int32_t result; // 0x8ca6f4da
    return result;
}

// Address range: 0x8ca6f522 - 0x8ca6f523
int32_t function_8ca6f522(void) {
    // 0x8ca6f522
    int32_t result; // 0x8ca6f522
    return result;
}

// Address range: 0x8ca6f670 - 0x8ca6f671
int32_t function_8ca6f670(void) {
    // 0x8ca6f670
    int32_t result; // 0x8ca6f670
    return result;
}

// Address range: 0x8ca6f749 - 0x8ca6f74a
int32_t function_8ca6f749(void) {
    // 0x8ca6f749
    int32_t result; // 0x8ca6f749
    return result;
}

// Address range: 0x8ca6faa9 - 0x8ca6faaa
int32_t function_8ca6faa9(void) {
    // 0x8ca6faa9
    int32_t result; // 0x8ca6faa9
    return result;
}

// Address range: 0x8ca6fde0 - 0x8ca6fde1
int32_t function_8ca6fde0(void) {
    // 0x8ca6fde0
    int32_t result; // 0x8ca6fde0
    return result;
}

// Address range: 0x8ca6feff - 0x8ca6ff00
int32_t function_8ca6feff(void) {
    // 0x8ca6feff
    int32_t result; // 0x8ca6feff
    return result;
}

// Address range: 0x8ca7033d - 0x8ca7033e
int32_t function_8ca7033d(void) {
    // 0x8ca7033d
    int32_t result; // 0x8ca7033d
    return result;
}

// Address range: 0x8ca70655 - 0x8ca70656
int32_t function_8ca70655(void) {
    // 0x8ca70655
    int32_t result; // 0x8ca70655
    return result;
}

// Address range: 0x8ca707cc - 0x8ca707cd
int32_t function_8ca707cc(void) {
    // 0x8ca707cc
    int32_t result; // 0x8ca707cc
    return result;
}

// Address range: 0x8ca70aab - 0x8ca70aac
int32_t function_8ca70aab(void) {
    // 0x8ca70aab
    int32_t result; // 0x8ca70aab
    return result;
}

// Address range: 0x8ca71680 - 0x8ca71681
int32_t function_8ca71680(void) {
    // 0x8ca71680
    int32_t result; // 0x8ca71680
    return result;
}

// Address range: 0x8caa6b7b - 0x8caa6b7c
int32_t function_8caa6b7b(void) {
    // 0x8caa6b7b
    int32_t result; // 0x8caa6b7b
    return result;
}

// Address range: 0x8cabd452 - 0x8cabd453
int32_t function_8cabd452(void) {
    // 0x8cabd452
    int32_t result; // 0x8cabd452
    return result;
}

// Address range: 0x8cacd9ec - 0x8cacd9ed
int32_t function_8cacd9ec(void) {
    // 0x8cacd9ec
    int32_t result; // 0x8cacd9ec
    return result;
}

// Address range: 0x8cb3c9b1 - 0x8cb3c9b2
int32_t function_8cb3c9b1(void) {
    // 0x8cb3c9b1
    int32_t result; // 0x8cb3c9b1
    return result;
}

// Address range: 0x8cc7baba - 0x8cc7babb
int32_t function_8cc7baba(void) {
    // 0x8cc7baba
    int32_t result; // 0x8cc7baba
    return result;
}

// Address range: 0x8ccd8a34 - 0x8ccd8a35
int32_t function_8ccd8a34(void) {
    // 0x8ccd8a34
    int32_t result; // 0x8ccd8a34
    return result;
}

// Address range: 0x8cded146 - 0x8cded147
int32_t function_8cded146(void) {
    // 0x8cded146
    int32_t result; // 0x8cded146
    return result;
}

// Address range: 0x8cedcfc1 - 0x8cedcfc2
int32_t function_8cedcfc1(void) {
    // 0x8cedcfc1
    int32_t result; // 0x8cedcfc1
    return result;
}

// Address range: 0x8cf0f39a - 0x8cf0f39b
int32_t function_8cf0f39a(void) {
    // 0x8cf0f39a
    int32_t result; // 0x8cf0f39a
    return result;
}

// Address range: 0x8cf3c24c - 0x8cf3c24d
int32_t function_8cf3c24c(void) {
    // 0x8cf3c24c
    int32_t result; // 0x8cf3c24c
    return result;
}

// Address range: 0x8cf9a887 - 0x8cf9a888
int32_t function_8cf9a887(void) {
    // 0x8cf9a887
    int32_t result; // 0x8cf9a887
    return result;
}

// Address range: 0x8de27876 - 0x8de27877
int32_t function_8de27876(void) {
    // 0x8de27876
    int32_t result; // 0x8de27876
    return result;
}

// Address range: 0x8e0d577d - 0x8e0d577e
int32_t function_8e0d577d(void) {
    // 0x8e0d577d
    int32_t result; // 0x8e0d577d
    return result;
}

// Address range: 0x900042e5 - 0x900042e6
int32_t function_900042e5(void) {
    // 0x900042e5
    int32_t result; // 0x900042e5
    return result;
}

// Address range: 0x91004ab2 - 0x91004ab3
int32_t function_91004ab2(void) {
    // 0x91004ab2
    int32_t result; // 0x91004ab2
    return result;
}

// Address range: 0x91ece804 - 0x91ece805
int32_t function_91ece804(void) {
    // 0x91ece804
    int32_t result; // 0x91ece804
    return result;
}

// Address range: 0x93a68d06 - 0x93a68d07
int32_t function_93a68d06(void) {
    // 0x93a68d06
    int32_t result; // 0x93a68d06
    return result;
}

// Address range: 0x944f5cfc - 0x944f5cfd
int32_t function_944f5cfc(void) {
    // 0x944f5cfc
    int32_t result; // 0x944f5cfc
    return result;
}

// Address range: 0x96004a19 - 0x96004a1a
int32_t function_96004a19(void) {
    // 0x96004a19
    int32_t result; // 0x96004a19
    return result;
}

// Address range: 0x972948be - 0x972948bf
int32_t function_972948be(void) {
    // 0x972948be
    int32_t result; // 0x972948be
    return result;
}

// Address range: 0x98a6d4a0 - 0x98a6d4a1
int32_t function_98a6d4a0(void) {
    // 0x98a6d4a0
    int32_t result; // 0x98a6d4a0
    return result;
}

// Address range: 0x9ba68587 - 0x9ba68588
int32_t function_9ba68587(void) {
    // 0x9ba68587
    int32_t result; // 0x9ba68587
    return result;
}

// Address range: 0xa27eaaf5 - 0xa27eaaf6
int32_t function_a27eaaf5(void) {
    // 0xa27eaaf5
    int32_t result; // 0xa27eaaf5
    return result;
}

// Address range: 0xa3f55b79 - 0xa3f55b7a
int32_t function_a3f55b79(void) {
    // 0xa3f55b79
    int32_t result; // 0xa3f55b79
    return result;
}

// Address range: 0xa3ffffe4 - 0xa3ffffe5
int32_t function_a3ffffe4(void) {
    // 0xa3ffffe4
    int32_t result; // 0xa3ffffe4
    return result;
}

// Address range: 0xa5dc9c51 - 0xa5dc9c52
int32_t function_a5dc9c51(void) {
    // 0xa5dc9c51
    int32_t result; // 0xa5dc9c51
    return result;
}

// Address range: 0xa5f302e9 - 0xa5f302ea
int32_t function_a5f302e9(void) {
    // 0xa5f302e9
    int32_t result; // 0xa5f302e9
    return result;
}

// Address range: 0xa81a391e - 0xa81a391f
int32_t function_a81a391e(void) {
    // 0xa81a391e
    int32_t result; // 0xa81a391e
    return result;
}

// Address range: 0xa98d044e - 0xa98d044f
int32_t function_a98d044e(void) {
    // 0xa98d044e
    int32_t result; // 0xa98d044e
    return result;
}

// Address range: 0xb2017228 - 0xb2017229
int32_t function_b2017228(void) {
    // 0xb2017228
    int32_t result; // 0xb2017228
    return result;
}

// Address range: 0xb3e99cec - 0xb3e99ced
int32_t function_b3e99cec(void) {
    // 0xb3e99cec
    int32_t result; // 0xb3e99cec
    return result;
}

// Address range: 0xb3ed6094 - 0xb3ed6095
int32_t function_b3ed6094(void) {
    // 0xb3ed6094
    int32_t result; // 0xb3ed6094
    return result;
}

// Address range: 0xb502e9c1 - 0xb502e9c2
int32_t function_b502e9c1(void) {
    // 0xb502e9c1
    int32_t result; // 0xb502e9c1
    return result;
}

// Address range: 0xb6003e72 - 0xb6003e73
int32_t function_b6003e72(void) {
    // 0xb6003e72
    int32_t result; // 0xb6003e72
    return result;
}

// Address range: 0xb8a6a01b - 0xb8a6a01c
int32_t function_b8a6a01b(void) {
    // 0xb8a6a01b
    int32_t result; // 0xb8a6a01b
    return result;
}

// Address range: 0xbd0057b9 - 0xbd0057ba
int32_t function_bd0057b9(void) {
    // 0xbd0057b9
    int32_t result; // 0xbd0057b9
    return result;
}

// Address range: 0xbd402da4 - 0xbd402da5
int32_t function_bd402da4(void) {
    // 0xbd402da4
    int32_t result; // 0xbd402da4
    return result;
}

// Address range: 0xbe2b5ef9 - 0xbe2b5efa
int32_t function_be2b5ef9(void) {
    // 0xbe2b5ef9
    int32_t result; // 0xbe2b5ef9
    return result;
}

// Address range: 0xc0008963 - 0xc0008964
int32_t function_c0008963(void) {
    // 0xc0008963
    int32_t result; // 0xc0008963
    return result;
}

// Address range: 0xc0a64830 - 0xc0a64831
int32_t function_c0a64830(void) {
    // 0xc0a64830
    int32_t result; // 0xc0a64830
    return result;
}

// Address range: 0xc3c9d5c6 - 0xc3c9d5c7
int32_t function_c3c9d5c6(void) {
    // 0xc3c9d5c6
    int32_t result; // 0xc3c9d5c6
    return result;
}

// Address range: 0xc600d9b8 - 0xc600d9b9
int32_t function_c600d9b8(void) {
    // 0xc600d9b8
    int32_t result; // 0xc600d9b8
    return result;
}

// Address range: 0xcc005977 - 0xcc005978
int32_t function_cc005977(void) {
    // 0xcc005977
    int32_t result; // 0xcc005977
    return result;
}

// Address range: 0xd1116dd7 - 0xd1116dd8
int32_t function_d1116dd7(void) {
    // 0xd1116dd7
    int32_t result; // 0xd1116dd7
    return result;
}

// Address range: 0xd1a602d0 - 0xd1a602d1
int32_t function_d1a602d0(void) {
    // 0xd1a602d0
    int32_t result; // 0xd1a602d0
    return result;
}

// Address range: 0xd4ff9a2a - 0xd4ff9a2b
int32_t function_d4ff9a2a(void) {
    // 0xd4ff9a2a
    int32_t result; // 0xd4ff9a2a
    return result;
}

// Address range: 0xd6e0c5c1 - 0xd6e0c5c2
int32_t function_d6e0c5c1(void) {
    // 0xd6e0c5c1
    int32_t result; // 0xd6e0c5c1
    return result;
}

// Address range: 0xdb005977 - 0xdb005978
int32_t function_db005977(int32_t a1) {
    // 0xdb005977
    int32_t result; // 0xdb005977
    return result;
}

// Address range: 0xdc826521 - 0xdc826522
int32_t function_dc826521(void) {
    // 0xdc826521
    int32_t result; // 0xdc826521
    return result;
}

// Address range: 0xe245a9e3 - 0xe245a9e4
int32_t function_e245a9e3(void) {
    // 0xe245a9e3
    int32_t result; // 0xe245a9e3
    return result;
}

// Address range: 0xe30113e5 - 0xe30113e6
int32_t function_e30113e5(int16_t a1) {
    // 0xe30113e5
    int32_t result; // 0xe30113e5
    return result;
}

// Address range: 0xe4a6a98d - 0xe4a6a98e
int32_t function_e4a6a98d(void) {
    // 0xe4a6a98d
    int32_t result; // 0xe4a6a98d
    return result;
}

// Address range: 0xe830b293 - 0xe830b294
int32_t function_e830b293(void) {
    // 0xe830b293
    int32_t result; // 0xe830b293
    return result;
}

// Address range: 0xe89b014d - 0xe89b014e
int32_t function_e89b014d(void) {
    // 0xe89b014d
    int32_t result; // 0xe89b014d
    return result;
}

// Address range: 0xe90547c4 - 0xe90547c5
int32_t function_e90547c4(void) {
    // 0xe90547c4
    int32_t result; // 0xe90547c4
    return result;
}

// Address range: 0xe950f125 - 0xe950f126
int32_t function_e950f125(int32_t a1) {
    // 0xe950f125
    int32_t result; // 0xe950f125
    return result;
}

// Address range: 0xe9a6df21 - 0xe9a6df22
int32_t function_e9a6df21(void) {
    // 0xe9a6df21
    int32_t result; // 0xe9a6df21
    return result;
}

// Address range: 0xea002dab - 0xea002dac
int32_t function_ea002dab(void) {
    // 0xea002dab
    int32_t result; // 0xea002dab
    return result;
}

// Address range: 0xeda6bffb - 0xeda6bffc
int32_t function_eda6bffb(void) {
    // 0xeda6bffb
    int32_t result; // 0xeda6bffb
    return result;
}

// Address range: 0xee005a73 - 0xee005a74
int32_t function_ee005a73(void) {
    // 0xee005a73
    int32_t result; // 0xee005a73
    return result;
}

// Address range: 0xf40df47a - 0xf40df47b
int32_t function_f40df47a(void) {
    // 0xf40df47a
    int32_t result; // 0xf40df47a
    return result;
}

// Address range: 0xf49ca082 - 0xf49ca083
int32_t function_f49ca082(int32_t a1) {
    // 0xf49ca082
    int32_t result; // 0xf49ca082
    return result;
}

// Address range: 0xf4f41ab1 - 0xf4f41ab2
int32_t function_f4f41ab1(void) {
    // 0xf4f41ab1
    int32_t result; // 0xf4f41ab1
    return result;
}

// Address range: 0xf6cbb47b - 0xf6cbb47c
int32_t function_f6cbb47b(void) {
    // 0xf6cbb47b
    int32_t result; // 0xf6cbb47b
    return result;
}

// Address range: 0xf8a6a796 - 0xf8a6a797
int32_t function_f8a6a796(void) {
    // 0xf8a6a796
    int32_t result; // 0xf8a6a796
    return result;
}

// Address range: 0xf9004a2a - 0xf9004a2b
int32_t function_f9004a2a(void) {
    // 0xf9004a2a
    int32_t result; // 0xf9004a2a
    return result;
}

// Address range: 0xf922fd55 - 0xf922fd56
int32_t function_f922fd55(void) {
    // 0xf922fd55
    int32_t result; // 0xf922fd55
    return result;
}

// Address range: 0xf9a6a60a - 0xf9a6a60b
int32_t function_f9a6a60a(void) {
    // 0xf9a6a60a
    int32_t result; // 0xf9a6a60a
    return result;
}

// Address range: 0xf9fb0069 - 0xf9fb006a
int32_t function_f9fb0069(void) {
    // 0xf9fb0069
    int32_t result; // 0xf9fb0069
    return result;
}

// Address range: 0xfaa68357 - 0xfaa68358
int32_t function_faa68357(void) {
    // 0xfaa68357
    int32_t result; // 0xfaa68357
    return result;
}

// Address range: 0xfd004ab2 - 0xfd004ab3
int32_t function_fd004ab2(void) {
    // 0xfd004ab2
    int32_t result; // 0xfd004ab2
    return result;
}

// Address range: 0xfd455568 - 0xfd455569
int32_t function_fd455568(void) {
    // 0xfd455568
    int32_t result; // 0xfd455568
    return result;
}

// Address range: 0xfe436498 - 0xfe436499
int32_t function_fe436498(void) {
    // 0xfe436498
    int32_t result; // 0xfe436498
    return result;
}

// Address range: 0xff157ccd - 0xff157cce
int32_t function_ff157ccd(int32_t a1) {
    // 0xff157ccd
    int32_t result; // 0xff157ccd
    return result;
}

// Address range: 0xffbf98e8 - 0xffbf98e9
int32_t function_ffbf98e8(void) {
    // 0xffbf98e8
    int32_t result; // 0xffbf98e8
    return result;
}

// Address range: 0xfff1ffd7 - 0xfff1ffd8
int32_t function_fff1ffd7(void) {
    // 0xfff1ffd7
    int32_t result; // 0xfff1ffd7
    return result;
}

// Address range: 0xffff99be - 0xffff99bf
int32_t function_ffff99be(void) {
    // 0xffff99be
    int32_t result; // 0xffff99be
    return result;
}

// Address range: 0xffffce86 - 0xffffce87
int32_t function_ffffce86(int32_t a1) {
    // 0xffffce86
    int32_t result; // 0xffffce86
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int32_t _3f_terminate_40__40_YAXXZ(void);
// void __cdecl _initterm(_In_ _PVFV * First, _In_ _PVFV * Last);
// wchar_t * __cdecl _wcsrev(_Inout_z_ wchar_t * String);
// BOOL CheckMenuRadioItem(_In_ HMENU hmenu, _In_ UINT first, _In_ UINT last, _In_ UINT check, _In_ UINT flags);
// BOOL CheckRadioButton(_In_ HWND hDlg, _In_ int nIDFirstButton, _In_ int nIDLastButton, _In_ int nIDCheckButton);
// HWND ChildWindowFromPoint(_In_ HWND hWndParent, _In_ POINT Point);
// LRESULT DefWindowProcW(_In_ HWND hWnd, _In_ UINT Msg, _In_ WPARAM wParam, _In_ LPARAM lParam);
// BOOL EnableWindow(_In_ HWND hWnd, _In_ BOOL bEnable);
// int GetDlgCtrlID(_In_ HWND hWnd);
// HMENU GetMenu(_In_ HWND hWnd);
// BOOL GetProcessDefaultLayout(_Out_ DWORD * pdwDefaultLayout);
// HBRUSH GetSysColorBrush(_In_ int nIndex);
// BOOL GlobalUnlock(_In_ HGLOBAL hMem);
// BOOL HideCaret(_In_opt_ HWND hWnd);
// HCURSOR LoadCursorW(_In_opt_ HINSTANCE hInstance, _In_ LPCWSTR lpCursorName);
// HLOCAL LocalAlloc(_In_ UINT uFlags, _In_ SIZE_T uBytes);
// HLOCAL LocalFree(HLOCAL hMem);
// int lstrlenW(_In_ LPCWSTR lpString);
// void * memmove(void * dest, const void * src, size_t n);
// ATOM RegisterClassExW(_In_ const WNDCLASSEXW *);
// LSTATUS RegOpenKeyExA(_In_ HKEY hKey, _In_opt_ LPCSTR lpSubKey, _In_opt_ DWORD ulOptions, _In_ REGSAM samDesired, _Out_ PHKEY phkResult);
// LRESULT SendMessageW(_In_ HWND hWnd, _In_ UINT Msg, WPARAM wParam, LPARAM lParam);
// COLORREF SetTextColor(_In_ HDC hdc, _In_ COLORREF color);
// wchar_t * wcschr(wchar_t * wcs, wchar_t wc);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (7.0)
// Detected functions: 1401
